diff --git a/include/fcl/broadphase/detail/hierarchy_tree-inl.h b/include/fcl/broadphase/detail/hierarchy_tree-inl.h
index 1438eb9..6381b86 100644
--- a/include/fcl/broadphase/detail/hierarchy_tree-inl.h
+++ b/include/fcl/broadphase/detail/hierarchy_tree-inl.h
@@ -326,6 +326,7 @@ typename HierarchyTree<BV>::NodeType*& HierarchyTree<BV>::getRoot()
 template<typename BV>
 void HierarchyTree<BV>::print(NodeType* root, int depth)
 {
+#if FCL_ENABLE_STD_LOGGING
   for(int i = 0; i < depth; ++i)
     std::cout << " ";
   std::cout << " (" << root->bv.min_[0] << ", " << root->bv.min_[1] << ", " << root->bv.min_[2] << "; " << root->bv.max_[0] << ", " << root->bv.max_[1] << ", " << root->bv.max_[2] << ")" << std::endl;
@@ -337,6 +338,10 @@ void HierarchyTree<BV>::print(NodeType* root, int depth)
     print(root->children[0], depth+1);
     print(root->children[1], depth+1);
   }
+#else
+  (void)root;
+  (void)depth;
+#endif
 }
 
 //==============================================================================
diff --git a/include/fcl/broadphase/detail/hierarchy_tree_array-inl.h b/include/fcl/broadphase/detail/hierarchy_tree_array-inl.h
index b4edc40..cb999a0 100644
--- a/include/fcl/broadphase/detail/hierarchy_tree_array-inl.h
+++ b/include/fcl/broadphase/detail/hierarchy_tree_array-inl.h
@@ -503,6 +503,7 @@ typename HierarchyTree<BV>::NodeType* HierarchyTree<BV>::getNodes() const
 template<typename BV>
 void HierarchyTree<BV>::print(size_t root, int depth)
 {
+#if FCL_ENABLE_STD_LOGGING
   for(int i = 0; i < depth; ++i)
     std::cout << " ";
   NodeType* n = nodes + root;
@@ -515,6 +516,10 @@ void HierarchyTree<BV>::print(size_t root, int depth)
     print(n->children[0], depth+1);
     print(n->children[1], depth+1);
   }
+#else
+  (void)root;
+  (void)depth;
+#endif
 }
 
 //==============================================================================
diff --git a/include/fcl/broadphase/detail/interval_tree_node-inl.h b/include/fcl/broadphase/detail/interval_tree_node-inl.h
index 2badc04..3e35502 100644
--- a/include/fcl/broadphase/detail/interval_tree_node-inl.h
+++ b/include/fcl/broadphase/detail/interval_tree_node-inl.h
@@ -79,6 +79,7 @@ template <typename S>
 void IntervalTreeNode<S>::print(
     IntervalTreeNode<S>* nil, IntervalTreeNode<S>* root) const
 {
+#if FCL_ENABLE_STD_LOGGING
   stored_interval->print();
   std::cout << ", k = " << key << ", h = " << high << ", mH = " << max_high;
   std::cout << "  l->key = ";
@@ -88,6 +89,10 @@ void IntervalTreeNode<S>::print(
   std::cout << "  p->key = ";
   if(parent == root) std::cout << "nullptr"; else std::cout << parent->key;
   std::cout << "  red = " << (int)red << std::endl;
+#else
+  (void)nil;
+  (void)root;
+#endif
 }
 
 } // namespace detail
diff --git a/include/fcl/common/detail/profiler.h b/include/fcl/common/detail/profiler.h
index 76e3675..aefdf64 100644
--- a/include/fcl/common/detail/profiler.h
+++ b/include/fcl/common/detail/profiler.h
@@ -40,7 +40,7 @@
 
 #include <algorithm>
 #include <chrono>
-#include <iostream>
+#include <iosfwd>
 #include <map>
 #include <cmath>
 #include <mutex>
@@ -131,12 +131,12 @@ public:
   /// @brief Print the status of the profiled code chunks and
   /// events. Optionally, computation done by different threads
   /// can be printed separately.
-  static void Status(std::ostream &out = std::cout, bool merge = true);
+  static void Status(std::ostream &out, bool merge = true);
 
   /// @brief Print the status of the profiled code chunks and
   /// events. Optionally, computation done by different threads
   /// can be printed separately.
-  void status(std::ostream &out = std::cout, bool merge = true);
+  void status(std::ostream &out, bool merge = true);
 
   /// @brief Check if the profiler is counting time or not
   bool running(void) const;
diff --git a/include/fcl/common/types.h b/include/fcl/common/types.h
index 892e2b0..92c519c 100644
--- a/include/fcl/common/types.h
+++ b/include/fcl/common/types.h
@@ -38,6 +38,7 @@
 #ifndef FCL_DATA_TYPES_H
 #define FCL_DATA_TYPES_H
 
+#include <cassert>
 #include <cstddef>
 #include <cstdint>
 #include <vector>
@@ -46,6 +47,7 @@
 #include <Eigen/Dense>
 #include <Eigen/StdVector>
 #include "fcl/export.h"
+#include "fcl/logging.h"
 
 namespace fcl
 {
diff --git a/include/fcl/geometry/bvh/BVH_model-inl.h b/include/fcl/geometry/bvh/BVH_model-inl.h
index 906a593..9cadae4 100644
--- a/include/fcl/geometry/bvh/BVH_model-inl.h
+++ b/include/fcl/geometry/bvh/BVH_model-inl.h
@@ -228,7 +228,7 @@ int BVHModel<BV>::beginModel(int num_tris_, int num_vertices_)
     tri_indices = new(std::nothrow) Triangle[num_tris_allocated];
     if(!tri_indices)
     {
-      std::cerr << "BVH Error! Out of memory for tri_indices array on BeginModel() call!\n";
+      FCL_CERR << "BVH Error! Out of memory for tri_indices array on BeginModel() call!\n";
       return BVH_ERR_MODEL_OUT_OF_MEMORY;
     }
   }
@@ -236,13 +236,13 @@ int BVHModel<BV>::beginModel(int num_tris_, int num_vertices_)
   vertices = new Vector3<S>[num_vertices_allocated];
   if(!vertices)
   {
-    std::cerr << "BVH Error! Out of memory for vertices array on BeginModel() call!\n";
+    FCL_CERR << "BVH Error! Out of memory for vertices array on BeginModel() call!\n";
     return BVH_ERR_MODEL_OUT_OF_MEMORY;
   }
 
   if(build_state != BVH_BUILD_STATE_EMPTY)
   {
-    std::cerr << "BVH Warning! Call beginModel() on a BVHModel that is not empty. This model was cleared and previous triangles/vertices were lost.\n";
+    FCL_CERR << "BVH Warning! Call beginModel() on a BVHModel that is not empty. This model was cleared and previous triangles/vertices were lost.\n";
     build_state = BVH_BUILD_STATE_EMPTY;
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
@@ -258,7 +258,7 @@ int BVHModel<BV>::addVertex(const Vector3<S>& p)
 {
   if(build_state != BVH_BUILD_STATE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call addVertex() in a wrong order. addVertex() was ignored. Must do a beginModel() to clear the model for addition of new vertices.\n";
+    FCL_CERR << "BVH Warning! Call addVertex() in a wrong order. addVertex() was ignored. Must do a beginModel() to clear the model for addition of new vertices.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -267,7 +267,7 @@ int BVHModel<BV>::addVertex(const Vector3<S>& p)
     Vector3<S>* temp = new Vector3<S>[num_vertices_allocated * 2];
     if(!temp)
     {
-      std::cerr << "BVH Error! Out of memory for vertices array on addVertex() call!\n";
+      FCL_CERR << "BVH Error! Out of memory for vertices array on addVertex() call!\n";
       return BVH_ERR_MODEL_OUT_OF_MEMORY;
     }
 
@@ -289,7 +289,7 @@ int BVHModel<BV>::addTriangle(const Vector3<S>& p1, const Vector3<S>& p2, const
 {
   if(build_state == BVH_BUILD_STATE_PROCESSED)
   {
-    std::cerr << "BVH Warning! Call addTriangle() in a wrong order. addTriangle() was ignored. Must do a beginModel() to clear the model for addition of new triangles.\n";
+    FCL_CERR << "BVH Warning! Call addTriangle() in a wrong order. addTriangle() was ignored. Must do a beginModel() to clear the model for addition of new triangles.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -298,7 +298,7 @@ int BVHModel<BV>::addTriangle(const Vector3<S>& p1, const Vector3<S>& p2, const
     Vector3<S>* temp = new Vector3<S>[num_vertices_allocated * 2 + 2];
     if(!temp)
     {
-      std::cerr << "BVH Error! Out of memory for vertices array on addTriangle() call!\n";
+      FCL_CERR << "BVH Error! Out of memory for vertices array on addTriangle() call!\n";
       return BVH_ERR_MODEL_OUT_OF_MEMORY;
     }
 
@@ -326,7 +326,7 @@ int BVHModel<BV>::addTriangle(const Vector3<S>& p1, const Vector3<S>& p2, const
     Triangle* temp = new Triangle[num_tris_allocated * 2];
     if(!temp)
     {
-      std::cerr << "BVH Error! Out of memory for tri_indices array on addTriangle() call!\n";
+      FCL_CERR << "BVH Error! Out of memory for tri_indices array on addTriangle() call!\n";
       return BVH_ERR_MODEL_OUT_OF_MEMORY;
     }
 
@@ -348,7 +348,7 @@ int BVHModel<BV>::addSubModel(const std::vector<Vector3<S>>& ps)
 {
   if(build_state == BVH_BUILD_STATE_PROCESSED)
   {
-    std::cerr << "BVH Warning! Call addSubModel() in a wrong order. addSubModel() was ignored. Must do a beginModel() to clear the model for addition of new vertices.\n";
+    FCL_CERR << "BVH Warning! Call addSubModel() in a wrong order. addSubModel() was ignored. Must do a beginModel() to clear the model for addition of new vertices.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -359,7 +359,7 @@ int BVHModel<BV>::addSubModel(const std::vector<Vector3<S>>& ps)
     Vector3<S>* temp = new Vector3<S>[num_vertices_allocated * 2 + num_vertices_to_add - 1];
     if(!temp)
     {
-      std::cerr << "BVH Error! Out of memory for vertices array on addSubModel() call!\n";
+      FCL_CERR << "BVH Error! Out of memory for vertices array on addSubModel() call!\n";
       return BVH_ERR_MODEL_OUT_OF_MEMORY;
     }
 
@@ -384,7 +384,7 @@ int BVHModel<BV>::addSubModel(const std::vector<Vector3<S>>& ps, const std::vect
 {
   if(build_state == BVH_BUILD_STATE_PROCESSED)
   {
-    std::cerr << "BVH Warning! Call addSubModel() in a wrong order. addSubModel() was ignored. Must do a beginModel() to clear the model for addition of new vertices.\n";
+    FCL_CERR << "BVH Warning! Call addSubModel() in a wrong order. addSubModel() was ignored. Must do a beginModel() to clear the model for addition of new vertices.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -395,7 +395,7 @@ int BVHModel<BV>::addSubModel(const std::vector<Vector3<S>>& ps, const std::vect
     Vector3<S>* temp = new Vector3<S>[num_vertices_allocated * 2 + num_vertices_to_add - 1];
     if(!temp)
     {
-      std::cerr << "BVH Error! Out of memory for vertices array on addSubModel() call!\n";
+      FCL_CERR << "BVH Error! Out of memory for vertices array on addSubModel() call!\n";
       return BVH_ERR_MODEL_OUT_OF_MEMORY;
     }
 
@@ -425,7 +425,7 @@ int BVHModel<BV>::addSubModel(const std::vector<Vector3<S>>& ps, const std::vect
     Triangle* temp = new(std::nothrow) Triangle[num_tris_allocated * 2 + num_tris_to_add - 1];
     if(!temp)
     {
-      std::cerr << "BVH Error! Out of memory for tri_indices array on addSubModel() call!\n";
+      FCL_CERR << "BVH Error! Out of memory for tri_indices array on addSubModel() call!\n";
       return BVH_ERR_MODEL_OUT_OF_MEMORY;
     }
 
@@ -451,13 +451,13 @@ int BVHModel<BV>::endModel()
 {
   if(build_state != BVH_BUILD_STATE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call endModel() in wrong order. endModel() was ignored.\n";
+    FCL_CERR << "BVH Warning! Call endModel() in wrong order. endModel() was ignored.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
   if(num_tris == 0 && num_vertices == 0)
   {
-    std::cerr << "BVH Error! endModel() called on model with no triangles and vertices.\n";
+    FCL_CERR << "BVH Error! endModel() called on model with no triangles and vertices.\n";
     return BVH_ERR_BUILD_EMPTY_MODEL;
   }
 
@@ -466,7 +466,7 @@ int BVHModel<BV>::endModel()
     Triangle* new_tris = new(std::nothrow) Triangle[num_tris];
     if(!new_tris)
     {
-      std::cerr << "BVH Error! Out of memory for tri_indices array in endModel() call!\n";
+      FCL_CERR << "BVH Error! Out of memory for tri_indices array in endModel() call!\n";
       return BVH_ERR_MODEL_OUT_OF_MEMORY;
     }
     std::copy(tri_indices, tri_indices + num_tris, new_tris);
@@ -480,7 +480,7 @@ int BVHModel<BV>::endModel()
     Vector3<S>* new_vertices = new Vector3<S>[num_vertices];
     if(!new_vertices)
     {
-      std::cerr << "BVH Error! Out of memory for vertices array in endModel() call!\n";
+      FCL_CERR << "BVH Error! Out of memory for vertices array in endModel() call!\n";
       return BVH_ERR_MODEL_OUT_OF_MEMORY;
     }
     std::copy(vertices, vertices + num_vertices, new_vertices);
@@ -502,7 +502,7 @@ int BVHModel<BV>::endModel()
   primitive_indices = new(std::nothrow) unsigned int [num_bvs_to_be_allocated];
   if(!bvs || !primitive_indices)
   {
-    std::cerr << "BVH Error! Out of memory for BV array in endModel()!\n";
+    FCL_CERR << "BVH Error! Out of memory for BV array in endModel()!\n";
     return BVH_ERR_MODEL_OUT_OF_MEMORY;
   }
   num_bvs_allocated = num_bvs_to_be_allocated;
@@ -522,7 +522,7 @@ int BVHModel<BV>::beginReplaceModel()
 {
   if(build_state != BVH_BUILD_STATE_PROCESSED)
   {
-    std::cerr << "BVH Error! Call beginReplaceModel() on a BVHModel that has no previous frame.\n";
+    FCL_CERR << "BVH Error! Call beginReplaceModel() on a BVHModel that has no previous frame.\n";
     return BVH_ERR_BUILD_EMPTY_PREVIOUS_FRAME;
   }
 
@@ -545,7 +545,7 @@ int BVHModel<BV>::replaceVertex(const Vector3<S>& p)
 {
   if(build_state != BVH_BUILD_STATE_REPLACE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call replaceVertex() in a wrong order. replaceVertex() was ignored. Must do a beginReplaceModel() for initialization.\n";
+    FCL_CERR << "BVH Warning! Call replaceVertex() in a wrong order. replaceVertex() was ignored. Must do a beginReplaceModel() for initialization.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -561,7 +561,7 @@ int BVHModel<BV>::replaceTriangle(const Vector3<S>& p1, const Vector3<S>& p2, co
 {
   if(build_state != BVH_BUILD_STATE_REPLACE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call replaceTriangle() in a wrong order. replaceTriangle() was ignored. Must do a beginReplaceModel() for initialization.\n";
+    FCL_CERR << "BVH Warning! Call replaceTriangle() in a wrong order. replaceTriangle() was ignored. Must do a beginReplaceModel() for initialization.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -577,7 +577,7 @@ int BVHModel<BV>::replaceSubModel(const std::vector<Vector3<S>>& ps)
 {
   if(build_state != BVH_BUILD_STATE_REPLACE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call replaceSubModel() in a wrong order. replaceSubModel() was ignored. Must do a beginReplaceModel() for initialization.\n";
+    FCL_CERR << "BVH Warning! Call replaceSubModel() in a wrong order. replaceSubModel() was ignored. Must do a beginReplaceModel() for initialization.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -595,13 +595,13 @@ int BVHModel<BV>::endReplaceModel(bool refit, bool bottomup)
 {
   if(build_state != BVH_BUILD_STATE_REPLACE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call endReplaceModel() in a wrong order. endReplaceModel() was ignored. \n";
+    FCL_CERR << "BVH Warning! Call endReplaceModel() in a wrong order. endReplaceModel() was ignored. \n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
   if(num_vertex_updated != num_vertices)
   {
-    std::cerr << "BVH Error! The replaced model should have the same number of vertices as the old model.\n";
+    FCL_CERR << "BVH Error! The replaced model should have the same number of vertices as the old model.\n";
     return BVH_ERR_INCORRECT_DATA;
   }
 
@@ -625,7 +625,7 @@ int BVHModel<BV>::beginUpdateModel()
 {
   if(build_state != BVH_BUILD_STATE_PROCESSED && build_state != BVH_BUILD_STATE_UPDATED)
   {
-    std::cerr << "BVH Error! Call beginUpdatemodel() on a BVHModel that has no previous frame.\n";
+    FCL_CERR << "BVH Error! Call beginUpdatemodel() on a BVHModel that has no previous frame.\n";
     return BVH_ERR_BUILD_EMPTY_PREVIOUS_FRAME;
   }
 
@@ -654,7 +654,7 @@ int BVHModel<BV>::updateVertex(const Vector3<S>& p)
 {
   if(build_state != BVH_BUILD_STATE_UPDATE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call updateVertex() in a wrong order. updateVertex() was ignored. Must do a beginUpdateModel() for initialization.\n";
+    FCL_CERR << "BVH Warning! Call updateVertex() in a wrong order. updateVertex() was ignored. Must do a beginUpdateModel() for initialization.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -670,7 +670,7 @@ int BVHModel<BV>::updateTriangle(const Vector3<S>& p1, const Vector3<S>& p2, con
 {
   if(build_state != BVH_BUILD_STATE_UPDATE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call updateTriangle() in a wrong order. updateTriangle() was ignored. Must do a beginUpdateModel() for initialization.\n";
+    FCL_CERR << "BVH Warning! Call updateTriangle() in a wrong order. updateTriangle() was ignored. Must do a beginUpdateModel() for initialization.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -686,7 +686,7 @@ int BVHModel<BV>::updateSubModel(const std::vector<Vector3<S>>& ps)
 {
   if(build_state != BVH_BUILD_STATE_UPDATE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call updateSubModel() in a wrong order. updateSubModel() was ignored. Must do a beginUpdateModel() for initialization.\n";
+    FCL_CERR << "BVH Warning! Call updateSubModel() in a wrong order. updateSubModel() was ignored. Must do a beginUpdateModel() for initialization.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -704,13 +704,13 @@ int BVHModel<BV>::endUpdateModel(bool refit, bool bottomup)
 {
   if(build_state != BVH_BUILD_STATE_UPDATE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call endUpdateModel() in a wrong order. endUpdateModel() was ignored. \n";
+    FCL_CERR << "BVH Warning! Call endUpdateModel() in a wrong order. endUpdateModel() was ignored. \n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
   if(num_vertex_updated != num_vertices)
   {
-    std::cerr << "BVH Error! The updated model should have the same number of vertices as the old model.\n";
+    FCL_CERR << "BVH Error! The updated model should have the same number of vertices as the old model.\n";
     return BVH_ERR_INCORRECT_DATA;
   }
 
@@ -744,10 +744,10 @@ int BVHModel<BV>::memUsage(int msg) const
   int total_mem = mem_bv_list + mem_tri_list + mem_vertex_list + sizeof(BVHModel<BV>);
   if(msg)
   {
-    std::cerr << "Total for model " << total_mem << " bytes.\n";
-    std::cerr << "BVs: " << num_bvs << " allocated.\n";
-    std::cerr << "Tris: " << num_tris << " allocated.\n";
-    std::cerr << "Vertices: " << num_vertices << " allocated.\n";
+    FCL_CERR << "Total for model " << total_mem << " bytes.\n";
+    FCL_CERR << "BVs: " << num_bvs << " allocated.\n";
+    FCL_CERR << "Tris: " << num_tris << " allocated.\n";
+    FCL_CERR << "Vertices: " << num_vertices << " allocated.\n";
   }
 
   return BVH_OK;
@@ -849,7 +849,7 @@ int BVHModel<BV>::buildTree()
     num_primitives = num_vertices;
     break;
   default:
-    std::cerr << "BVH Error: Model type not supported!\n";
+    FCL_CERR << "BVH Error: Model type not supported!\n";
     return BVH_ERR_UNSUPPORTED_FUNCTION;
   }
 
@@ -903,7 +903,7 @@ int BVHModel<BV>::recursiveBuildTree(int bv_id, int first_primitive, int num_pri
       }
       else
       {
-        std::cerr << "BVH Error: Model type not supported!\n";
+        FCL_CERR << "BVH Error: Model type not supported!\n";
         return BVH_ERR_UNSUPPORTED_FUNCTION;
       }
 
@@ -1012,7 +1012,7 @@ int BVHModel<BV>::recursiveRefitTree_bottomup(int bv_id)
     }
     else
     {
-      std::cerr << "BVH Error: Model type not supported!\n";
+      FCL_CERR << "BVH Error: Model type not supported!\n";
       return BVH_ERR_UNSUPPORTED_FUNCTION;
     }
   }
diff --git a/include/fcl/geometry/bvh/detail/BV_splitter-inl.h b/include/fcl/geometry/bvh/detail/BV_splitter-inl.h
index 26e8bf0..c9c916e 100644
--- a/include/fcl/geometry/bvh/detail/BV_splitter-inl.h
+++ b/include/fcl/geometry/bvh/detail/BV_splitter-inl.h
@@ -90,7 +90,7 @@ void BVSplitter<BV>::computeRule(
     computeRule_bvcenter(bv, primitive_indices, num_primitives);
     break;
   default:
-    std::cerr << "Split method not supported\n";
+    FCL_CERR << "Split method not supported\n";
   }
 }
 
diff --git a/include/fcl/geometry/geometric_shape_to_BVH_model-inl.h b/include/fcl/geometry/geometric_shape_to_BVH_model-inl.h
index 7fe4386..f75bac0 100644
--- a/include/fcl/geometry/geometric_shape_to_BVH_model-inl.h
+++ b/include/fcl/geometry/geometric_shape_to_BVH_model-inl.h
@@ -444,4 +444,4 @@ int generateBVHModel(BVHModel<BV>& model, const Cone<typename BV::S>& shape, con
 
 } // namespace fcl
 
-#endif
\ No newline at end of file
+#endif
diff --git a/include/fcl/geometry/geometric_shape_to_BVH_model.h b/include/fcl/geometry/geometric_shape_to_BVH_model.h
index d44350d..acf8cc5 100644
--- a/include/fcl/geometry/geometric_shape_to_BVH_model.h
+++ b/include/fcl/geometry/geometric_shape_to_BVH_model.h
@@ -161,4 +161,4 @@ int generateBVHModel(BVHModel<BV>& model, const Cone<typename BV::S>& shape, con
 
 #include "fcl/geometry/geometric_shape_to_BVH_model-inl.h"
 
-#endif
\ No newline at end of file
+#endif
diff --git a/include/fcl/geometry/shape/box-inl.h b/include/fcl/geometry/shape/box-inl.h
index 053119a..0c72ad2 100644
--- a/include/fcl/geometry/shape/box-inl.h
+++ b/include/fcl/geometry/shape/box-inl.h
@@ -38,7 +38,11 @@
 #ifndef FCL_SHAPE_BOX_INL_H
 #define FCL_SHAPE_BOX_INL_H
 
+#include <iomanip>
+#include <sstream>
+
 #include "fcl/geometry/shape/box.h"
+#include "fcl/geometry/shape/representation.h"
 
 namespace fcl
 {
@@ -133,6 +137,25 @@ std::vector<Vector3<S>> Box<S>::getBoundVertices(
   return result;
 }
 
+//==============================================================================
+template <typename S>
+std::string Box<S>::representation(int precision) const {
+  const char* S_str = detail::ScalarRepr<S>::value();
+#if FCL_ENABLE_STD_LOGGING
+  std::stringstream ss;
+  ss << std::setprecision(precision);
+  ss << "Box<" << S_str << ">(" << side[0] << ", " << side[1] << ", " << side[2]
+     << ");";
+  return ss.str();
+#else
+  (void)precision;
+  std::string repr = "Box<";
+  repr += S_str;
+  repr += ">";
+  return repr;
+#endif
+}
+
 } // namespace fcl
 
 #endif
diff --git a/include/fcl/geometry/shape/capsule-inl.h b/include/fcl/geometry/shape/capsule-inl.h
index b2add91..ca204c5 100644
--- a/include/fcl/geometry/shape/capsule-inl.h
+++ b/include/fcl/geometry/shape/capsule-inl.h
@@ -38,7 +38,11 @@
 #ifndef FCL_SHAPE_CAPSULE_INL_H
 #define FCL_SHAPE_CAPSULE_INL_H
 
+#include <iomanip>
+#include <sstream>
+
 #include "fcl/geometry/shape/capsule.h"
+#include "fcl/geometry/shape/representation.h"
 
 namespace fcl
 {
@@ -157,6 +161,24 @@ std::vector<Vector3<S>> Capsule<S>::getBoundVertices(
   return result;
 }
 
+//==============================================================================
+template <typename S>
+std::string Capsule<S>::representation(int precision) const {
+  const char* S_str = detail::ScalarRepr<S>::value();
+#if FCL_ENABLE_STD_LOGGING
+  std::stringstream ss;
+  ss << std::setprecision(precision);
+  ss << "Capsule<" << S_str << ">(" << radius << ", " << lz << ");";
+  return ss.str();
+#else
+  (void)precision;
+  std::string repr = "Capsule<";
+  repr += S_str;
+  repr += ">";
+  return repr;
+#endif
+}
+
 } // namespace fcl
 
 #endif
diff --git a/include/fcl/geometry/shape/cone-inl.h b/include/fcl/geometry/shape/cone-inl.h
index 3b023fc..33795c6 100644
--- a/include/fcl/geometry/shape/cone-inl.h
+++ b/include/fcl/geometry/shape/cone-inl.h
@@ -38,7 +38,11 @@
 #ifndef FCL_SHAPE_CONE_INL_H
 #define FCL_SHAPE_CONE_INL_H
 
+#include <iomanip>
+#include <sstream>
+
 #include "fcl/geometry/shape/cone.h"
+#include "fcl/geometry/shape/representation.h"
 
 namespace fcl
 {
@@ -123,6 +127,24 @@ std::vector<Vector3<S>> Cone<S>::getBoundVertices(
   return result;
 }
 
+//==============================================================================
+template <typename S>
+std::string Cone<S>::representation(int precision) const {
+  const char* S_str = detail::ScalarRepr<S>::value();
+#if FCL_ENABLE_STD_LOGGING
+  std::stringstream ss;
+  ss << std::setprecision(precision);
+  ss << "Cone<" << S_str << ">(" << radius << ", " << lz << ");";
+  return ss.str();
+#else
+  (void)precision;
+  std::string repr = "Cone<";
+  repr += S_str;
+  repr += ">";
+  return repr;
+#endif
+}
+
 } // namespace fcl
 
 #endif
diff --git a/include/fcl/geometry/shape/convex-inl.h b/include/fcl/geometry/shape/convex-inl.h
index 10adc69..857d7f3 100644
--- a/include/fcl/geometry/shape/convex-inl.h
+++ b/include/fcl/geometry/shape/convex-inl.h
@@ -39,11 +39,14 @@
 #ifndef FCL_SHAPE_CONVEX_INL_H
 #define FCL_SHAPE_CONVEX_INL_H
 
+#include <iomanip>
 #include <map>
 #include <set>
+#include <sstream>
 #include <utility>
 
 #include "fcl/geometry/shape/convex.h"
+#include "fcl/geometry/shape/representation.h"
 
 namespace fcl
 {
@@ -62,6 +65,7 @@ Convex<S>::Convex(
       vertices_(vertices),
       num_faces_(num_faces),
       faces_(faces),
+      throw_if_invalid_(throw_if_invalid),
       find_extreme_via_neighbors_{vertices->size() >
                                   kMinVertCountForEdgeWalking} {
   assert(vertices != nullptr);
@@ -309,6 +313,48 @@ const Vector3<S>& Convex<S>::findExtremeVertex(const Vector3<S>& v_C) const {
   return vertices[extreme_index];
 }
 
+//==============================================================================
+template <typename S>
+std::string Convex<S>::representation(int precision) const {
+  const char* S_str = detail::ScalarRepr<S>::value();
+#if FCL_ENABLE_STD_LOGGING
+  std::stringstream ss;
+  ss << std::setprecision(precision);
+  ss << "Convex<" << S_str << ">("
+     << "\n  std::make_shared<std::vector<Vector3<" << S_str << ">>>("
+     << "\n    std::initializer_list<Vector3<" << S_str << ">>{";
+  for (const Vector3<S>& p_GV : *vertices_) {
+    ss << "\n      Vector3<" << S_str << ">(" << p_GV[0] << ", " << p_GV[1]
+       << ", " << p_GV[2] << "),";
+  }
+  ss << "}),";
+  ss << "\n    " << num_faces_ << ",";
+  ss << "\n    std::make_shared<std::vector<int>>("
+     << "\n        std::initializer_list<int>{"
+     << "\n            ";
+  const std::vector<int>& faces = *faces_;
+  int face_index = 0;
+  for (int i = 0; i < num_faces_; ++i) {
+    const int vertex_count = faces[face_index];
+    ss << " " << vertex_count << ",";
+    for (int j = 1; j <= vertex_count; ++j) {
+      ss << " " << faces[face_index + j] << ",";
+    }
+    face_index += vertex_count + 1;
+  }
+  ss << "}),"
+     << "\n    " << std::boolalpha << throw_if_invalid_ << ");";
+
+  return ss.str();
+#else
+  (void)precision;
+  std::string repr = "Convex<";
+  repr += S_str;
+  repr += ">";
+  return repr;
+#endif
+}
+
 //==============================================================================
 template <typename S>
 void Convex<S>::ValidateMesh(bool throw_on_error) {
@@ -323,7 +369,7 @@ void Convex<S>::ValidateTopology(bool throw_on_error) {
   // Computing the vertex neighbors is a pre-requisite to determining validity.
   assert(neighbors_.size() > vertices_->size());
 
-  std::stringstream ss;
+  logging::StringBuilder ss;
   ss << "Found errors in the Convex mesh:";
 
   // To simplify the code, we define an edge as a pair of ints (A, B) such that
diff --git a/include/fcl/geometry/shape/cylinder-inl.h b/include/fcl/geometry/shape/cylinder-inl.h
index f5a6211..1e4b782 100644
--- a/include/fcl/geometry/shape/cylinder-inl.h
+++ b/include/fcl/geometry/shape/cylinder-inl.h
@@ -38,7 +38,11 @@
 #ifndef FCL_SHAPE_CYLINDER_INL_H
 #define FCL_SHAPE_CYLINDER_INL_H
 
+#include <iomanip>
+#include <sstream>
+
 #include "fcl/geometry/shape/cylinder.h"
+#include "fcl/geometry/shape/representation.h"
 
 namespace fcl
 {
@@ -121,6 +125,24 @@ std::vector<Vector3<S>> Cylinder<S>::getBoundVertices(
   return result;
 }
 
+//==============================================================================
+template <typename S>
+std::string Cylinder<S>::representation(int precision) const {
+  const char* S_str = detail::ScalarRepr<S>::value();
+#if FCL_ENABLE_STD_LOGGING
+  std::stringstream ss;
+  ss << std::setprecision(precision);
+  ss << "Cylinder<" << S_str << ">(" << radius << ", " << lz << ");";
+  return ss.str();
+#else
+  (void)precision;
+  std::string repr = "Cylinder<";
+  repr += S_str;
+  repr += ">";
+  return repr;
+#endif
+}
+
 } // namespace fcl
 
 #endif
diff --git a/include/fcl/geometry/shape/ellipsoid-inl.h b/include/fcl/geometry/shape/ellipsoid-inl.h
index 5bbf946..115f631 100644
--- a/include/fcl/geometry/shape/ellipsoid-inl.h
+++ b/include/fcl/geometry/shape/ellipsoid-inl.h
@@ -38,7 +38,11 @@
 #ifndef FCL_SHAPE_ELLIPSOID_INL_H
 #define FCL_SHAPE_ELLIPSOID_INL_H
 
+#include <iomanip>
+#include <sstream>
+
 #include "fcl/geometry/shape/ellipsoid.h"
+#include "fcl/geometry/shape/representation.h"
 
 namespace fcl
 {
@@ -143,6 +147,25 @@ std::vector<Vector3<S>> Ellipsoid<S>::getBoundVertices(
   return result;
 }
 
+//==============================================================================
+template <typename S>
+std::string Ellipsoid<S>::representation(int precision) const {
+  const char* S_str = detail::ScalarRepr<S>::value();
+#if FCL_ENABLE_STD_LOGGING
+  std::stringstream ss;
+  ss << std::setprecision(precision);
+  ss << "Ellipsoid<" << S_str << ">(" << radii[0] << ", " << radii[1] << ", "
+     << radii[2] << ");";
+  return ss.str();
+#else
+  (void)precision;
+  std::string repr = "Ellipsoid<";
+  repr += S_str;
+  repr += ">";
+  return repr;
+#endif
+}
+
 } // namespace fcl
 
 #endif
diff --git a/include/fcl/geometry/shape/halfspace-inl.h b/include/fcl/geometry/shape/halfspace-inl.h
index bc58f80..06d8eec 100644
--- a/include/fcl/geometry/shape/halfspace-inl.h
+++ b/include/fcl/geometry/shape/halfspace-inl.h
@@ -38,7 +38,11 @@
 #ifndef FCL_SHAPE_HALFSPACE_INL_H
 #define FCL_SHAPE_HALFSPACE_INL_H
 
+#include <iomanip>
+#include <sstream>
+
 #include "fcl/geometry/shape/halfspace.h"
+#include "fcl/geometry/shape/representation.h"
 
 namespace fcl
 {
@@ -130,6 +134,25 @@ NODE_TYPE Halfspace<S>::getNodeType() const
   return GEOM_HALFSPACE;
 }
 
+//==============================================================================
+template <typename S>
+std::string Halfspace<S>::representation(int precision) const {
+  const char* S_str = detail::ScalarRepr<S>::value();
+#if FCL_ENABLE_STD_LOGGING
+  std::stringstream ss;
+  ss << std::setprecision(precision);
+  ss << "Halfspace<" << S_str << ">(" << n[0] << ", " << n[1] << ", " << n[2]
+     << ", " << d << ");";
+  return ss.str();
+#else
+  (void)precision;
+  std::string repr = "Halfspace<";
+  repr += S_str;
+  repr += ">";
+  return repr;
+#endif
+}
+
 //==============================================================================
 template <typename S>
 void Halfspace<S>::unitNormalTest()
diff --git a/include/fcl/geometry/shape/plane-inl.h b/include/fcl/geometry/shape/plane-inl.h
index 2e5da9c..179b182 100644
--- a/include/fcl/geometry/shape/plane-inl.h
+++ b/include/fcl/geometry/shape/plane-inl.h
@@ -38,7 +38,11 @@
 #ifndef FCL_SHAPE_PLANE_INL_H
 #define FCL_SHAPE_PLANE_INL_H
 
+#include <iomanip>
+#include <sstream>
+
 #include "fcl/geometry/shape/plane.h"
+#include "fcl/geometry/shape/representation.h"
 
 namespace fcl
 {
@@ -130,6 +134,25 @@ NODE_TYPE Plane<S>::getNodeType() const
   return GEOM_PLANE;
 }
 
+//==============================================================================
+template <typename S>
+std::string Plane<S>::representation(int precision) const {
+  const char* S_str = detail::ScalarRepr<S>::value();
+#if FCL_ENABLE_STD_LOGGING
+  std::stringstream ss;
+  ss << std::setprecision(precision);
+  ss << "Plane<" << S_str << ">(" << n[0] << ", " << n[1] << ", " << n[2]
+     << ", " << d << ");";
+  return ss.str();
+#else
+  (void)precision;
+  std::string repr = "Plane<";
+  repr += S_str;
+  repr += ">";
+  return repr;
+#endif
+}
+
 //==============================================================================
 template <typename S>
 void Plane<S>::unitNormalTest()
diff --git a/include/fcl/geometry/shape/sphere-inl.h b/include/fcl/geometry/shape/sphere-inl.h
index 0da7eea..1a8f21e 100644
--- a/include/fcl/geometry/shape/sphere-inl.h
+++ b/include/fcl/geometry/shape/sphere-inl.h
@@ -38,7 +38,11 @@
 #ifndef FCL_SHAPE_SPHERE_INL_H
 #define FCL_SHAPE_SPHERE_INL_H
 
+#include <iomanip>
+#include <sstream>
+
 #include "fcl/geometry/shape/sphere.h"
+#include "fcl/geometry/shape/representation.h"
 
 namespace fcl
 {
@@ -115,6 +119,24 @@ std::vector<Vector3<S>> Sphere<S>::getBoundVertices(
   return result;
 }
 
+//==============================================================================
+template <typename S>
+std::string Sphere<S>::representation(int precision) const {
+  const char* S_str = detail::ScalarRepr<S>::value();
+#if FCL_ENABLE_STD_LOGGING
+  std::stringstream ss;
+  ss << std::setprecision(precision);
+  ss << "Sphere<" << S_str << ">(" << radius << ");";
+  return ss.str();
+#else
+  (void)precision;
+  std::string repr = "Sphere<";
+  repr += S_str;
+  repr += ">";
+  return repr;
+#endif
+}
+
 } // namespace fcl
 
 #endif
diff --git a/include/fcl/math/bv/OBB-inl.h b/include/fcl/math/bv/OBB-inl.h
index 4d5455f..091ee94 100644
--- a/include/fcl/math/bv/OBB-inl.h
+++ b/include/fcl/math/bv/OBB-inl.h
@@ -224,7 +224,7 @@ S OBB<S>::distance(const OBB& other, Vector3<S>* P,
   FCL_UNUSED(P);
   FCL_UNUSED(Q);
 
-  std::cerr << "OBB distance not implemented!\n";
+  FCL_CERR << "OBB distance not implemented!\n";
   return 0.0;
 }
 
diff --git a/include/fcl/math/bv/kDOP-inl.h b/include/fcl/math/bv/kDOP-inl.h
index f660266..2732134 100644
--- a/include/fcl/math/bv/kDOP-inl.h
+++ b/include/fcl/math/bv/kDOP-inl.h
@@ -264,7 +264,7 @@ S KDOP<S, N>::distance(const KDOP<S, N>& other, Vector3<S>* P, Vector3<S>* Q) co
   FCL_UNUSED(P);
   FCL_UNUSED(Q);
 
-  std::cerr << "KDOP distance not implemented!\n";
+  FCL_CERR << "KDOP distance not implemented!\n";
   return 0.0;
 }
 
diff --git a/include/fcl/math/geometry-inl.h b/include/fcl/math/geometry-inl.h
index a9d3dc8..16c09c2 100644
--- a/include/fcl/math/geometry-inl.h
+++ b/include/fcl/math/geometry-inl.h
@@ -464,7 +464,7 @@ void eigen(const Matrix3<S>& m, Vector3<S>& dout, Matrix3<S>& vout)
   Eigen::SelfAdjointEigenSolver<Matrix3<S>> eigensolver(m);
   if (eigensolver.info() != Eigen::Success)
   {
-    std::cerr << "[eigen] Failed to compute eigendecomposition.\n";
+    FCL_CERR << "[eigen] Failed to compute eigendecomposition.\n";
     return;
   }
   dout = eigensolver.eigenvalues();
@@ -556,7 +556,7 @@ void eigen_old(const Matrix3<S>& m, Vector3<S>& dout, Matrix3<S>& vout)
     }
   }
 
-  std::cerr << "eigen: too many iterations in Jacobi transform.\n";
+  FCL_CERR << "eigen: too many iterations in Jacobi transform.\n";
 
   return;
 }
diff --git a/include/fcl/math/motion/interp_motion-inl.h b/include/fcl/math/motion/interp_motion-inl.h
index 384367a..0667e10 100644
--- a/include/fcl/math/motion/interp_motion-inl.h
+++ b/include/fcl/math/motion/interp_motion-inl.h
@@ -127,7 +127,7 @@ InterpMotion<S>::InterpMotion(
 
 //==============================================================================
 template <typename S>
-bool InterpMotion<S>::integrate(double dt) const
+bool InterpMotion<S>::integrate(S dt) const
 {
   if(dt > 1) dt = 1;
 
@@ -187,6 +187,71 @@ void InterpMotion<S>::getTaylorModel(TMatrix3<S>& tm, TVector3<S>& tv) const
 }
 
 //==============================================================================
+#if defined(FCL_MUSA_KERNEL_MODE)
+
+template <typename S>
+void InterpMotion<S>::computeVelocity()
+{
+  // Linear velocity: difference of reference point under start/end transforms.
+  linear_vel = tf2 * reference_p - tf1 * reference_p;
+
+  // Compute relative rotation R = R2 * R1^T.
+  const Matrix3<S> R = tf2.linear() * tf1.linear().transpose();
+
+  // Convert R to axis-angle without going through Eigen::AngleAxis stableNorm
+  // path, to keep stack usage small in kernel builds.
+  const S trace = R(0, 0) + R(1, 1) + R(2, 2);
+  Quaternion<S> q;
+  if(trace > S(0))
+  {
+    const S t = trace + S(1);
+    const S s = std::sqrt(t) * S(2);
+    q.w() = t / s;
+    q.x() = (R(2, 1) - R(1, 2)) / s;
+    q.y() = (R(0, 2) - R(2, 0)) / s;
+    q.z() = (R(1, 0) - R(0, 1)) / s;
+  }
+  else
+  {
+    int i = 0;
+    if(R(1, 1) > R(0, 0)) i = 1;
+    if(R(2, 2) > R(i, i)) i = 2;
+    const int j = (i + 1) % 3;
+    const int k = (i + 2) % 3;
+    const S t = (R(i, i) - R(j, j) - R(k, k)) + S(1);
+    const S s = std::sqrt(t) * S(2);
+    S* q_data = q.coeffs().data(); // x,y,z,w
+    q_data[i] = t / s;
+    q_data[3] = (R(k, j) - R(j, k)) / s;
+    q_data[j] = (R(j, i) + R(i, j)) / s;
+    q_data[k] = (R(k, i) + R(i, k)) / s;
+  }
+
+  // Normalize quaternion to be safe.
+  q.normalize();
+
+  // Extract angle and axis.
+  angular_vel = S(2) * std::acos(std::max(S(-1), std::min(S(1), q.w())));
+  const S sin_half = std::sqrt(std::max(S(0), S(1) - q.w() * q.w()));
+  if(sin_half > std::numeric_limits<S>::epsilon())
+  {
+    angular_axis = Vector3<S>(q.x(), q.y(), q.z()) / sin_half;
+  }
+  else
+  {
+    angular_axis = Vector3<S>::UnitX();
+    angular_vel = 0;
+  }
+
+  if(angular_vel < 0)
+  {
+    angular_vel = -angular_vel;
+    angular_axis = -angular_axis;
+  }
+}
+
+#else
+
 template <typename S>
 void InterpMotion<S>::computeVelocity()
 {
@@ -203,6 +268,8 @@ void InterpMotion<S>::computeVelocity()
   }
 }
 
+#endif
+
 //==============================================================================
 template <typename S>
 Quaternion<S> InterpMotion<S>::deltaRotation(S dt) const
diff --git a/include/fcl/math/motion/taylor_model/interval-inl.h b/include/fcl/math/motion/taylor_model/interval-inl.h
index 2e2dbb1..01e8252 100644
--- a/include/fcl/math/motion/taylor_model/interval-inl.h
+++ b/include/fcl/math/motion/taylor_model/interval-inl.h
@@ -395,7 +395,11 @@ Interval<S>& Interval<S>::bound(const Interval<S>& other)
 template <typename S>
 void Interval<S>::print() const
 {
+#if FCL_ENABLE_STD_LOGGING
   std::cout << "[" << i_[0] << ", " << i_[1] << "]" << std::endl;
+#else
+  (void)i_;
+#endif
 }
 
 //==============================================================================
diff --git a/include/fcl/math/motion/taylor_model/interval_matrix-inl.h b/include/fcl/math/motion/taylor_model/interval_matrix-inl.h
index bda8fc0..effb3e9 100644
--- a/include/fcl/math/motion/taylor_model/interval_matrix-inl.h
+++ b/include/fcl/math/motion/taylor_model/interval_matrix-inl.h
@@ -313,9 +313,13 @@ IMatrix3<S>& IMatrix3<S>::rotationConstrain()
 template <typename S>
 void IMatrix3<S>::print() const
 {
+#if FCL_ENABLE_STD_LOGGING
   std::cout << "[" << v_[0][0][0] << "," << v_[0][0][1] << "]" << " [" << v_[0][1][0] << "," << v_[0][1][1] << "]" << " [" << v_[0][2][0] << "," << v_[0][2][1] << "]" << std::endl;
   std::cout << "[" << v_[1][0][0] << "," << v_[1][0][1] << "]" << " [" << v_[1][1][0] << "," << v_[1][1][1] << "]" << " [" << v_[1][2][0] << "," << v_[1][2][1] << "]" << std::endl;
   std::cout << "[" << v_[2][0][0] << "," << v_[2][0][1] << "]" << " [" << v_[2][1][0] << "," << v_[2][1][1] << "]" << " [" << v_[2][2][0] << "," << v_[2][2][1] << "]" << std::endl;
+#else
+  (void)v_;
+#endif
 }
 
 //==============================================================================
diff --git a/include/fcl/math/motion/taylor_model/interval_vector-inl.h b/include/fcl/math/motion/taylor_model/interval_vector-inl.h
index 5755f76..42b356d 100644
--- a/include/fcl/math/motion/taylor_model/interval_vector-inl.h
+++ b/include/fcl/math/motion/taylor_model/interval_vector-inl.h
@@ -295,9 +295,13 @@ S IVector3<S>::volumn() const
 template <typename S>
 void IVector3<S>::print() const
 {
+#if FCL_ENABLE_STD_LOGGING
   std::cout << "[" << i_[0][0] << "," << i_[0][1] << "]" << std::endl;
   std::cout << "[" << i_[1][0] << "," << i_[1][1] << "]" << std::endl;
   std::cout << "[" << i_[2][0] << "," << i_[2][1] << "]" << std::endl;
+#else
+  (void)i_;
+#endif
 }
 
 //==============================================================================
diff --git a/include/fcl/math/motion/taylor_model/taylor_model-inl.h b/include/fcl/math/motion/taylor_model/taylor_model-inl.h
index 861f72d..5ccb7e0 100644
--- a/include/fcl/math/motion/taylor_model/taylor_model-inl.h
+++ b/include/fcl/math/motion/taylor_model/taylor_model-inl.h
@@ -331,7 +331,12 @@ TaylorModel<S> TaylorModel<S>::operator - () const
 template <typename S>
 void TaylorModel<S>::print() const
 {
+#if FCL_ENABLE_STD_LOGGING
   std::cout << coeffs_[0] << "+" << coeffs_[1] << "*t+" << coeffs_[2] << "*t^2+" << coeffs_[3] << "*t^3+[" << r_[0] << "," << r_[1] << "]" << std::endl;
+#else
+  (void)coeffs_;
+  (void)r_;
+#endif
 }
 
 //==============================================================================
diff --git a/include/fcl/math/rng-inl.h b/include/fcl/math/rng-inl.h
index 8877c48..8a8d895 100644
--- a/include/fcl/math/rng-inl.h
+++ b/include/fcl/math/rng-inl.h
@@ -193,13 +193,13 @@ void RNG<S>::setSeed(uint_fast32_t seed)
 {
   if (detail::Seed::isFirstSeedGenerated())
   {
-    std::cerr << "Random number generation already started. Changing seed now "
+    FCL_CERR << "Random number generation already started. Changing seed now "
               << "will not lead to deterministic sampling.\n";
   }
 
   if (seed == 0)
   {
-    std::cerr << "Random generator seed cannot be 0. Using 1 instead.\n";
+    FCL_CERR << "Random generator seed cannot be 0. Using 1 instead.\n";
     detail::Seed::setUserSetSeed(1);
   }
   else
diff --git a/include/fcl/narrowphase/collision-inl.h b/include/fcl/narrowphase/collision-inl.h
index 69f4c2c..1fd35ba 100644
--- a/include/fcl/narrowphase/collision-inl.h
+++ b/include/fcl/narrowphase/collision-inl.h
@@ -110,7 +110,7 @@ std::size_t collide(
   std::size_t res;
   if(request.num_max_contacts == 0)
   {
-    std::cerr << "Warning: should stop early as num_max_contact is " << request.num_max_contacts << " !\n";
+    FCL_CERR << "Warning: should stop early as num_max_contact is " << request.num_max_contacts << " !\n";
     res = 0;
   }
   else
@@ -124,7 +124,7 @@ std::size_t collide(
     {
       if(!looktable.collision_matrix[node_type2][node_type1])
       {
-        std::cerr << "Warning: collision function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
+        FCL_CERR << "Warning: collision function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
         res = 0;
       }
       else
@@ -134,7 +134,7 @@ std::size_t collide(
     {
       if(!looktable.collision_matrix[node_type1][node_type2])
       {
-        std::cerr << "Warning: collision function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
+        FCL_CERR << "Warning: collision function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
         res = 0;
       }
       else
@@ -201,7 +201,7 @@ std::size_t collide(
       return collide(o1, tf1, o2, tf2, &solver, request, result);
     }
   default:
-    std::cerr << "Warning! Invalid GJK solver\n";
+    FCL_CERR << "Warning! Invalid GJK solver\n";
     return -1; // error
   }
 }
diff --git a/include/fcl/narrowphase/continuous_collision-inl.h b/include/fcl/narrowphase/continuous_collision-inl.h
index b24d0b8..4df23cf 100644
--- a/include/fcl/narrowphase/continuous_collision-inl.h
+++ b/include/fcl/narrowphase/continuous_collision-inl.h
@@ -291,7 +291,7 @@ S continuousCollideBVHPolynomial(
     ;
   }
 
-  std::cerr << "Warning: BV type not supported by polynomial solver CCD\n";
+  FCL_CERR << "Warning: BV type not supported by polynomial solver CCD\n";
 
   return -1;
 }
@@ -326,7 +326,7 @@ typename NarrowPhaseSolver::S continuousCollideConservativeAdvancement(
 
   if(!looktable.conservative_advancement_matrix[node_type1][node_type2])
   {
-    std::cerr << "Warning: collision function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
+    FCL_CERR << "Warning: collision function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
   }
   else
   {
@@ -412,7 +412,7 @@ S continuousCollide(
 
     }
     else
-      std::cerr << "Warning! Invalid continuous collision setting\n";
+      FCL_CERR << "Warning! Invalid continuous collision setting\n";
     break;
   case CCDC_POLYNOMIAL_SOLVER:
     if(o1->getObjectType() == OT_BVH && o2->getObjectType() == OT_BVH && request.ccd_motion_type == CCDM_TRANS)
@@ -422,10 +422,10 @@ S continuousCollide(
                                             request, result);
     }
     else
-      std::cerr << "Warning! Invalid continuous collision checking\n";
+      FCL_CERR << "Warning! Invalid continuous collision checking\n";
     break;
   default:
-    std::cerr << "Warning! Invalid continuous collision setting\n";
+    FCL_CERR << "Warning! Invalid continuous collision setting\n";
   }
 
   return -1;
diff --git a/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd-inl.h b/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd-inl.h
index 60fd0ad..b205581 100644
--- a/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd-inl.h
+++ b/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd-inl.h
@@ -38,15 +38,16 @@
 #ifndef FCL_NARROWPHASE_DETAIL_GJKLIBCCD_INL_H
 #define FCL_NARROWPHASE_DETAIL_GJKLIBCCD_INL_H
 
-#include "fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd.h"
-#include "fcl/narrowphase/detail/failed_at_this_configuration.h"
-
 #include <array>
+#include <string>
 #include <unordered_map>
 #include <unordered_set>
 
 #include "fcl/common/unused.h"
 #include "fcl/common/warning.h"
+#include "fcl/logging.h"
+#include "fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd.h"
+#include "fcl/narrowphase/detail/failed_at_this_configuration.h"
 
 namespace fcl
 {
@@ -186,6 +187,46 @@ struct ccd_triangle_t : public ccd_obj_t
 namespace libccd_extension
 {
 
+// These two functions contain the only "valid" invocations of
+// ccdVec3PointTriDist2(). Any other invocations should be considered a defect.
+// We can remove these safety layers if/when the issue noted below gets
+// resolved upstream.
+
+// The code in this file (and elsewhere if it comes up), should *not* ever call
+// `ccdVec3PointTriDist2()` directly. It has some precision quirks. For those
+// invocations that want the squared distance without a witness point, call
+// *this* function.
+static ccd_real_t ccdVec3PointTriDist2NoWitness(const ccd_vec3_t* P,
+                                                const ccd_vec3_t* a,
+                                                const ccd_vec3_t* b,
+                                                const ccd_vec3_t* c) {
+  // When called, ccdVec3PointTriDist2 can optionally compute the value of the
+  // "witness" point. When we don't need the witness point, we skip it. However,
+  // the libccd implementation takes two different code paths based on whether
+  // we request the witness point producing different answers due to numerical
+  // precision issues. So, when FCL doesn't want/need a witness point, we use
+  // this wrapper to force the witness point to get a more consistent and
+  // reliable answer. See
+  // https://github.com/danfis/libccd/issues/55 for an explanation.
+  //
+  // Any actual invocation of ccdVec3PointTriDist2() in the code should request
+  // a witness point *or* call this invocation.
+  ccd_vec3_t unused;
+  return ccdVec3PointTriDist2(P, a, b, c, &unused);
+}
+
+// The code in this file (and elsewhere if it comes up), should *not* ever call
+// `ccdVec3PointTriDist2()` directly. It has some precision quirks. For those
+// invocations that want the squared distance *with* a witness point, call
+// *this* function.
+static ccd_real_t ccdVec3PointTriDist2WithWitness(const ccd_vec3_t* P,
+                                                  const ccd_vec3_t* a,
+                                                  const ccd_vec3_t* b,
+                                                  const ccd_vec3_t* c,
+                                                  ccd_vec3_t* w) {
+  return ccdVec3PointTriDist2(P, a, b, c, w);
+}
+
 static ccd_real_t simplexReduceToTriangle(ccd_simplex_t *simplex,
                                           ccd_real_t dist,
                                           ccd_vec3_t *best_witness)
@@ -197,11 +238,10 @@ static ccd_real_t simplexReduceToTriangle(ccd_simplex_t *simplex,
 
   // try the fourth point in all three positions
   for (i = 0; i < 3; i++){
-    newdist = ccdVec3PointTriDist2(ccd_vec3_origin,
-                                   &ccdSimplexPoint(simplex, (i == 0 ? 3 : 0))->v,
-                                   &ccdSimplexPoint(simplex, (i == 1 ? 3 : 1))->v,
-                                   &ccdSimplexPoint(simplex, (i == 2 ? 3 : 2))->v,
-                                   &witness);
+    newdist = ccdVec3PointTriDist2WithWitness(
+        ccd_vec3_origin, &ccdSimplexPoint(simplex, (i == 0 ? 3 : 0))->v,
+        &ccdSimplexPoint(simplex, (i == 1 ? 3 : 1))->v,
+        &ccdSimplexPoint(simplex, (i == 2 ? 3 : 2))->v, &witness);
     newdist = CCD_SQRT(newdist);
 
     // record the best triangle
@@ -398,13 +438,8 @@ static int doSimplex3(ccd_simplex_t *simplex, ccd_vec3_t *dir)
   C = ccdSimplexPoint(simplex, 0);
 
   // check touching contact
-  // Compute origin_projection as well. Without computing the origin projection,
-  // libccd could give inaccurate result. See
-  // https://github.com/danfis/libccd/issues/55.
-  ccd_vec3_t origin_projection_unused;
-
-  const ccd_real_t dist_squared = ccdVec3PointTriDist2(
-      ccd_vec3_origin, &A->v, &B->v, &C->v, &origin_projection_unused);
+  const ccd_real_t dist_squared = ccdVec3PointTriDist2NoWitness(
+      ccd_vec3_origin, &A->v, &B->v, &C->v);
   if (isAbsValueLessThanEpsSquared(dist_squared)) {
     return 1;
   }
@@ -493,30 +528,25 @@ static int doSimplex4(ccd_simplex_t *simplex, ccd_vec3_t *dir)
   // check if tetrahedron is really tetrahedron (has volume > 0)
   // if it is not simplex can't be expanded and thus no intersection is
   // found.
-  // point_projection_on_triangle_unused is not used. We ask
-  // ccdVec3PointTriDist2 to compute this witness point, so as to get a
-  // numerical robust dist_squared. See
-  // https://github.com/danfis/libccd/issues/55 for an explanation.
-  ccd_vec3_t point_projection_on_triangle_unused;
-  ccd_real_t dist_squared = ccdVec3PointTriDist2(
-      &A->v, &B->v, &C->v, &D->v, &point_projection_on_triangle_unused);
+  ccd_real_t dist_squared = ccdVec3PointTriDist2NoWitness(
+      &A->v, &B->v, &C->v, &D->v);
   if (isAbsValueLessThanEpsSquared(dist_squared)) {
     return -1;
   }
 
   // check if origin lies on some of tetrahedron's face - if so objects
   // intersect
-  dist_squared = ccdVec3PointTriDist2(ccd_vec3_origin, &A->v, &B->v, &C->v,
-                                      &point_projection_on_triangle_unused);
+  dist_squared =
+      ccdVec3PointTriDist2NoWitness(ccd_vec3_origin, &A->v, &B->v, &C->v);
   if (isAbsValueLessThanEpsSquared((dist_squared))) return 1;
-  dist_squared = ccdVec3PointTriDist2(ccd_vec3_origin, &A->v, &C->v, &D->v,
-                                      &point_projection_on_triangle_unused);
+  dist_squared =
+      ccdVec3PointTriDist2NoWitness(ccd_vec3_origin, &A->v, &C->v, &D->v);
   if (isAbsValueLessThanEpsSquared((dist_squared))) return 1;
-  dist_squared = ccdVec3PointTriDist2(ccd_vec3_origin, &A->v, &B->v, &D->v,
-                                      &point_projection_on_triangle_unused);
+  dist_squared =
+      ccdVec3PointTriDist2NoWitness(ccd_vec3_origin, &A->v, &B->v, &D->v);
   if (isAbsValueLessThanEpsSquared(dist_squared)) return 1;
-  dist_squared = ccdVec3PointTriDist2(ccd_vec3_origin, &B->v, &C->v, &D->v,
-                                      &point_projection_on_triangle_unused);
+  dist_squared =
+      ccdVec3PointTriDist2NoWitness(ccd_vec3_origin, &B->v, &C->v, &D->v);
   if (isAbsValueLessThanEpsSquared(dist_squared)) return 1;
 
   // compute AO, AB, AC, AD segments and ABC, ACD, ADB normal vectors
@@ -757,15 +787,14 @@ static int convert2SimplexToTetrahedron(const void* obj1, const void* obj2,
   ccdVec3Sub2(&ac, &c->v, &a->v);
   ccdVec3Cross(&dir, &ab, &ac);
   __ccdSupport(obj1, obj2, &dir, ccd, &d);
-  ccd_vec3_t point_projection_on_triangle_unused;
-  const ccd_real_t dist_squared = ccdVec3PointTriDist2(
-      &d.v, &a->v, &b->v, &c->v, &point_projection_on_triangle_unused);
+  const ccd_real_t dist_squared =
+      ccdVec3PointTriDist2NoWitness(&d.v, &a->v, &b->v, &c->v);
 
   // and second one take in opposite direction
   ccdVec3Scale(&dir, -CCD_ONE);
   __ccdSupport(obj1, obj2, &dir, ccd, &d2);
-  const ccd_real_t dist_squared_opposite = ccdVec3PointTriDist2(
-      &d2.v, &a->v, &b->v, &c->v, &point_projection_on_triangle_unused);
+  const ccd_real_t dist_squared_opposite =
+      ccdVec3PointTriDist2NoWitness(&d2.v, &a->v, &b->v, &c->v);
 
   // check if face isn't already on edge of minkowski sum and thus we
   // have touching contact
@@ -844,14 +873,15 @@ static int simplexToPolytope4(const void* obj1, const void* obj2,
   // of the simplex to that face and then attempt to construct the polytope from
   // the resulting face. We simply take the first face which exhibited the
   // trait.
+
   ccd_real_t dist_squared =
-      ccdVec3PointTriDist2(ccd_vec3_origin, &a->v, &b->v, &c->v, NULL);
+      ccdVec3PointTriDist2NoWitness(ccd_vec3_origin, &a->v, &b->v, &c->v);
   if (isAbsValueLessThanEpsSquared(dist_squared)) {
     use_polytope3 = true;
   }
   if (!use_polytope3) {
     dist_squared =
-        ccdVec3PointTriDist2(ccd_vec3_origin, &a->v, &c->v, &d->v, NULL);
+        ccdVec3PointTriDist2NoWitness(ccd_vec3_origin, &a->v, &c->v, &d->v);
     if (isAbsValueLessThanEpsSquared(dist_squared)) {
       use_polytope3 = true;
       ccdSimplexSet(simplex, 1, c);
@@ -860,7 +890,7 @@ static int simplexToPolytope4(const void* obj1, const void* obj2,
   }
   if (!use_polytope3) {
     dist_squared =
-        ccdVec3PointTriDist2(ccd_vec3_origin, &a->v, &b->v, &d->v, NULL);
+        ccdVec3PointTriDist2NoWitness(ccd_vec3_origin, &a->v, &b->v, &d->v);
     if (isAbsValueLessThanEpsSquared(dist_squared)) {
       use_polytope3 = true;
       ccdSimplexSet(simplex, 2, d);
@@ -868,7 +898,7 @@ static int simplexToPolytope4(const void* obj1, const void* obj2,
   }
   if (!use_polytope3) {
     dist_squared =
-        ccdVec3PointTriDist2(ccd_vec3_origin, &b->v, &c->v, &d->v, NULL);
+        ccdVec3PointTriDist2NoWitness(ccd_vec3_origin, &b->v, &c->v, &d->v);
     if (isAbsValueLessThanEpsSquared(dist_squared)) {
       use_polytope3 = true;
       ccdSimplexSet(simplex, 0, b);
@@ -1583,9 +1613,7 @@ static int nextSupport(const ccd_pt_t* polytope, const void* obj1,
     ccdPtFaceVec3(reinterpret_cast<const ccd_pt_face_t*>(el), &a, &b, &c);
 
     // check if new point can significantly expand polytope
-    ccd_vec3_t point_projection_on_triangle_unused;
-    dist_squared = ccdVec3PointTriDist2(&out->v, a, b, c,
-                                        &point_projection_on_triangle_unused);
+    dist_squared = ccdVec3PointTriDist2NoWitness(&out->v, a, b, c);
   }
 
   if (std::sqrt(dist_squared) < ccd->epa_tolerance) return -1;
@@ -1716,9 +1744,12 @@ static void validateNearestFeatureOfPolytopeBeingEdge(ccd_pt_t* polytope) {
     // distance to be considered zero. We assume that the GJK/EPA code
     // ultimately classifies inside/outside around *zero* and *not* epsilon.
     if (origin_to_face_distance[i] > plane_threshold) {
-      FCL_THROW_FAILED_AT_THIS_CONFIGURATION(
-          "The origin is outside of the polytope. This should already have "
-          "been identified as separating.");
+      fcl::logging::StringBuilder builder;
+      builder << "The origin is outside of the polytope by "
+              << origin_to_face_distance[i] << ", exceeding the threshold "
+              << plane_threshold
+              << ". This should already have been identified as separating.";
+      FCL_THROW_FAILED_AT_THIS_CONFIGURATION(builder.str());
     }
   }
 
@@ -2065,11 +2096,10 @@ static inline ccd_real_t _ccdDist(const void *obj1, const void *obj2,
     }
     else if (ccdSimplexSize(simplex) == 3)
     {
-      dist = ccdVec3PointTriDist2(ccd_vec3_origin,
-                                  &ccdSimplexPoint(simplex, 0)->v,
-                                  &ccdSimplexPoint(simplex, 1)->v,
-                                  &ccdSimplexPoint(simplex, 2)->v,
-                                  &closest_p);
+      dist = ccdVec3PointTriDist2WithWitness(
+          ccd_vec3_origin, &ccdSimplexPoint(simplex, 0)->v,
+          &ccdSimplexPoint(simplex, 1)->v, &ccdSimplexPoint(simplex, 2)->v,
+          &closest_p);
       dist = CCD_SQRT(dist);
     }
     else
diff --git a/include/fcl/narrowphase/detail/failed_at_this_configuration.h b/include/fcl/narrowphase/detail/failed_at_this_configuration.h
index b36bb59..e52a934 100644
--- a/include/fcl/narrowphase/detail/failed_at_this_configuration.h
+++ b/include/fcl/narrowphase/detail/failed_at_this_configuration.h
@@ -38,12 +38,16 @@
 #define FCL_FAILED_AT_THIS_CONFIGURATION_H
 
 #include <exception>
-#include <iomanip>
-#include <iostream>
-#include <sstream>
 #include <stdexcept>
 #include <string>
 
+#if FCL_ENABLE_STD_LOGGING
+#include <iomanip>
+#include <ostream>
+#include <sstream>
+#endif
+
+#include "fcl/common/types.h"
 #include "fcl/export.h"
 
 namespace fcl {
@@ -85,6 +89,48 @@ class FCL_EXPORT FailedAtThisConfiguration final
 FCL_EXPORT void ThrowFailedAtThisConfiguration(
     const std::string& message, const char* func, const char* file, int line);
 
+/** Works in conjuction with ThrowDetailedConfiguration() to format the pose
+ in a more python-like repr() way (facilitating error reproduction). In this
+ case, just doing comma-delimited print outs makes copying-and-pasting the
+ error message contents into code easier.
+
+ The intention is that the matrix is printed out as:
+
+      a, b, c, d,
+      e, f, g, h,
+      i, j, k, l,
+      m, n, o, p;
+
+ so, that it can easily be copied and pasted into code like this:
+
+ Transform3<S> X;
+ X.matrix() << a, b, c, d,
+               e, f, g, h,
+               i, j, k, l,
+               m, n, o, p; */
+#if FCL_ENABLE_STD_LOGGING
+
+template <typename S>
+void WriteCommaSeparated(
+    std::stringstream* sstream,
+    const Transform3<S>& p) {
+  const auto& m = p.matrix();
+  std::stringstream& ss = *sstream;
+  for (int row = 0; row < 4; ++row) {
+    for (int col = 0; col < 4; ++col) {
+      ss << m(row, col);
+      if (col < 3) {
+        ss << ", ";
+      }
+    }
+    if (row < 3) {
+      ss << ",\n";
+    } else {
+      ss << ";";
+    }
+  }
+}
+
 /** Helper class for propagating a low-level exception upwards but with
  configuration-specific details appended. The parameters
  
@@ -99,22 +145,36 @@ FCL_EXPORT void ThrowFailedAtThisConfiguration(
  @tparam Solver   The solver type (with scalar type erase).
  @tparam Pose     The pose type (a Transform<S> with scalar type erased).
  */
-template <typename Shape1, typename Shape2, typename Solver, typename Pose>
-void ThrowDetailedConfiguration(const Shape1& s1, const Pose& X_FS1,
-                                const Shape2& s2, const Pose& X_FS2,
+template <typename Shape1, typename Shape2, typename Solver, typename S>
+void ThrowDetailedConfiguration(const Shape1& s1, const Transform3<S>& X_FS1,
+                                const Shape2& s2, const Transform3<S>& X_FS2,
                                 const Solver& solver, const std::exception& e) {
   std::stringstream ss;
-  ss << std::setprecision(20);
+  const int digits = 20;
+  ss << std::setprecision(digits);
   ss << "Error with configuration"
      << "\n  Original error message: " << e.what()
-     << "\n  Shape 1: " << s1
-     << "\n  X_FS1\n" << X_FS1.matrix()
-     << "\n  Shape 2: " << s2
-     << "\n  X_FS2\n" << X_FS2.matrix()
-     << "\n  Solver: " << solver;
+     << "\n  Shape 1:\n" << s1.representation(digits)
+     << "\n  X_FS1\n";
+  WriteCommaSeparated(&ss, X_FS1);
+  ss << "\n  Shape 2:\n" << s2.representation(digits)
+     << "\n  X_FS2\n";
+  WriteCommaSeparated(&ss, X_FS2);
+  ss << "\n  Solver: " << solver;
   throw std::logic_error(ss.str());
 }
 
+#else
+
+template <typename Shape1, typename Shape2, typename Solver, typename S>
+void ThrowDetailedConfiguration(const Shape1&, const Transform3<S>&,
+                                const Shape2&, const Transform3<S>&,
+                                const Solver&, const std::exception& e) {
+  throw std::logic_error(e.what());
+}
+
+#endif
+
 }  // namespace detail
 }  // namespace fcl
 
diff --git a/include/fcl/narrowphase/distance-inl.h b/include/fcl/narrowphase/distance-inl.h
index 3244631..e406efc 100644
--- a/include/fcl/narrowphase/distance-inl.h
+++ b/include/fcl/narrowphase/distance-inl.h
@@ -118,7 +118,7 @@ typename NarrowPhaseSolver::S distance(
   {
     if(!looktable.distance_matrix[node_type2][node_type1])
     {
-      std::cerr << "Warning: distance function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
+      FCL_CERR << "Warning: distance function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
     }
     else
     {
@@ -129,7 +129,7 @@ typename NarrowPhaseSolver::S distance(
   {
     if(!looktable.distance_matrix[node_type1][node_type2])
     {
-      std::cerr << "Warning: distance function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
+      FCL_CERR << "Warning: distance function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
     }
     else
     {
diff --git a/src/common/detail/profiler.cpp b/src/common/detail/profiler.cpp
index 6d78ee0..cb1a682 100644
--- a/src/common/detail/profiler.cpp
+++ b/src/common/detail/profiler.cpp
@@ -37,6 +37,12 @@
 
 #include "fcl/common/detail/profiler.h"
 
+#if FCL_ENABLE_PROFILING
+
+#if FCL_ENABLE_STD_LOGGING
+#include <iostream>
+#endif
+
 namespace fcl {
 namespace detail {
 
@@ -58,8 +64,12 @@ Profiler::Profiler(bool printOnDestroy, bool autoStart)
 //==============================================================================
 Profiler::~Profiler()
 {
+#if FCL_ENABLE_STD_LOGGING
   if (printOnDestroy_ && !data_.empty())
-    status();
+    status(std::cerr);
+#else
+  printOnDestroy_ = false;
+#endif
 }
 
 //==============================================================================
@@ -397,3 +407,74 @@ Profiler::ScopedBlock::~ScopedBlock()
 
 } // namespace detail
 } // namespace fcl
+
+#else  // !FCL_ENABLE_PROFILING
+
+namespace fcl {
+namespace detail {
+
+Profiler& Profiler::Instance(void)
+{
+  static Profiler instance(false, false);
+  return instance;
+}
+
+Profiler::Profiler(bool printOnDestroy, bool autoStart)
+  : running_(false), printOnDestroy_(printOnDestroy)
+{
+  (void)autoStart;
+}
+
+Profiler::~Profiler() = default;
+
+void Profiler::Start() {}
+void Profiler::Stop() {}
+void Profiler::Clear() {}
+
+void Profiler::start(void) {}
+void Profiler::stop(void) {}
+void Profiler::clear(void) {}
+
+void Profiler::Event(const std::string&, const unsigned int) {}
+void Profiler::event(const std::string&, const unsigned int) {}
+
+void Profiler::Average(const std::string&, const double) {}
+void Profiler::average(const std::string&, const double) {}
+
+void Profiler::Begin(const std::string&) {}
+void Profiler::End(const std::string&) {}
+void Profiler::begin(const std::string&) {}
+void Profiler::end(const std::string&) {}
+
+void Profiler::Status(std::ostream&, bool) {}
+void Profiler::status(std::ostream&, bool) {}
+
+bool Profiler::running(void) const { return false; }
+bool Profiler::Running(void) { return false; }
+
+Profiler::TimeInfo::TimeInfo()
+  : total(), shortest(), longest(), parts(0)
+{
+}
+
+void Profiler::TimeInfo::set() {}
+void Profiler::TimeInfo::update() {}
+
+Profiler::ScopedBlock::ScopedBlock(const std::string& name, Profiler& prof)
+  : name_(name), prof_(prof)
+{
+}
+
+Profiler::ScopedBlock::~ScopedBlock() = default;
+
+Profiler::ScopedStart::ScopedStart(Profiler& prof)
+  : prof_(prof), wasRunning_(false)
+{
+}
+
+Profiler::ScopedStart::~ScopedStart() = default;
+
+} // namespace detail
+} // namespace fcl
+
+#endif  // FCL_ENABLE_PROFILING
diff --git a/src/narrowphase/detail/failed_at_this_configuration.cpp b/src/narrowphase/detail/failed_at_this_configuration.cpp
index ba7875d..34815a9 100644
--- a/src/narrowphase/detail/failed_at_this_configuration.cpp
+++ b/src/narrowphase/detail/failed_at_this_configuration.cpp
@@ -1,6 +1,8 @@
 #include "fcl/narrowphase/detail/failed_at_this_configuration.h"
 
+#if FCL_ENABLE_STD_LOGGING
 #include <sstream>
+#endif
 
 namespace fcl {
 namespace detail {
@@ -8,9 +10,16 @@ namespace detail {
 void ThrowFailedAtThisConfiguration(const std::string& message,
                                     const char* func,
                                     const char* file, int line) {
+#if FCL_ENABLE_STD_LOGGING
   std::stringstream ss;
   ss << file << ":(" << line << "): " << func << "(): " << message;
   throw FailedAtThisConfiguration(ss.str());
+#else
+  (void)func;
+  (void)file;
+  (void)line;
+  throw FailedAtThisConfiguration(message);
+#endif
 }
 
 }  // namespace detail
