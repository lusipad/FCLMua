diff --git a/include/fcl/broadphase/detail/hierarchy_tree-inl.h b/include/fcl/broadphase/detail/hierarchy_tree-inl.h
index 1438eb9..6381b86 100644
--- a/include/fcl/broadphase/detail/hierarchy_tree-inl.h
+++ b/include/fcl/broadphase/detail/hierarchy_tree-inl.h
@@ -326,6 +326,7 @@ typename HierarchyTree<BV>::NodeType*& HierarchyTree<BV>::getRoot()
 template<typename BV>
 void HierarchyTree<BV>::print(NodeType* root, int depth)
 {
+#if FCL_ENABLE_STD_LOGGING
   for(int i = 0; i < depth; ++i)
     std::cout << " ";
   std::cout << " (" << root->bv.min_[0] << ", " << root->bv.min_[1] << ", " << root->bv.min_[2] << "; " << root->bv.max_[0] << ", " << root->bv.max_[1] << ", " << root->bv.max_[2] << ")" << std::endl;
@@ -337,6 +338,10 @@ void HierarchyTree<BV>::print(NodeType* root, int depth)
     print(root->children[0], depth+1);
     print(root->children[1], depth+1);
   }
+#else
+  (void)root;
+  (void)depth;
+#endif
 }
 
 //==============================================================================
diff --git a/include/fcl/broadphase/detail/hierarchy_tree_array-inl.h b/include/fcl/broadphase/detail/hierarchy_tree_array-inl.h
index b4edc40..cb999a0 100644
--- a/include/fcl/broadphase/detail/hierarchy_tree_array-inl.h
+++ b/include/fcl/broadphase/detail/hierarchy_tree_array-inl.h
@@ -503,6 +503,7 @@ typename HierarchyTree<BV>::NodeType* HierarchyTree<BV>::getNodes() const
 template<typename BV>
 void HierarchyTree<BV>::print(size_t root, int depth)
 {
+#if FCL_ENABLE_STD_LOGGING
   for(int i = 0; i < depth; ++i)
     std::cout << " ";
   NodeType* n = nodes + root;
@@ -515,6 +516,10 @@ void HierarchyTree<BV>::print(size_t root, int depth)
     print(n->children[0], depth+1);
     print(n->children[1], depth+1);
   }
+#else
+  (void)root;
+  (void)depth;
+#endif
 }
 
 //==============================================================================
diff --git a/include/fcl/broadphase/detail/interval_tree_node-inl.h b/include/fcl/broadphase/detail/interval_tree_node-inl.h
index 2badc04..3e35502 100644
--- a/include/fcl/broadphase/detail/interval_tree_node-inl.h
+++ b/include/fcl/broadphase/detail/interval_tree_node-inl.h
@@ -79,6 +79,7 @@ template <typename S>
 void IntervalTreeNode<S>::print(
     IntervalTreeNode<S>* nil, IntervalTreeNode<S>* root) const
 {
+#if FCL_ENABLE_STD_LOGGING
   stored_interval->print();
   std::cout << ", k = " << key << ", h = " << high << ", mH = " << max_high;
   std::cout << "  l->key = ";
@@ -88,6 +89,10 @@ void IntervalTreeNode<S>::print(
   std::cout << "  p->key = ";
   if(parent == root) std::cout << "nullptr"; else std::cout << parent->key;
   std::cout << "  red = " << (int)red << std::endl;
+#else
+  (void)nil;
+  (void)root;
+#endif
 }
 
 } // namespace detail
diff --git a/include/fcl/common/detail/profiler.h b/include/fcl/common/detail/profiler.h
index 76e3675..aefdf64 100644
--- a/include/fcl/common/detail/profiler.h
+++ b/include/fcl/common/detail/profiler.h
@@ -40,7 +40,7 @@
 
 #include <algorithm>
 #include <chrono>
-#include <iostream>
+#include <iosfwd>
 #include <map>
 #include <cmath>
 #include <mutex>
@@ -131,12 +131,12 @@ public:
   /// @brief Print the status of the profiled code chunks and
   /// events. Optionally, computation done by different threads
   /// can be printed separately.
-  static void Status(std::ostream &out = std::cout, bool merge = true);
+  static void Status(std::ostream &out, bool merge = true);
 
   /// @brief Print the status of the profiled code chunks and
   /// events. Optionally, computation done by different threads
   /// can be printed separately.
-  void status(std::ostream &out = std::cout, bool merge = true);
+  void status(std::ostream &out, bool merge = true);
 
   /// @brief Check if the profiler is counting time or not
   bool running(void) const;
diff --git a/include/fcl/common/types.h b/include/fcl/common/types.h
index 892e2b0..92c519c 100644
--- a/include/fcl/common/types.h
+++ b/include/fcl/common/types.h
@@ -38,6 +38,7 @@
 #ifndef FCL_DATA_TYPES_H
 #define FCL_DATA_TYPES_H
 
+#include <cassert>
 #include <cstddef>
 #include <cstdint>
 #include <vector>
@@ -46,6 +47,7 @@
 #include <Eigen/Dense>
 #include <Eigen/StdVector>
 #include "fcl/export.h"
+#include "fcl/logging.h"
 
 namespace fcl
 {
diff --git a/include/fcl/config.h b/include/fcl/config.h
new file mode 100644
index 0000000..33f599e
--- /dev/null
+++ b/include/fcl/config.h
@@ -0,0 +1,8 @@
+#pragma once
+
+// Generated stub for kernel build: OctoMap is not available in this environment.
+#define FCL_HAVE_OCTOMAP 0
+
+#ifndef FCL_ENABLE_PROFILING
+#define FCL_ENABLE_PROFILING 0
+#endif
diff --git a/include/fcl/export.h b/include/fcl/export.h
new file mode 100644
index 0000000..cc26ebb
--- /dev/null
+++ b/include/fcl/export.h
@@ -0,0 +1,54 @@
+#pragma once
+
+#if defined(_MSC_VER)
+#  define FCL_HELPER_DLL_IMPORT __declspec(dllimport)
+#  define FCL_HELPER_DLL_EXPORT __declspec(dllexport)
+#  define FCL_HELPER_DLL_LOCAL
+#else
+#  if __GNUC__ >= 4
+#    define FCL_HELPER_DLL_IMPORT __attribute__((visibility("default")))
+#    define FCL_HELPER_DLL_EXPORT __attribute__((visibility("default")))
+#    define FCL_HELPER_DLL_LOCAL  __attribute__((visibility("hidden")))
+#  else
+#    define FCL_HELPER_DLL_IMPORT
+#    define FCL_HELPER_DLL_EXPORT
+#    define FCL_HELPER_DLL_LOCAL
+#  endif
+#endif
+
+#ifdef FCL_STATIC_DEFINE
+#  define FCL_EXPORT
+#  define FCL_NO_EXPORT
+#else
+#  ifdef FCL_EXPORTS
+#    define FCL_EXPORT FCL_HELPER_DLL_EXPORT
+#  else
+#    define FCL_EXPORT FCL_HELPER_DLL_IMPORT
+#  endif
+#  define FCL_NO_EXPORT FCL_HELPER_DLL_LOCAL
+#endif
+
+#if !defined(FCL_DEPRECATED)
+#  if defined(_MSC_VER)
+#    define FCL_DEPRECATED __declspec(deprecated)
+#  else
+#    define FCL_DEPRECATED __attribute__((deprecated))
+#  endif
+#endif
+
+#if !defined(FCL_DEPRECATED_EXPORT)
+#  define FCL_DEPRECATED_EXPORT FCL_EXPORT FCL_DEPRECATED
+#endif
+
+#if !defined(FCL_DEPRECATED_NO_EXPORT)
+#  define FCL_DEPRECATED_NO_EXPORT FCL_NO_EXPORT FCL_DEPRECATED
+#endif
+
+#if defined(FCL_NO_DEPRECATED)
+#  undef FCL_DEPRECATED
+#  define FCL_DEPRECATED
+#  undef FCL_DEPRECATED_EXPORT
+#  define FCL_DEPRECATED_EXPORT FCL_EXPORT
+#  undef FCL_DEPRECATED_NO_EXPORT
+#  define FCL_DEPRECATED_NO_EXPORT FCL_NO_EXPORT
+#endif
diff --git a/include/fcl/geometry/bvh/BVH_model-inl.h b/include/fcl/geometry/bvh/BVH_model-inl.h
index 906a593..9cadae4 100644
--- a/include/fcl/geometry/bvh/BVH_model-inl.h
+++ b/include/fcl/geometry/bvh/BVH_model-inl.h
@@ -228,7 +228,7 @@ int BVHModel<BV>::beginModel(int num_tris_, int num_vertices_)
     tri_indices = new(std::nothrow) Triangle[num_tris_allocated];
     if(!tri_indices)
     {
-      std::cerr << "BVH Error! Out of memory for tri_indices array on BeginModel() call!\n";
+      FCL_CERR << "BVH Error! Out of memory for tri_indices array on BeginModel() call!\n";
       return BVH_ERR_MODEL_OUT_OF_MEMORY;
     }
   }
@@ -236,13 +236,13 @@ int BVHModel<BV>::beginModel(int num_tris_, int num_vertices_)
   vertices = new Vector3<S>[num_vertices_allocated];
   if(!vertices)
   {
-    std::cerr << "BVH Error! Out of memory for vertices array on BeginModel() call!\n";
+    FCL_CERR << "BVH Error! Out of memory for vertices array on BeginModel() call!\n";
     return BVH_ERR_MODEL_OUT_OF_MEMORY;
   }
 
   if(build_state != BVH_BUILD_STATE_EMPTY)
   {
-    std::cerr << "BVH Warning! Call beginModel() on a BVHModel that is not empty. This model was cleared and previous triangles/vertices were lost.\n";
+    FCL_CERR << "BVH Warning! Call beginModel() on a BVHModel that is not empty. This model was cleared and previous triangles/vertices were lost.\n";
     build_state = BVH_BUILD_STATE_EMPTY;
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
@@ -258,7 +258,7 @@ int BVHModel<BV>::addVertex(const Vector3<S>& p)
 {
   if(build_state != BVH_BUILD_STATE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call addVertex() in a wrong order. addVertex() was ignored. Must do a beginModel() to clear the model for addition of new vertices.\n";
+    FCL_CERR << "BVH Warning! Call addVertex() in a wrong order. addVertex() was ignored. Must do a beginModel() to clear the model for addition of new vertices.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -267,7 +267,7 @@ int BVHModel<BV>::addVertex(const Vector3<S>& p)
     Vector3<S>* temp = new Vector3<S>[num_vertices_allocated * 2];
     if(!temp)
     {
-      std::cerr << "BVH Error! Out of memory for vertices array on addVertex() call!\n";
+      FCL_CERR << "BVH Error! Out of memory for vertices array on addVertex() call!\n";
       return BVH_ERR_MODEL_OUT_OF_MEMORY;
     }
 
@@ -289,7 +289,7 @@ int BVHModel<BV>::addTriangle(const Vector3<S>& p1, const Vector3<S>& p2, const
 {
   if(build_state == BVH_BUILD_STATE_PROCESSED)
   {
-    std::cerr << "BVH Warning! Call addTriangle() in a wrong order. addTriangle() was ignored. Must do a beginModel() to clear the model for addition of new triangles.\n";
+    FCL_CERR << "BVH Warning! Call addTriangle() in a wrong order. addTriangle() was ignored. Must do a beginModel() to clear the model for addition of new triangles.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -298,7 +298,7 @@ int BVHModel<BV>::addTriangle(const Vector3<S>& p1, const Vector3<S>& p2, const
     Vector3<S>* temp = new Vector3<S>[num_vertices_allocated * 2 + 2];
     if(!temp)
     {
-      std::cerr << "BVH Error! Out of memory for vertices array on addTriangle() call!\n";
+      FCL_CERR << "BVH Error! Out of memory for vertices array on addTriangle() call!\n";
       return BVH_ERR_MODEL_OUT_OF_MEMORY;
     }
 
@@ -326,7 +326,7 @@ int BVHModel<BV>::addTriangle(const Vector3<S>& p1, const Vector3<S>& p2, const
     Triangle* temp = new Triangle[num_tris_allocated * 2];
     if(!temp)
     {
-      std::cerr << "BVH Error! Out of memory for tri_indices array on addTriangle() call!\n";
+      FCL_CERR << "BVH Error! Out of memory for tri_indices array on addTriangle() call!\n";
       return BVH_ERR_MODEL_OUT_OF_MEMORY;
     }
 
@@ -348,7 +348,7 @@ int BVHModel<BV>::addSubModel(const std::vector<Vector3<S>>& ps)
 {
   if(build_state == BVH_BUILD_STATE_PROCESSED)
   {
-    std::cerr << "BVH Warning! Call addSubModel() in a wrong order. addSubModel() was ignored. Must do a beginModel() to clear the model for addition of new vertices.\n";
+    FCL_CERR << "BVH Warning! Call addSubModel() in a wrong order. addSubModel() was ignored. Must do a beginModel() to clear the model for addition of new vertices.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -359,7 +359,7 @@ int BVHModel<BV>::addSubModel(const std::vector<Vector3<S>>& ps)
     Vector3<S>* temp = new Vector3<S>[num_vertices_allocated * 2 + num_vertices_to_add - 1];
     if(!temp)
     {
-      std::cerr << "BVH Error! Out of memory for vertices array on addSubModel() call!\n";
+      FCL_CERR << "BVH Error! Out of memory for vertices array on addSubModel() call!\n";
       return BVH_ERR_MODEL_OUT_OF_MEMORY;
     }
 
@@ -384,7 +384,7 @@ int BVHModel<BV>::addSubModel(const std::vector<Vector3<S>>& ps, const std::vect
 {
   if(build_state == BVH_BUILD_STATE_PROCESSED)
   {
-    std::cerr << "BVH Warning! Call addSubModel() in a wrong order. addSubModel() was ignored. Must do a beginModel() to clear the model for addition of new vertices.\n";
+    FCL_CERR << "BVH Warning! Call addSubModel() in a wrong order. addSubModel() was ignored. Must do a beginModel() to clear the model for addition of new vertices.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -395,7 +395,7 @@ int BVHModel<BV>::addSubModel(const std::vector<Vector3<S>>& ps, const std::vect
     Vector3<S>* temp = new Vector3<S>[num_vertices_allocated * 2 + num_vertices_to_add - 1];
     if(!temp)
     {
-      std::cerr << "BVH Error! Out of memory for vertices array on addSubModel() call!\n";
+      FCL_CERR << "BVH Error! Out of memory for vertices array on addSubModel() call!\n";
       return BVH_ERR_MODEL_OUT_OF_MEMORY;
     }
 
@@ -425,7 +425,7 @@ int BVHModel<BV>::addSubModel(const std::vector<Vector3<S>>& ps, const std::vect
     Triangle* temp = new(std::nothrow) Triangle[num_tris_allocated * 2 + num_tris_to_add - 1];
     if(!temp)
     {
-      std::cerr << "BVH Error! Out of memory for tri_indices array on addSubModel() call!\n";
+      FCL_CERR << "BVH Error! Out of memory for tri_indices array on addSubModel() call!\n";
       return BVH_ERR_MODEL_OUT_OF_MEMORY;
     }
 
@@ -451,13 +451,13 @@ int BVHModel<BV>::endModel()
 {
   if(build_state != BVH_BUILD_STATE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call endModel() in wrong order. endModel() was ignored.\n";
+    FCL_CERR << "BVH Warning! Call endModel() in wrong order. endModel() was ignored.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
   if(num_tris == 0 && num_vertices == 0)
   {
-    std::cerr << "BVH Error! endModel() called on model with no triangles and vertices.\n";
+    FCL_CERR << "BVH Error! endModel() called on model with no triangles and vertices.\n";
     return BVH_ERR_BUILD_EMPTY_MODEL;
   }
 
@@ -466,7 +466,7 @@ int BVHModel<BV>::endModel()
     Triangle* new_tris = new(std::nothrow) Triangle[num_tris];
     if(!new_tris)
     {
-      std::cerr << "BVH Error! Out of memory for tri_indices array in endModel() call!\n";
+      FCL_CERR << "BVH Error! Out of memory for tri_indices array in endModel() call!\n";
       return BVH_ERR_MODEL_OUT_OF_MEMORY;
     }
     std::copy(tri_indices, tri_indices + num_tris, new_tris);
@@ -480,7 +480,7 @@ int BVHModel<BV>::endModel()
     Vector3<S>* new_vertices = new Vector3<S>[num_vertices];
     if(!new_vertices)
     {
-      std::cerr << "BVH Error! Out of memory for vertices array in endModel() call!\n";
+      FCL_CERR << "BVH Error! Out of memory for vertices array in endModel() call!\n";
       return BVH_ERR_MODEL_OUT_OF_MEMORY;
     }
     std::copy(vertices, vertices + num_vertices, new_vertices);
@@ -502,7 +502,7 @@ int BVHModel<BV>::endModel()
   primitive_indices = new(std::nothrow) unsigned int [num_bvs_to_be_allocated];
   if(!bvs || !primitive_indices)
   {
-    std::cerr << "BVH Error! Out of memory for BV array in endModel()!\n";
+    FCL_CERR << "BVH Error! Out of memory for BV array in endModel()!\n";
     return BVH_ERR_MODEL_OUT_OF_MEMORY;
   }
   num_bvs_allocated = num_bvs_to_be_allocated;
@@ -522,7 +522,7 @@ int BVHModel<BV>::beginReplaceModel()
 {
   if(build_state != BVH_BUILD_STATE_PROCESSED)
   {
-    std::cerr << "BVH Error! Call beginReplaceModel() on a BVHModel that has no previous frame.\n";
+    FCL_CERR << "BVH Error! Call beginReplaceModel() on a BVHModel that has no previous frame.\n";
     return BVH_ERR_BUILD_EMPTY_PREVIOUS_FRAME;
   }
 
@@ -545,7 +545,7 @@ int BVHModel<BV>::replaceVertex(const Vector3<S>& p)
 {
   if(build_state != BVH_BUILD_STATE_REPLACE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call replaceVertex() in a wrong order. replaceVertex() was ignored. Must do a beginReplaceModel() for initialization.\n";
+    FCL_CERR << "BVH Warning! Call replaceVertex() in a wrong order. replaceVertex() was ignored. Must do a beginReplaceModel() for initialization.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -561,7 +561,7 @@ int BVHModel<BV>::replaceTriangle(const Vector3<S>& p1, const Vector3<S>& p2, co
 {
   if(build_state != BVH_BUILD_STATE_REPLACE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call replaceTriangle() in a wrong order. replaceTriangle() was ignored. Must do a beginReplaceModel() for initialization.\n";
+    FCL_CERR << "BVH Warning! Call replaceTriangle() in a wrong order. replaceTriangle() was ignored. Must do a beginReplaceModel() for initialization.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -577,7 +577,7 @@ int BVHModel<BV>::replaceSubModel(const std::vector<Vector3<S>>& ps)
 {
   if(build_state != BVH_BUILD_STATE_REPLACE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call replaceSubModel() in a wrong order. replaceSubModel() was ignored. Must do a beginReplaceModel() for initialization.\n";
+    FCL_CERR << "BVH Warning! Call replaceSubModel() in a wrong order. replaceSubModel() was ignored. Must do a beginReplaceModel() for initialization.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -595,13 +595,13 @@ int BVHModel<BV>::endReplaceModel(bool refit, bool bottomup)
 {
   if(build_state != BVH_BUILD_STATE_REPLACE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call endReplaceModel() in a wrong order. endReplaceModel() was ignored. \n";
+    FCL_CERR << "BVH Warning! Call endReplaceModel() in a wrong order. endReplaceModel() was ignored. \n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
   if(num_vertex_updated != num_vertices)
   {
-    std::cerr << "BVH Error! The replaced model should have the same number of vertices as the old model.\n";
+    FCL_CERR << "BVH Error! The replaced model should have the same number of vertices as the old model.\n";
     return BVH_ERR_INCORRECT_DATA;
   }
 
@@ -625,7 +625,7 @@ int BVHModel<BV>::beginUpdateModel()
 {
   if(build_state != BVH_BUILD_STATE_PROCESSED && build_state != BVH_BUILD_STATE_UPDATED)
   {
-    std::cerr << "BVH Error! Call beginUpdatemodel() on a BVHModel that has no previous frame.\n";
+    FCL_CERR << "BVH Error! Call beginUpdatemodel() on a BVHModel that has no previous frame.\n";
     return BVH_ERR_BUILD_EMPTY_PREVIOUS_FRAME;
   }
 
@@ -654,7 +654,7 @@ int BVHModel<BV>::updateVertex(const Vector3<S>& p)
 {
   if(build_state != BVH_BUILD_STATE_UPDATE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call updateVertex() in a wrong order. updateVertex() was ignored. Must do a beginUpdateModel() for initialization.\n";
+    FCL_CERR << "BVH Warning! Call updateVertex() in a wrong order. updateVertex() was ignored. Must do a beginUpdateModel() for initialization.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -670,7 +670,7 @@ int BVHModel<BV>::updateTriangle(const Vector3<S>& p1, const Vector3<S>& p2, con
 {
   if(build_state != BVH_BUILD_STATE_UPDATE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call updateTriangle() in a wrong order. updateTriangle() was ignored. Must do a beginUpdateModel() for initialization.\n";
+    FCL_CERR << "BVH Warning! Call updateTriangle() in a wrong order. updateTriangle() was ignored. Must do a beginUpdateModel() for initialization.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -686,7 +686,7 @@ int BVHModel<BV>::updateSubModel(const std::vector<Vector3<S>>& ps)
 {
   if(build_state != BVH_BUILD_STATE_UPDATE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call updateSubModel() in a wrong order. updateSubModel() was ignored. Must do a beginUpdateModel() for initialization.\n";
+    FCL_CERR << "BVH Warning! Call updateSubModel() in a wrong order. updateSubModel() was ignored. Must do a beginUpdateModel() for initialization.\n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
@@ -704,13 +704,13 @@ int BVHModel<BV>::endUpdateModel(bool refit, bool bottomup)
 {
   if(build_state != BVH_BUILD_STATE_UPDATE_BEGUN)
   {
-    std::cerr << "BVH Warning! Call endUpdateModel() in a wrong order. endUpdateModel() was ignored. \n";
+    FCL_CERR << "BVH Warning! Call endUpdateModel() in a wrong order. endUpdateModel() was ignored. \n";
     return BVH_ERR_BUILD_OUT_OF_SEQUENCE;
   }
 
   if(num_vertex_updated != num_vertices)
   {
-    std::cerr << "BVH Error! The updated model should have the same number of vertices as the old model.\n";
+    FCL_CERR << "BVH Error! The updated model should have the same number of vertices as the old model.\n";
     return BVH_ERR_INCORRECT_DATA;
   }
 
@@ -744,10 +744,10 @@ int BVHModel<BV>::memUsage(int msg) const
   int total_mem = mem_bv_list + mem_tri_list + mem_vertex_list + sizeof(BVHModel<BV>);
   if(msg)
   {
-    std::cerr << "Total for model " << total_mem << " bytes.\n";
-    std::cerr << "BVs: " << num_bvs << " allocated.\n";
-    std::cerr << "Tris: " << num_tris << " allocated.\n";
-    std::cerr << "Vertices: " << num_vertices << " allocated.\n";
+    FCL_CERR << "Total for model " << total_mem << " bytes.\n";
+    FCL_CERR << "BVs: " << num_bvs << " allocated.\n";
+    FCL_CERR << "Tris: " << num_tris << " allocated.\n";
+    FCL_CERR << "Vertices: " << num_vertices << " allocated.\n";
   }
 
   return BVH_OK;
@@ -849,7 +849,7 @@ int BVHModel<BV>::buildTree()
     num_primitives = num_vertices;
     break;
   default:
-    std::cerr << "BVH Error: Model type not supported!\n";
+    FCL_CERR << "BVH Error: Model type not supported!\n";
     return BVH_ERR_UNSUPPORTED_FUNCTION;
   }
 
@@ -903,7 +903,7 @@ int BVHModel<BV>::recursiveBuildTree(int bv_id, int first_primitive, int num_pri
       }
       else
       {
-        std::cerr << "BVH Error: Model type not supported!\n";
+        FCL_CERR << "BVH Error: Model type not supported!\n";
         return BVH_ERR_UNSUPPORTED_FUNCTION;
       }
 
@@ -1012,7 +1012,7 @@ int BVHModel<BV>::recursiveRefitTree_bottomup(int bv_id)
     }
     else
     {
-      std::cerr << "BVH Error: Model type not supported!\n";
+      FCL_CERR << "BVH Error: Model type not supported!\n";
       return BVH_ERR_UNSUPPORTED_FUNCTION;
     }
   }
diff --git a/include/fcl/geometry/bvh/detail/BV_splitter-inl.h b/include/fcl/geometry/bvh/detail/BV_splitter-inl.h
index 26e8bf0..c9c916e 100644
--- a/include/fcl/geometry/bvh/detail/BV_splitter-inl.h
+++ b/include/fcl/geometry/bvh/detail/BV_splitter-inl.h
@@ -90,7 +90,7 @@ void BVSplitter<BV>::computeRule(
     computeRule_bvcenter(bv, primitive_indices, num_primitives);
     break;
   default:
-    std::cerr << "Split method not supported\n";
+    FCL_CERR << "Split method not supported\n";
   }
 }
 
diff --git a/include/fcl/geometry/geometric_shape_to_BVH_model-inl.h b/include/fcl/geometry/geometric_shape_to_BVH_model-inl.h
index 7fe4386..f75bac0 100644
--- a/include/fcl/geometry/geometric_shape_to_BVH_model-inl.h
+++ b/include/fcl/geometry/geometric_shape_to_BVH_model-inl.h
@@ -444,4 +444,4 @@ int generateBVHModel(BVHModel<BV>& model, const Cone<typename BV::S>& shape, con
 
 } // namespace fcl
 
-#endif
\ No newline at end of file
+#endif
diff --git a/include/fcl/geometry/geometric_shape_to_BVH_model.h b/include/fcl/geometry/geometric_shape_to_BVH_model.h
index d44350d..acf8cc5 100644
--- a/include/fcl/geometry/geometric_shape_to_BVH_model.h
+++ b/include/fcl/geometry/geometric_shape_to_BVH_model.h
@@ -161,4 +161,4 @@ int generateBVHModel(BVHModel<BV>& model, const Cone<typename BV::S>& shape, con
 
 #include "fcl/geometry/geometric_shape_to_BVH_model-inl.h"
 
-#endif
\ No newline at end of file
+#endif
diff --git a/include/fcl/geometry/shape/box-inl.h b/include/fcl/geometry/shape/box-inl.h
index 053119a..0c72ad2 100644
--- a/include/fcl/geometry/shape/box-inl.h
+++ b/include/fcl/geometry/shape/box-inl.h
@@ -38,7 +38,11 @@
 #ifndef FCL_SHAPE_BOX_INL_H
 #define FCL_SHAPE_BOX_INL_H
 
+#include <iomanip>
+#include <sstream>
+
 #include "fcl/geometry/shape/box.h"
+#include "fcl/geometry/shape/representation.h"
 
 namespace fcl
 {
@@ -133,6 +137,25 @@ std::vector<Vector3<S>> Box<S>::getBoundVertices(
   return result;
 }
 
+//==============================================================================
+template <typename S>
+std::string Box<S>::representation(int precision) const {
+  const char* S_str = detail::ScalarRepr<S>::value();
+#if FCL_ENABLE_STD_LOGGING
+  std::stringstream ss;
+  ss << std::setprecision(precision);
+  ss << "Box<" << S_str << ">(" << side[0] << ", " << side[1] << ", " << side[2]
+     << ");";
+  return ss.str();
+#else
+  (void)precision;
+  std::string repr = "Box<";
+  repr += S_str;
+  repr += ">";
+  return repr;
+#endif
+}
+
 } // namespace fcl
 
 #endif
diff --git a/include/fcl/geometry/shape/box.h b/include/fcl/geometry/shape/box.h
index d15e9f2..a1716b0 100644
--- a/include/fcl/geometry/shape/box.h
+++ b/include/fcl/geometry/shape/box.h
@@ -40,7 +40,8 @@
 
 #include "fcl/geometry/shape/shape_base.h"
 
-#include <iostream>
+#include <ostream>
+#include <string>
 
 namespace fcl
 {
@@ -81,6 +82,13 @@ public:
   /// a specific configuration
   std::vector<Vector3<S>> getBoundVertices(const Transform3<S>& tf) const;
 
+  /// @brief Create a string that should be sufficient to recreate this shape.
+  /// This is akin to the repr() implementation in python.
+  /// @param precision The requested digits of precision for the numerical
+  ///                  measures (same semantics as std::setprecision()).
+  /// @return The string representation of this instance.
+  std::string representation(int precision = 20) const;
+
   friend
   std::ostream& operator<<(std::ostream& out, const Box& box) {
     out << "Box" << box.side.transpose();
diff --git a/include/fcl/geometry/shape/capsule-inl.h b/include/fcl/geometry/shape/capsule-inl.h
index b2add91..ca204c5 100644
--- a/include/fcl/geometry/shape/capsule-inl.h
+++ b/include/fcl/geometry/shape/capsule-inl.h
@@ -38,7 +38,11 @@
 #ifndef FCL_SHAPE_CAPSULE_INL_H
 #define FCL_SHAPE_CAPSULE_INL_H
 
+#include <iomanip>
+#include <sstream>
+
 #include "fcl/geometry/shape/capsule.h"
+#include "fcl/geometry/shape/representation.h"
 
 namespace fcl
 {
@@ -157,6 +161,24 @@ std::vector<Vector3<S>> Capsule<S>::getBoundVertices(
   return result;
 }
 
+//==============================================================================
+template <typename S>
+std::string Capsule<S>::representation(int precision) const {
+  const char* S_str = detail::ScalarRepr<S>::value();
+#if FCL_ENABLE_STD_LOGGING
+  std::stringstream ss;
+  ss << std::setprecision(precision);
+  ss << "Capsule<" << S_str << ">(" << radius << ", " << lz << ");";
+  return ss.str();
+#else
+  (void)precision;
+  std::string repr = "Capsule<";
+  repr += S_str;
+  repr += ">";
+  return repr;
+#endif
+}
+
 } // namespace fcl
 
 #endif
diff --git a/include/fcl/geometry/shape/capsule.h b/include/fcl/geometry/shape/capsule.h
index 5add95e..66e260b 100644
--- a/include/fcl/geometry/shape/capsule.h
+++ b/include/fcl/geometry/shape/capsule.h
@@ -38,7 +38,8 @@
 #ifndef FCL_SHAPE_CAPSULE_H
 #define FCL_SHAPE_CAPSULE_H
 
-#include <iostream>
+#include <ostream>
+#include <string>
 
 #include "fcl/geometry/shape/shape_base.h"
 
@@ -78,6 +79,13 @@ public:
   /// a specific configuration
   std::vector<Vector3<S>> getBoundVertices(const Transform3<S>& tf) const;
 
+  /// @brief Create a string that should be sufficient to recreate this shape.
+  /// This is akin to the repr() implementation in python.
+  /// @param precision The requested digits of precision for the numerical
+  ///                  measures (same semantics as std::setprecision()).
+  /// @return The string representation of this instance.
+  std::string representation(int precision = 20) const;
+
   friend
   std::ostream& operator<<(std::ostream& out, const Capsule& capsule) {
     out << "Capsule(r: " << capsule.radius << ", lz: " << capsule.lz << ")";
diff --git a/include/fcl/geometry/shape/cone-inl.h b/include/fcl/geometry/shape/cone-inl.h
index 3b023fc..33795c6 100644
--- a/include/fcl/geometry/shape/cone-inl.h
+++ b/include/fcl/geometry/shape/cone-inl.h
@@ -38,7 +38,11 @@
 #ifndef FCL_SHAPE_CONE_INL_H
 #define FCL_SHAPE_CONE_INL_H
 
+#include <iomanip>
+#include <sstream>
+
 #include "fcl/geometry/shape/cone.h"
+#include "fcl/geometry/shape/representation.h"
 
 namespace fcl
 {
@@ -123,6 +127,24 @@ std::vector<Vector3<S>> Cone<S>::getBoundVertices(
   return result;
 }
 
+//==============================================================================
+template <typename S>
+std::string Cone<S>::representation(int precision) const {
+  const char* S_str = detail::ScalarRepr<S>::value();
+#if FCL_ENABLE_STD_LOGGING
+  std::stringstream ss;
+  ss << std::setprecision(precision);
+  ss << "Cone<" << S_str << ">(" << radius << ", " << lz << ");";
+  return ss.str();
+#else
+  (void)precision;
+  std::string repr = "Cone<";
+  repr += S_str;
+  repr += ">";
+  return repr;
+#endif
+}
+
 } // namespace fcl
 
 #endif
diff --git a/include/fcl/geometry/shape/cone.h b/include/fcl/geometry/shape/cone.h
index ef9180c..2e8d7e3 100644
--- a/include/fcl/geometry/shape/cone.h
+++ b/include/fcl/geometry/shape/cone.h
@@ -38,7 +38,8 @@
 #ifndef FCL_SHAPE_CONE_H
 #define FCL_SHAPE_CONE_H
 
-#include <iostream>
+#include <ostream>
+#include <string>
 
 #include "fcl/geometry/shape/shape_base.h"
 
@@ -80,6 +81,13 @@ public:
   /// a specific configuration
   std::vector<Vector3<S>> getBoundVertices(const Transform3<S>& tf) const;
 
+  /// @brief Create a string that should be sufficient to recreate this shape.
+  /// This is akin to the repr() implementation in python.
+  /// @param precision The requested digits of precision for the numerical
+  ///                  measures (same semantics as std::setprecision()).
+  /// @return The string representation of this instance.
+  std::string representation(int precision = 20) const;
+
   friend
   std::ostream& operator<<(std::ostream& out, const Cone& cone) {
     out << "Cone(r: " << cone.radius << ", lz: " << cone.lz << ")";
diff --git a/include/fcl/geometry/shape/convex-inl.h b/include/fcl/geometry/shape/convex-inl.h
index 10adc69..857d7f3 100644
--- a/include/fcl/geometry/shape/convex-inl.h
+++ b/include/fcl/geometry/shape/convex-inl.h
@@ -39,11 +39,14 @@
 #ifndef FCL_SHAPE_CONVEX_INL_H
 #define FCL_SHAPE_CONVEX_INL_H
 
+#include <iomanip>
 #include <map>
 #include <set>
+#include <sstream>
 #include <utility>
 
 #include "fcl/geometry/shape/convex.h"
+#include "fcl/geometry/shape/representation.h"
 
 namespace fcl
 {
@@ -62,6 +65,7 @@ Convex<S>::Convex(
       vertices_(vertices),
       num_faces_(num_faces),
       faces_(faces),
+      throw_if_invalid_(throw_if_invalid),
       find_extreme_via_neighbors_{vertices->size() >
                                   kMinVertCountForEdgeWalking} {
   assert(vertices != nullptr);
@@ -309,6 +313,48 @@ const Vector3<S>& Convex<S>::findExtremeVertex(const Vector3<S>& v_C) const {
   return vertices[extreme_index];
 }
 
+//==============================================================================
+template <typename S>
+std::string Convex<S>::representation(int precision) const {
+  const char* S_str = detail::ScalarRepr<S>::value();
+#if FCL_ENABLE_STD_LOGGING
+  std::stringstream ss;
+  ss << std::setprecision(precision);
+  ss << "Convex<" << S_str << ">("
+     << "\n  std::make_shared<std::vector<Vector3<" << S_str << ">>>("
+     << "\n    std::initializer_list<Vector3<" << S_str << ">>{";
+  for (const Vector3<S>& p_GV : *vertices_) {
+    ss << "\n      Vector3<" << S_str << ">(" << p_GV[0] << ", " << p_GV[1]
+       << ", " << p_GV[2] << "),";
+  }
+  ss << "}),";
+  ss << "\n    " << num_faces_ << ",";
+  ss << "\n    std::make_shared<std::vector<int>>("
+     << "\n        std::initializer_list<int>{"
+     << "\n            ";
+  const std::vector<int>& faces = *faces_;
+  int face_index = 0;
+  for (int i = 0; i < num_faces_; ++i) {
+    const int vertex_count = faces[face_index];
+    ss << " " << vertex_count << ",";
+    for (int j = 1; j <= vertex_count; ++j) {
+      ss << " " << faces[face_index + j] << ",";
+    }
+    face_index += vertex_count + 1;
+  }
+  ss << "}),"
+     << "\n    " << std::boolalpha << throw_if_invalid_ << ");";
+
+  return ss.str();
+#else
+  (void)precision;
+  std::string repr = "Convex<";
+  repr += S_str;
+  repr += ">";
+  return repr;
+#endif
+}
+
 //==============================================================================
 template <typename S>
 void Convex<S>::ValidateMesh(bool throw_on_error) {
@@ -323,7 +369,7 @@ void Convex<S>::ValidateTopology(bool throw_on_error) {
   // Computing the vertex neighbors is a pre-requisite to determining validity.
   assert(neighbors_.size() > vertices_->size());
 
-  std::stringstream ss;
+  logging::StringBuilder ss;
   ss << "Found errors in the Convex mesh:";
 
   // To simplify the code, we define an edge as a pair of ints (A, B) such that
diff --git a/include/fcl/geometry/shape/convex.h b/include/fcl/geometry/shape/convex.h
index d817b4c..41f2cca 100644
--- a/include/fcl/geometry/shape/convex.h
+++ b/include/fcl/geometry/shape/convex.h
@@ -39,8 +39,9 @@
 #ifndef FCL_SHAPE_CONVEX_H
 #define FCL_SHAPE_CONVEX_H
 
-#include <iostream>
+#include <ostream>
 #include <memory>
+#include <string>
 #include <vector>
 
 #include "fcl/geometry/shape/shape_base.h"
@@ -175,6 +176,13 @@ public:
   ///         in the  %Convex polytope's set of vertices.
   const Vector3<S>& findExtremeVertex(const Vector3<S>& v_C) const;
 
+  /// @brief Create a string that should be sufficient to recreate this shape.
+  /// This is akin to the repr() implementation in python.
+  /// @param precision The requested digits of precision for the numerical
+  ///                  measures (same semantics as std::setprecision()).
+  /// @return The string representation of this instance.
+  std::string representation(int precision = 20) const;
+
   friend
   std::ostream& operator<<(std::ostream& out, const Convex& convex) {
     out << "Convex(v count: " << convex.vertices_->size() << ", f count: "
@@ -225,6 +233,8 @@ public:
   const std::shared_ptr<const std::vector<Vector3<S>>> vertices_;
   const int num_faces_;
   const std::shared_ptr<const std::vector<int>> faces_;
+  // This is stored to support representation().
+  const bool throw_if_invalid_{};
   Vector3<S> interior_point_;
 
   /* The encoding of vertex adjacency in the mesh. The encoding is as follows:
diff --git a/include/fcl/geometry/shape/cylinder-inl.h b/include/fcl/geometry/shape/cylinder-inl.h
index f5a6211..1e4b782 100644
--- a/include/fcl/geometry/shape/cylinder-inl.h
+++ b/include/fcl/geometry/shape/cylinder-inl.h
@@ -38,7 +38,11 @@
 #ifndef FCL_SHAPE_CYLINDER_INL_H
 #define FCL_SHAPE_CYLINDER_INL_H
 
+#include <iomanip>
+#include <sstream>
+
 #include "fcl/geometry/shape/cylinder.h"
+#include "fcl/geometry/shape/representation.h"
 
 namespace fcl
 {
@@ -121,6 +125,24 @@ std::vector<Vector3<S>> Cylinder<S>::getBoundVertices(
   return result;
 }
 
+//==============================================================================
+template <typename S>
+std::string Cylinder<S>::representation(int precision) const {
+  const char* S_str = detail::ScalarRepr<S>::value();
+#if FCL_ENABLE_STD_LOGGING
+  std::stringstream ss;
+  ss << std::setprecision(precision);
+  ss << "Cylinder<" << S_str << ">(" << radius << ", " << lz << ");";
+  return ss.str();
+#else
+  (void)precision;
+  std::string repr = "Cylinder<";
+  repr += S_str;
+  repr += ">";
+  return repr;
+#endif
+}
+
 } // namespace fcl
 
 #endif
diff --git a/include/fcl/geometry/shape/cylinder.h b/include/fcl/geometry/shape/cylinder.h
index bd67d31..43c103e 100644
--- a/include/fcl/geometry/shape/cylinder.h
+++ b/include/fcl/geometry/shape/cylinder.h
@@ -38,7 +38,8 @@
 #ifndef FCL_SHAPE_CYLINDER_H
 #define FCL_SHAPE_CYLINDER_H
 
-#include <iostream>
+#include <ostream>
+#include <string>
 
 #include "fcl/geometry/shape/shape_base.h"
 
@@ -78,6 +79,13 @@ public:
   /// a specific configuration
   std::vector<Vector3<S>> getBoundVertices(const Transform3<S>& tf) const;
 
+  /// @brief Create a string that should be sufficient to recreate this shape.
+  /// This is akin to the repr() implementation in python.
+  /// @param precision The requested digits of precision for the numerical
+  ///                  measures (same semantics as std::setprecision()).
+  /// @return The string representation of this instance.
+  std::string representation(int precision = 20) const;
+
   friend
   std::ostream& operator<<(std::ostream& out, const Cylinder& cylinder) {
     out << "Cylinder(r: " << cylinder.radius << ", lz: " << cylinder.lz << ")";
diff --git a/include/fcl/geometry/shape/ellipsoid-inl.h b/include/fcl/geometry/shape/ellipsoid-inl.h
index 5bbf946..115f631 100644
--- a/include/fcl/geometry/shape/ellipsoid-inl.h
+++ b/include/fcl/geometry/shape/ellipsoid-inl.h
@@ -38,7 +38,11 @@
 #ifndef FCL_SHAPE_ELLIPSOID_INL_H
 #define FCL_SHAPE_ELLIPSOID_INL_H
 
+#include <iomanip>
+#include <sstream>
+
 #include "fcl/geometry/shape/ellipsoid.h"
+#include "fcl/geometry/shape/representation.h"
 
 namespace fcl
 {
@@ -143,6 +147,25 @@ std::vector<Vector3<S>> Ellipsoid<S>::getBoundVertices(
   return result;
 }
 
+//==============================================================================
+template <typename S>
+std::string Ellipsoid<S>::representation(int precision) const {
+  const char* S_str = detail::ScalarRepr<S>::value();
+#if FCL_ENABLE_STD_LOGGING
+  std::stringstream ss;
+  ss << std::setprecision(precision);
+  ss << "Ellipsoid<" << S_str << ">(" << radii[0] << ", " << radii[1] << ", "
+     << radii[2] << ");";
+  return ss.str();
+#else
+  (void)precision;
+  std::string repr = "Ellipsoid<";
+  repr += S_str;
+  repr += ">";
+  return repr;
+#endif
+}
+
 } // namespace fcl
 
 #endif
diff --git a/include/fcl/geometry/shape/ellipsoid.h b/include/fcl/geometry/shape/ellipsoid.h
index 85632a9..0b638c8 100644
--- a/include/fcl/geometry/shape/ellipsoid.h
+++ b/include/fcl/geometry/shape/ellipsoid.h
@@ -38,7 +38,8 @@
 #ifndef FCL_SHAPE_ELLIPSOID_H
 #define FCL_SHAPE_ELLIPSOID_H
 
-#include <iostream>
+#include <ostream>
+#include <string>
 
 #include "fcl/geometry/shape/shape_base.h"
 
@@ -78,6 +79,13 @@ public:
   /// a specific configuration
   std::vector<Vector3<S>> getBoundVertices(const Transform3<S>& tf) const;
 
+  /// @brief Create a string that should be sufficient to recreate this shape.
+  /// This is akin to the repr() implementation in python.
+  /// @param precision The requested digits of precision for the numerical
+  ///                  measures (same semantics as std::setprecision()).
+  /// @return The string representation of this instance.
+  std::string representation(int precision = 20) const;
+
   friend
   std::ostream& operator<<(std::ostream& out, const Ellipsoid& ellipsoid) {
     out << "Ellipsoid(radii: " << ellipsoid.radii.transpose() << ")";
diff --git a/include/fcl/geometry/shape/halfspace-inl.h b/include/fcl/geometry/shape/halfspace-inl.h
index bc58f80..06d8eec 100644
--- a/include/fcl/geometry/shape/halfspace-inl.h
+++ b/include/fcl/geometry/shape/halfspace-inl.h
@@ -38,7 +38,11 @@
 #ifndef FCL_SHAPE_HALFSPACE_INL_H
 #define FCL_SHAPE_HALFSPACE_INL_H
 
+#include <iomanip>
+#include <sstream>
+
 #include "fcl/geometry/shape/halfspace.h"
+#include "fcl/geometry/shape/representation.h"
 
 namespace fcl
 {
@@ -130,6 +134,25 @@ NODE_TYPE Halfspace<S>::getNodeType() const
   return GEOM_HALFSPACE;
 }
 
+//==============================================================================
+template <typename S>
+std::string Halfspace<S>::representation(int precision) const {
+  const char* S_str = detail::ScalarRepr<S>::value();
+#if FCL_ENABLE_STD_LOGGING
+  std::stringstream ss;
+  ss << std::setprecision(precision);
+  ss << "Halfspace<" << S_str << ">(" << n[0] << ", " << n[1] << ", " << n[2]
+     << ", " << d << ");";
+  return ss.str();
+#else
+  (void)precision;
+  std::string repr = "Halfspace<";
+  repr += S_str;
+  repr += ">";
+  return repr;
+#endif
+}
+
 //==============================================================================
 template <typename S>
 void Halfspace<S>::unitNormalTest()
diff --git a/include/fcl/geometry/shape/halfspace.h b/include/fcl/geometry/shape/halfspace.h
index e679759..8fcf379 100644
--- a/include/fcl/geometry/shape/halfspace.h
+++ b/include/fcl/geometry/shape/halfspace.h
@@ -38,7 +38,8 @@
 #ifndef FCL_SHAPE_HALFSPACE_H
 #define FCL_SHAPE_HALFSPACE_H
 
-#include <iostream>
+#include <ostream>
+#include <string>
 
 #include "fcl/geometry/shape/shape_base.h"
 #include "fcl/math/bv/OBB.h"
@@ -86,6 +87,13 @@ public:
   /// @brief Planed offset
   S d;
 
+  /// @brief Create a string that should be sufficient to recreate this shape.
+  /// This is akin to the repr() implementation in python.
+  /// @param precision The requested digits of precision for the numerical
+  ///                  measures (same semantics as std::setprecision()).
+  /// @return The string representation of this instance.
+  std::string representation(int precision = 20) const;
+
   friend
   std::ostream& operator<<(std::ostream& out, const Halfspace& halfspace) {
     out << "Halfspace(n: " << halfspace.n.transpose() << ", d: "
diff --git a/include/fcl/geometry/shape/plane-inl.h b/include/fcl/geometry/shape/plane-inl.h
index 2e5da9c..179b182 100644
--- a/include/fcl/geometry/shape/plane-inl.h
+++ b/include/fcl/geometry/shape/plane-inl.h
@@ -38,7 +38,11 @@
 #ifndef FCL_SHAPE_PLANE_INL_H
 #define FCL_SHAPE_PLANE_INL_H
 
+#include <iomanip>
+#include <sstream>
+
 #include "fcl/geometry/shape/plane.h"
+#include "fcl/geometry/shape/representation.h"
 
 namespace fcl
 {
@@ -130,6 +134,25 @@ NODE_TYPE Plane<S>::getNodeType() const
   return GEOM_PLANE;
 }
 
+//==============================================================================
+template <typename S>
+std::string Plane<S>::representation(int precision) const {
+  const char* S_str = detail::ScalarRepr<S>::value();
+#if FCL_ENABLE_STD_LOGGING
+  std::stringstream ss;
+  ss << std::setprecision(precision);
+  ss << "Plane<" << S_str << ">(" << n[0] << ", " << n[1] << ", " << n[2]
+     << ", " << d << ");";
+  return ss.str();
+#else
+  (void)precision;
+  std::string repr = "Plane<";
+  repr += S_str;
+  repr += ">";
+  return repr;
+#endif
+}
+
 //==============================================================================
 template <typename S>
 void Plane<S>::unitNormalTest()
diff --git a/include/fcl/geometry/shape/plane.h b/include/fcl/geometry/shape/plane.h
index bcf3421..a94b46b 100644
--- a/include/fcl/geometry/shape/plane.h
+++ b/include/fcl/geometry/shape/plane.h
@@ -38,7 +38,8 @@
 #ifndef FCL_SHAPE_PLANE_H
 #define FCL_SHAPE_PLANE_H
 
-#include <iostream>
+#include <ostream>
+#include <string>
 
 #include "fcl/geometry/shape/shape_base.h"
 
@@ -77,6 +78,13 @@ public:
   /// @brief Plane offset 
   S d;
 
+  /// @brief Create a string that should be sufficient to recreate this shape.
+  /// This is akin to the repr() implementation in python.
+  /// @param precision The requested digits of precision for the numerical
+  ///                  measures (same semantics as std::setprecision()).
+  /// @return The string representation of this instance.
+  std::string representation(int precision = 20) const;
+
   friend
   std::ostream& operator<<(std::ostream& out, const Plane& plane) {
     out << "Plane(n: " << plane.n.transpose() << ", d: " << plane.d << ")";
diff --git a/include/fcl/geometry/shape/representation.h b/include/fcl/geometry/shape/representation.h
new file mode 100644
index 0000000..5b93547
--- /dev/null
+++ b/include/fcl/geometry/shape/representation.h
@@ -0,0 +1,61 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2023, Toyota Research Institute
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Sean Curtis */
+
+#ifndef FCL_SHAPE_REPRESENTATION_H
+#define FCL_SHAPE_REPRESENTATION_H
+
+namespace fcl {
+namespace detail {
+
+/* A type-traits-like struct for turning scalar types into shape representation
+ strings. By default, it is printed with the FCL-generic scalar template "S". */
+template <typename S>
+struct ScalarRepr {
+  static const char* value() { return "S"; };
+};
+
+template <> struct ScalarRepr<double> {
+  static const char* value() { return "double"; };
+};
+
+template <> struct ScalarRepr<float> {
+  static const char* value() { return "float"; };
+};
+
+}  // namespace detail
+}  // namespace fcl
+
+#endif  // FCL_SHAPE_REPRESENTATION_H
diff --git a/include/fcl/geometry/shape/sphere-inl.h b/include/fcl/geometry/shape/sphere-inl.h
index 0da7eea..1a8f21e 100644
--- a/include/fcl/geometry/shape/sphere-inl.h
+++ b/include/fcl/geometry/shape/sphere-inl.h
@@ -38,7 +38,11 @@
 #ifndef FCL_SHAPE_SPHERE_INL_H
 #define FCL_SHAPE_SPHERE_INL_H
 
+#include <iomanip>
+#include <sstream>
+
 #include "fcl/geometry/shape/sphere.h"
+#include "fcl/geometry/shape/representation.h"
 
 namespace fcl
 {
@@ -115,6 +119,24 @@ std::vector<Vector3<S>> Sphere<S>::getBoundVertices(
   return result;
 }
 
+//==============================================================================
+template <typename S>
+std::string Sphere<S>::representation(int precision) const {
+  const char* S_str = detail::ScalarRepr<S>::value();
+#if FCL_ENABLE_STD_LOGGING
+  std::stringstream ss;
+  ss << std::setprecision(precision);
+  ss << "Sphere<" << S_str << ">(" << radius << ");";
+  return ss.str();
+#else
+  (void)precision;
+  std::string repr = "Sphere<";
+  repr += S_str;
+  repr += ">";
+  return repr;
+#endif
+}
+
 } // namespace fcl
 
 #endif
diff --git a/include/fcl/geometry/shape/sphere.h b/include/fcl/geometry/shape/sphere.h
index 48b6792..7da4022 100644
--- a/include/fcl/geometry/shape/sphere.h
+++ b/include/fcl/geometry/shape/sphere.h
@@ -40,7 +40,8 @@
 
 #include "fcl/geometry/shape/shape_base.h"
 
-#include <iostream>
+#include <ostream>
+#include <string>
 
 namespace fcl
 {
@@ -72,6 +73,13 @@ public:
   /// a specific configuration
   std::vector<Vector3<S>> getBoundVertices(const Transform3<S>& tf) const;
 
+  /// @brief Create a string that should be sufficient to recreate this shape.
+  /// This is akin to the repr() implementation in python.
+  /// @param precision The requested digits of precision for the numerical
+  ///                  measures (same semantics as std::setprecision()).
+  /// @return The string representation of this instance.
+  std::string representation(int precision = 20) const;
+
   friend
   std::ostream& operator<<(std::ostream& out, const Sphere& sphere) {
     out << "Sphere(" << sphere.radius << ")";
diff --git a/include/fcl/logging.h b/include/fcl/logging.h
new file mode 100644
index 0000000..904694b
--- /dev/null
+++ b/include/fcl/logging.h
@@ -0,0 +1,102 @@
+#pragma once
+
+#include <ostream>
+#include <charconv>
+#include <system_error>
+#include <string>
+#include <type_traits>
+
+#ifndef FCL_ENABLE_STD_LOGGING
+#define FCL_ENABLE_STD_LOGGING 1
+#endif
+
+namespace fcl {
+namespace logging {
+
+#if FCL_ENABLE_STD_LOGGING
+
+inline std::ostream& GetCerr() noexcept {
+    return std::cerr;
+}
+
+#else
+
+class NullStream {
+public:
+    template <typename T>
+    NullStream& operator<<(const T&) noexcept {
+        return *this;
+    }
+
+    NullStream& operator<<(std::ostream& (*)(std::ostream&)) noexcept {
+        return *this;
+    }
+
+    NullStream& operator<<(std::ios_base& (*)(std::ios_base&)) noexcept {
+        return *this;
+    }
+};
+
+inline NullStream& GetCerr() noexcept {
+    static NullStream stream;
+    return stream;
+}
+
+#endif
+
+class StringBuilder {
+public:
+    StringBuilder& operator<<(const char* text) {
+        if (text != nullptr) {
+            buffer_.append(text);
+        }
+        return *this;
+    }
+
+    StringBuilder& operator<<(char value) {
+        buffer_.push_back(value);
+        return *this;
+    }
+
+    StringBuilder& operator<<(const std::string& text) {
+        buffer_.append(text);
+        return *this;
+    }
+
+    StringBuilder& operator<<(bool value) {
+        buffer_.append(value ? "true" : "false");
+        return *this;
+    }
+
+    template <typename T, std::enable_if_t<std::is_integral_v<T>, int> = 0>
+    StringBuilder& operator<<(T value) {
+        char buffer[32];
+        auto [ptr, ec] = std::to_chars(buffer, buffer + sizeof(buffer), value);
+        if (ec == std::errc()) {
+            buffer_.append(buffer, ptr);
+        }
+        return *this;
+    }
+
+    template <typename T, std::enable_if_t<std::is_floating_point_v<T>, int> = 0>
+    StringBuilder& operator<<(T value) {
+        char buffer[64];
+        auto [ptr, ec] = std::to_chars(buffer, buffer + sizeof(buffer), value, std::chars_format::general);
+        if (ec == std::errc()) {
+            buffer_.append(buffer, ptr);
+        }
+        return *this;
+    }
+
+    std::string str() const {
+        return buffer_;
+    }
+
+private:
+    std::string buffer_;
+};
+
+}  // namespace logging
+}  // namespace fcl
+
+#define FCL_CERR (::fcl::logging::GetCerr())
diff --git a/include/fcl/math/bv/OBB-inl.h b/include/fcl/math/bv/OBB-inl.h
index 4d5455f..091ee94 100644
--- a/include/fcl/math/bv/OBB-inl.h
+++ b/include/fcl/math/bv/OBB-inl.h
@@ -224,7 +224,7 @@ S OBB<S>::distance(const OBB& other, Vector3<S>* P,
   FCL_UNUSED(P);
   FCL_UNUSED(Q);
 
-  std::cerr << "OBB distance not implemented!\n";
+  FCL_CERR << "OBB distance not implemented!\n";
   return 0.0;
 }
 
diff --git a/include/fcl/math/bv/kDOP-inl.h b/include/fcl/math/bv/kDOP-inl.h
index f660266..2732134 100644
--- a/include/fcl/math/bv/kDOP-inl.h
+++ b/include/fcl/math/bv/kDOP-inl.h
@@ -264,7 +264,7 @@ S KDOP<S, N>::distance(const KDOP<S, N>& other, Vector3<S>* P, Vector3<S>* Q) co
   FCL_UNUSED(P);
   FCL_UNUSED(Q);
 
-  std::cerr << "KDOP distance not implemented!\n";
+  FCL_CERR << "KDOP distance not implemented!\n";
   return 0.0;
 }
 
diff --git a/include/fcl/math/detail/polysolver-inl.h b/include/fcl/math/detail/polysolver-inl.h
index c2c538c..dccc6a9 100644
--- a/include/fcl/math/detail/polysolver-inl.h
+++ b/include/fcl/math/detail/polysolver-inl.h
@@ -1,201 +1,201 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#ifndef FCL_NARROWPHASE_DETAIL_POLYSOLVER_INL_H
-#define FCL_NARROWPHASE_DETAIL_POLYSOLVER_INL_H
-
-#include "fcl/math/detail/polysolver.h"
-
-#include <cmath>
-#include "fcl/common/types.h"
-
-namespace fcl
-{
-
-namespace detail {
-
-//==============================================================================
-extern template
-class FCL_EXPORT PolySolver<double>;
-
-//==============================================================================
-template <typename S>
-int PolySolver<S>::solveLinear(S c[2], S s[1])
-{
-  if(isZero(c[1]))
-    return 0;
-  s[0] = - c[0] / c[1];
-  return 1;
-}
-
-//==============================================================================
-template <typename S>
-int PolySolver<S>::solveQuadric(S c[3], S s[2])
-{
-  S p, q, D;
-
-  // make sure we have a d2 equation
-
-  if(isZero(c[2]))
-    return solveLinear(c, s);
-
-  // normal for: x^2 + px + q
-  p = c[1] / (2.0 * c[2]);
-  q = c[0] / c[2];
-  D = p * p - q;
-
-  if(isZero(D))
-  {
-    // one S root
-    s[0] = s[1] = -p;
-    return 1;
-  }
-
-  if(D < 0.0)
-    // no real root
-    return 0;
-  else
-  {
-    // two real roots
-    S sqrt_D = sqrt(D);
-    s[0] = sqrt_D - p;
-    s[1] = -sqrt_D - p;
-    return 2;
-  }
-}
-
-//==============================================================================
-template <typename S>
-int PolySolver<S>::solveCubic(S c[4], S s[3])
-{
-  int i, num;
-  S sub, A, B, C, sq_A, p, q, cb_p, D;
-  const S ONE_OVER_THREE = 1 / 3.0;
-  const S PI = 3.14159265358979323846;
-
-  // make sure we have a d2 equation
-  if(isZero(c[3]))
-    return solveQuadric(c, s);
-
-  // normalize the equation:x ^ 3 + Ax ^ 2 + Bx  + C = 0
-  A = c[2] / c[3];
-  B = c[1] / c[3];
-  C = c[0] / c[3];
-
-  // substitute x = y - A / 3 to eliminate the quadratic term: x^3 + px + q = 0
-  sq_A = A * A;
-  p = (-ONE_OVER_THREE * sq_A + B) * ONE_OVER_THREE;
-  q = 0.5 * (2.0 / 27.0 * A * sq_A - ONE_OVER_THREE * A * B + C);
-
-  // use Cardano's formula
-  cb_p = p * p * p;
-  D = q * q + cb_p;
-
-  if(isZero(D))
-  {
-    if(isZero(q))
-    {
-      // one triple solution
-      s[0] = 0.0;
-      num = 1;
-    }
-    else
-    {
-      // one single and one S solution
-      S u = cbrt(-q);
-      s[0] = 2.0 * u;
-      s[1] = -u;
-      num = 2;
-    }
-  }
-  else
-  {
-    if(D < 0.0)
-    {
-      // three real solutions
-      S phi = ONE_OVER_THREE * acos(-q / sqrt(-cb_p));
-      S t = 2.0 * sqrt(-p);
-      s[0] = t * cos(phi);
-      s[1] = -t * cos(phi + PI / 3.0);
-      s[2] = -t * cos(phi - PI / 3.0);
-      num = 3;
-    }
-    else
-    {
-      // one real solution
-      S sqrt_D = sqrt(D);
-      S u = cbrt(sqrt_D + fabs(q));
-      if(q > 0.0)
-        s[0] = - u + p / u ;
-      else
-        s[0] = u - p / u;
-      num = 1;
-    }
-  }
-
-  // re-substitute
-  sub = ONE_OVER_THREE * A;
-  for(i = 0; i < num; i++)
-    s[i] -= sub;
-  return num;
-}
-
-//==============================================================================
-template <typename S>
-bool PolySolver<S>::isZero(S v)
-{
-  return (v < getNearZeroThreshold()) && (v > -getNearZeroThreshold());
-}
-
-//==============================================================================
-template <typename S>
-bool PolySolver<S>::cbrt(S v)
-{
-  return std::pow(v, 1.0 / 3.0);
-}
-
-//==============================================================================
-template <typename S>
-constexpr S PolySolver<S>::getNearZeroThreshold()
-{
-  return 1e-9;
-}
-
-} // namespace detail
-} // namespace fcl
-
-#endif
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#ifndef FCL_NARROWPHASE_DETAIL_POLYSOLVER_INL_H
+#define FCL_NARROWPHASE_DETAIL_POLYSOLVER_INL_H
+
+#include "fcl/math/detail/polysolver.h"
+
+#include <cmath>
+#include "fcl/common/types.h"
+
+namespace fcl
+{
+
+namespace detail {
+
+//==============================================================================
+extern template
+class FCL_EXPORT PolySolver<double>;
+
+//==============================================================================
+template <typename S>
+int PolySolver<S>::solveLinear(S c[2], S s[1])
+{
+  if(isZero(c[1]))
+    return 0;
+  s[0] = - c[0] / c[1];
+  return 1;
+}
+
+//==============================================================================
+template <typename S>
+int PolySolver<S>::solveQuadric(S c[3], S s[2])
+{
+  S p, q, D;
+
+  // make sure we have a d2 equation
+
+  if(isZero(c[2]))
+    return solveLinear(c, s);
+
+  // normal for: x^2 + px + q
+  p = c[1] / (2.0 * c[2]);
+  q = c[0] / c[2];
+  D = p * p - q;
+
+  if(isZero(D))
+  {
+    // one S root
+    s[0] = s[1] = -p;
+    return 1;
+  }
+
+  if(D < 0.0)
+    // no real root
+    return 0;
+  else
+  {
+    // two real roots
+    S sqrt_D = sqrt(D);
+    s[0] = sqrt_D - p;
+    s[1] = -sqrt_D - p;
+    return 2;
+  }
+}
+
+//==============================================================================
+template <typename S>
+int PolySolver<S>::solveCubic(S c[4], S s[3])
+{
+  int i, num;
+  S sub, A, B, C, sq_A, p, q, cb_p, D;
+  const S ONE_OVER_THREE = 1 / 3.0;
+  const S PI = 3.14159265358979323846;
+
+  // make sure we have a d2 equation
+  if(isZero(c[3]))
+    return solveQuadric(c, s);
+
+  // normalize the equation:x ^ 3 + Ax ^ 2 + Bx  + C = 0
+  A = c[2] / c[3];
+  B = c[1] / c[3];
+  C = c[0] / c[3];
+
+  // substitute x = y - A / 3 to eliminate the quadratic term: x^3 + px + q = 0
+  sq_A = A * A;
+  p = (-ONE_OVER_THREE * sq_A + B) * ONE_OVER_THREE;
+  q = 0.5 * (2.0 / 27.0 * A * sq_A - ONE_OVER_THREE * A * B + C);
+
+  // use Cardano's formula
+  cb_p = p * p * p;
+  D = q * q + cb_p;
+
+  if(isZero(D))
+  {
+    if(isZero(q))
+    {
+      // one triple solution
+      s[0] = 0.0;
+      num = 1;
+    }
+    else
+    {
+      // one single and one S solution
+      S u = cbrt(-q);
+      s[0] = 2.0 * u;
+      s[1] = -u;
+      num = 2;
+    }
+  }
+  else
+  {
+    if(D < 0.0)
+    {
+      // three real solutions
+      S phi = ONE_OVER_THREE * acos(-q / sqrt(-cb_p));
+      S t = 2.0 * sqrt(-p);
+      s[0] = t * cos(phi);
+      s[1] = -t * cos(phi + PI / 3.0);
+      s[2] = -t * cos(phi - PI / 3.0);
+      num = 3;
+    }
+    else
+    {
+      // one real solution
+      S sqrt_D = sqrt(D);
+      S u = cbrt(sqrt_D + fabs(q));
+      if(q > 0.0)
+        s[0] = - u + p / u ;
+      else
+        s[0] = u - p / u;
+      num = 1;
+    }
+  }
+
+  // re-substitute
+  sub = ONE_OVER_THREE * A;
+  for(i = 0; i < num; i++)
+    s[i] -= sub;
+  return num;
+}
+
+//==============================================================================
+template <typename S>
+bool PolySolver<S>::isZero(S v)
+{
+  return (v < getNearZeroThreshold()) && (v > -getNearZeroThreshold());
+}
+
+//==============================================================================
+template <typename S>
+bool PolySolver<S>::cbrt(S v)
+{
+  return std::pow(v, 1.0 / 3.0);
+}
+
+//==============================================================================
+template <typename S>
+constexpr S PolySolver<S>::getNearZeroThreshold()
+{
+  return 1e-9;
+}
+
+} // namespace detail
+} // namespace fcl
+
+#endif
diff --git a/include/fcl/math/detail/polysolver.h b/include/fcl/math/detail/polysolver.h
index 52808a9..a43fe75 100644
--- a/include/fcl/math/detail/polysolver.h
+++ b/include/fcl/math/detail/polysolver.h
@@ -1,80 +1,80 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#ifndef FCL_NARROWPHASE_DETAIL_POLYSOLVER_H
-#define FCL_NARROWPHASE_DETAIL_POLYSOLVER_H
-
-#include "fcl/export.h"
-
-namespace fcl
-{
-
-namespace detail {
-
-/// @brief A class solves polynomial degree (1,2,3) equations 
-template <typename S>
-class FCL_EXPORT PolySolver
-{
-public:
-  /// @brief Solve a linear equation with coefficients c, return roots s and number of roots 
-  static int solveLinear(S c[2], S s[1]);
-
-  /// @brief Solve a quadratic function with coefficients c, return roots s and number of roots 
-  static int solveQuadric(S c[3], S s[2]);
-
-  /// @brief Solve a cubic function with coefficients c, return roots s and number of roots 
-  static int solveCubic(S c[4], S s[3]);
-
-private:
-  /// @brief Check whether v is zero 
-  static bool isZero(S v);
-
-  /// @brief Compute v^{1/3} 
-  static bool cbrt(S v);
-
-  static constexpr S getNearZeroThreshold();
-};
-
-using PolySolverf = PolySolver<float>;
-using PolySolverd = PolySolver<double>;
-
-} // namespace detail
-} // namespace fcl
-
-#include "fcl/math/detail/polysolver-inl.h"
-
-#endif
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#ifndef FCL_NARROWPHASE_DETAIL_POLYSOLVER_H
+#define FCL_NARROWPHASE_DETAIL_POLYSOLVER_H
+
+#include "fcl/export.h"
+
+namespace fcl
+{
+
+namespace detail {
+
+/// @brief A class solves polynomial degree (1,2,3) equations 
+template <typename S>
+class FCL_EXPORT PolySolver
+{
+public:
+  /// @brief Solve a linear equation with coefficients c, return roots s and number of roots 
+  static int solveLinear(S c[2], S s[1]);
+
+  /// @brief Solve a quadratic function with coefficients c, return roots s and number of roots 
+  static int solveQuadric(S c[3], S s[2]);
+
+  /// @brief Solve a cubic function with coefficients c, return roots s and number of roots 
+  static int solveCubic(S c[4], S s[3]);
+
+private:
+  /// @brief Check whether v is zero 
+  static bool isZero(S v);
+
+  /// @brief Compute v^{1/3} 
+  static bool cbrt(S v);
+
+  static constexpr S getNearZeroThreshold();
+};
+
+using PolySolverf = PolySolver<float>;
+using PolySolverd = PolySolver<double>;
+
+} // namespace detail
+} // namespace fcl
+
+#include "fcl/math/detail/polysolver-inl.h"
+
+#endif
diff --git a/include/fcl/math/detail/project-inl.h b/include/fcl/math/detail/project-inl.h
index abe4df6..64923fd 100644
--- a/include/fcl/math/detail/project-inl.h
+++ b/include/fcl/math/detail/project-inl.h
@@ -1,320 +1,320 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#ifndef FCL_NARROWPHASE_DETAIL_PROJECT_INL_H
-#define FCL_NARROWPHASE_DETAIL_PROJECT_INL_H
-
-#include "fcl/math/detail/project.h"
-
-namespace fcl
-{
-
-namespace detail
-{
-
-//==============================================================================
-extern template
-class FCL_EXPORT Project<double>;
-
-//==============================================================================
-template <typename S>
-typename Project<S>::ProjectResult Project<S>::projectLine(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& p)
-{
-  ProjectResult res;
-
-  const Vector3<S> d = b - a;
-  const S l = d.squaredNorm();
-
-  if(l > 0)
-  {
-    const S t = (p - a).dot(d);
-    res.parameterization[1] = (t >= l) ? 1 : ((t <= 0) ? 0 : (t / l));
-    res.parameterization[0] = 1 - res.parameterization[1];
-    if(t >= l) { res.sqr_distance = (p - b).squaredNorm(); res.encode = 2; /* 0x10 */ }
-    else if(t <= 0) { res.sqr_distance = (p - a).squaredNorm(); res.encode = 1; /* 0x01 */ }
-    else { res.sqr_distance = (a + d * res.parameterization[1] - p).squaredNorm(); res.encode = 3; /* 0x00 */ }
-  }
-
-  return res;
-}
-
-//==============================================================================
-template <typename S>
-typename Project<S>::ProjectResult Project<S>::projectTriangle(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& p)
-{
-  ProjectResult res;
-
-  static const size_t nexti[3] = {1, 2, 0};
-  const Vector3<S>* vt[] = {&a, &b, &c};
-  const Vector3<S> dl[] = {a - b, b - c, c - a};
-  const Vector3<S>& n = dl[0].cross(dl[1]);
-  const S l = n.squaredNorm();
-
-  if(l > 0)
-  {
-    S mindist = -1;
-    for(size_t i = 0; i < 3; ++i)
-    {
-      if((*vt[i] - p).dot(dl[i].cross(n)) > 0) // origin is to the outside part of the triangle edge, then the optimal can only be on the edge
-      {
-        size_t j = nexti[i];
-        ProjectResult res_line = projectLine(*vt[i], *vt[j], p);
-
-        if(mindist < 0 || res_line.sqr_distance < mindist)
-        {
-          mindist = res_line.sqr_distance;
-          res.encode = static_cast<size_t>(((res_line.encode&1)?1<<i:0) + ((res_line.encode&2)?1<<j:0));
-          res.parameterization[i] = res_line.parameterization[0];
-          res.parameterization[j] = res_line.parameterization[1];
-          res.parameterization[nexti[j]] = 0;
-        }
-      }
-    }
-
-    if(mindist < 0) // the origin project is within the triangle
-    {
-      S d = (a - p).dot(n);
-      S s = sqrt(l);
-      Vector3<S> p_to_project = n * (d / l);
-      mindist = p_to_project.squaredNorm();
-      res.encode = 7; // m = 0x111
-      res.parameterization[0] = dl[1].cross(b - p -p_to_project).norm() / s;
-      res.parameterization[1] = dl[2].cross(c - p -p_to_project).norm() / s;
-      res.parameterization[2] = 1 - res.parameterization[0] - res.parameterization[1];
-    }
-
-    res.sqr_distance = mindist;
-  }
-
-  return  res;
-
-}
-
-//==============================================================================
-template <typename S>
-typename Project<S>::ProjectResult Project<S>::projectTetrahedra(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& d, const Vector3<S>& p)
-{
-  ProjectResult res;
-
-  static const size_t nexti[] = {1, 2, 0};
-  const Vector3<S>* vt[] = {&a, &b, &c, &d};
-  const Vector3<S> dl[3] = {a-d, b-d, c-d};
-  S vl = triple(dl[0], dl[1], dl[2]);
-  bool ng = (vl * (a-p).dot((b-c).cross(a-b))) <= 0;
-  if(ng && std::abs(vl) > 0) // abs(vl) == 0, the tetrahedron is degenerated; if ng is false, then the last vertex in the tetrahedron does not grow toward the origin (in fact origin is on the other side of the abc face)
-  {
-    S mindist = -1;
-
-    for(size_t i = 0; i < 3; ++i)
-    {
-      size_t j = nexti[i];
-      S s = vl * (d-p).dot(dl[i].cross(dl[j]));
-      if(s > 0) // the origin is to the outside part of a triangle face, then the optimal can only be on the triangle face
-      {
-        ProjectResult res_triangle = projectTriangle(*vt[i], *vt[j], d, p);
-        if(mindist < 0 || res_triangle.sqr_distance < mindist)
-        {
-          mindist = res_triangle.sqr_distance;
-          res.encode = static_cast<size_t>( (res_triangle.encode&1?1<<i:0) + (res_triangle.encode&2?1<<j:0) + (res_triangle.encode&4?8:0) );
-          res.parameterization[i] = res_triangle.parameterization[0];
-          res.parameterization[j] = res_triangle.parameterization[1];
-          res.parameterization[nexti[j]] = 0;
-          res.parameterization[3] = res_triangle.parameterization[2];
-        }
-      }
-    }
-
-    if(mindist < 0)
-    {
-      mindist = 0;
-      res.encode = 15;
-      res.parameterization[0] = triple(c - p, b - p, d - p) / vl;
-      res.parameterization[1] = triple(a - p, c - p, d - p) / vl;
-      res.parameterization[2] = triple(b - p, a - p, d - p) / vl;
-      res.parameterization[3] = 1 - (res.parameterization[0] + res.parameterization[1] + res.parameterization[2]);
-    }
-
-    res.sqr_distance = mindist;
-  }
-  else if(!ng)
-  {
-    res = projectTriangle(a, b, c, p);
-    res.parameterization[3] = 0;
-  }
-  return res;
-}
-
-//==============================================================================
-template <typename S>
-typename Project<S>::ProjectResult Project<S>::projectLineOrigin(const Vector3<S>& a, const Vector3<S>& b)
-{
-  ProjectResult res;
-
-  const Vector3<S> d = b - a;
-  const S l = d.squaredNorm();
-
-  if(l > 0)
-  {
-    const S t = - a.dot(d);
-    res.parameterization[1] = (t >= l) ? 1 : ((t <= 0) ? 0 : (t / l));
-    res.parameterization[0] = 1 - res.parameterization[1];
-    if(t >= l) { res.sqr_distance = b.squaredNorm(); res.encode = 2; /* 0x10 */ }
-    else if(t <= 0) { res.sqr_distance = a.squaredNorm(); res.encode = 1; /* 0x01 */ }
-    else { res.sqr_distance = (a + d * res.parameterization[1]).squaredNorm(); res.encode = 3; /* 0x00 */ }
-  }
-
-  return res;
-}
-
-//==============================================================================
-template <typename S>
-typename Project<S>::ProjectResult Project<S>::projectTriangleOrigin(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c)
-{
-  ProjectResult res;
-
-  static const size_t nexti[3] = {1, 2, 0};
-  const Vector3<S>* vt[] = {&a, &b, &c};
-  const Vector3<S> dl[] = {a - b, b - c, c - a};
-  const Vector3<S>& n = dl[0].cross(dl[1]);
-  const S l = n.squaredNorm();
-
-  if(l > 0)
-  {
-    S mindist = -1;
-    for(size_t i = 0; i < 3; ++i)
-    {
-      if(vt[i]->dot(dl[i].cross(n)) > 0) // origin is to the outside part of the triangle edge, then the optimal can only be on the edge
-      {
-        size_t j = nexti[i];
-        ProjectResult res_line = projectLineOrigin(*vt[i], *vt[j]);
-
-        if(mindist < 0 || res_line.sqr_distance < mindist)
-        {
-          mindist = res_line.sqr_distance;
-          res.encode = static_cast<size_t>(((res_line.encode&1)?1<<i:0) + ((res_line.encode&2)?1<<j:0));
-          res.parameterization[i] = res_line.parameterization[0];
-          res.parameterization[j] = res_line.parameterization[1];
-          res.parameterization[nexti[j]] = 0;
-        }
-      }
-    }
-
-    if(mindist < 0) // the origin project is within the triangle
-    {
-      S d = a.dot(n);
-      S s = sqrt(l);
-      Vector3<S> o_to_project = n * (d / l);
-      mindist = o_to_project.squaredNorm();
-      res.encode = 7; // m = 0x111
-      res.parameterization[0] = dl[1].cross(b - o_to_project).norm() / s;
-      res.parameterization[1] = dl[2].cross(c - o_to_project).norm() / s;
-      res.parameterization[2] = 1 - res.parameterization[0] - res.parameterization[1];
-    }
-
-    res.sqr_distance = mindist;
-  }
-
-  return  res;
-
-}
-
-//==============================================================================
-template <typename S>
-typename Project<S>::ProjectResult Project<S>::projectTetrahedraOrigin(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& d)
-{
-  ProjectResult res;
-
-  static const size_t nexti[] = {1, 2, 0};
-  const Vector3<S>* vt[] = {&a, &b, &c, &d};
-  const Vector3<S> dl[3] = {a-d, b-d, c-d};
-  S vl = triple(dl[0], dl[1], dl[2]);
-  bool ng = (vl * a.dot((b-c).cross(a-b))) <= 0;
-  if(ng && std::abs(vl) > 0) // abs(vl) == 0, the tetrahedron is degenerated; if ng is false, then the last vertex in the tetrahedron does not grow toward the origin (in fact origin is on the other side of the abc face)
-  {
-    S mindist = -1;
-
-    for(size_t i = 0; i < 3; ++i)
-    {
-      size_t j = nexti[i];
-      S s = vl * d.dot(dl[i].cross(dl[j]));
-      if(s > 0) // the origin is to the outside part of a triangle face, then the optimal can only be on the triangle face
-      {
-        ProjectResult res_triangle = projectTriangleOrigin(*vt[i], *vt[j], d);
-        if(mindist < 0 || res_triangle.sqr_distance < mindist)
-        {
-          mindist = res_triangle.sqr_distance;
-          res.encode = static_cast<size_t>( (res_triangle.encode&1?1<<i:0) + (res_triangle.encode&2?1<<j:0) + (res_triangle.encode&4?8:0) );
-          res.parameterization[i] = res_triangle.parameterization[0];
-          res.parameterization[j] = res_triangle.parameterization[1];
-          res.parameterization[nexti[j]] = 0;
-          res.parameterization[3] = res_triangle.parameterization[2];
-        }
-      }
-    }
-
-    if(mindist < 0)
-    {
-      mindist = 0;
-      res.encode = 15;
-      res.parameterization[0] = triple(c, b, d) / vl;
-      res.parameterization[1] = triple(a, c, d) / vl;
-      res.parameterization[2] = triple(b, a, d) / vl;
-      res.parameterization[3] = 1 - (res.parameterization[0] + res.parameterization[1] + res.parameterization[2]);
-    }
-
-    res.sqr_distance = mindist;
-  }
-  else if(!ng)
-  {
-    res = projectTriangleOrigin(a, b, c);
-    res.parameterization[3] = 0;
-  }
-  return res;
-}
-
-//==============================================================================
-template <typename S>
-Project<S>::ProjectResult::ProjectResult()
-  : parameterization{0.0, 0.0, 0.0, 0.0}, sqr_distance(-1), encode(0)
-{
-  // Do nothing
-}
-
-} // namespace detail
-} // namespace fcl
-
-#endif
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#ifndef FCL_NARROWPHASE_DETAIL_PROJECT_INL_H
+#define FCL_NARROWPHASE_DETAIL_PROJECT_INL_H
+
+#include "fcl/math/detail/project.h"
+
+namespace fcl
+{
+
+namespace detail
+{
+
+//==============================================================================
+extern template
+class FCL_EXPORT Project<double>;
+
+//==============================================================================
+template <typename S>
+typename Project<S>::ProjectResult Project<S>::projectLine(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& p)
+{
+  ProjectResult res;
+
+  const Vector3<S> d = b - a;
+  const S l = d.squaredNorm();
+
+  if(l > 0)
+  {
+    const S t = (p - a).dot(d);
+    res.parameterization[1] = (t >= l) ? 1 : ((t <= 0) ? 0 : (t / l));
+    res.parameterization[0] = 1 - res.parameterization[1];
+    if(t >= l) { res.sqr_distance = (p - b).squaredNorm(); res.encode = 2; /* 0x10 */ }
+    else if(t <= 0) { res.sqr_distance = (p - a).squaredNorm(); res.encode = 1; /* 0x01 */ }
+    else { res.sqr_distance = (a + d * res.parameterization[1] - p).squaredNorm(); res.encode = 3; /* 0x00 */ }
+  }
+
+  return res;
+}
+
+//==============================================================================
+template <typename S>
+typename Project<S>::ProjectResult Project<S>::projectTriangle(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& p)
+{
+  ProjectResult res;
+
+  static const size_t nexti[3] = {1, 2, 0};
+  const Vector3<S>* vt[] = {&a, &b, &c};
+  const Vector3<S> dl[] = {a - b, b - c, c - a};
+  const Vector3<S>& n = dl[0].cross(dl[1]);
+  const S l = n.squaredNorm();
+
+  if(l > 0)
+  {
+    S mindist = -1;
+    for(size_t i = 0; i < 3; ++i)
+    {
+      if((*vt[i] - p).dot(dl[i].cross(n)) > 0) // origin is to the outside part of the triangle edge, then the optimal can only be on the edge
+      {
+        size_t j = nexti[i];
+        ProjectResult res_line = projectLine(*vt[i], *vt[j], p);
+
+        if(mindist < 0 || res_line.sqr_distance < mindist)
+        {
+          mindist = res_line.sqr_distance;
+          res.encode = static_cast<size_t>(((res_line.encode&1)?1<<i:0) + ((res_line.encode&2)?1<<j:0));
+          res.parameterization[i] = res_line.parameterization[0];
+          res.parameterization[j] = res_line.parameterization[1];
+          res.parameterization[nexti[j]] = 0;
+        }
+      }
+    }
+
+    if(mindist < 0) // the origin project is within the triangle
+    {
+      S d = (a - p).dot(n);
+      S s = sqrt(l);
+      Vector3<S> p_to_project = n * (d / l);
+      mindist = p_to_project.squaredNorm();
+      res.encode = 7; // m = 0x111
+      res.parameterization[0] = dl[1].cross(b - p -p_to_project).norm() / s;
+      res.parameterization[1] = dl[2].cross(c - p -p_to_project).norm() / s;
+      res.parameterization[2] = 1 - res.parameterization[0] - res.parameterization[1];
+    }
+
+    res.sqr_distance = mindist;
+  }
+
+  return  res;
+
+}
+
+//==============================================================================
+template <typename S>
+typename Project<S>::ProjectResult Project<S>::projectTetrahedra(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& d, const Vector3<S>& p)
+{
+  ProjectResult res;
+
+  static const size_t nexti[] = {1, 2, 0};
+  const Vector3<S>* vt[] = {&a, &b, &c, &d};
+  const Vector3<S> dl[3] = {a-d, b-d, c-d};
+  S vl = triple(dl[0], dl[1], dl[2]);
+  bool ng = (vl * (a-p).dot((b-c).cross(a-b))) <= 0;
+  if(ng && std::abs(vl) > 0) // abs(vl) == 0, the tetrahedron is degenerated; if ng is false, then the last vertex in the tetrahedron does not grow toward the origin (in fact origin is on the other side of the abc face)
+  {
+    S mindist = -1;
+
+    for(size_t i = 0; i < 3; ++i)
+    {
+      size_t j = nexti[i];
+      S s = vl * (d-p).dot(dl[i].cross(dl[j]));
+      if(s > 0) // the origin is to the outside part of a triangle face, then the optimal can only be on the triangle face
+      {
+        ProjectResult res_triangle = projectTriangle(*vt[i], *vt[j], d, p);
+        if(mindist < 0 || res_triangle.sqr_distance < mindist)
+        {
+          mindist = res_triangle.sqr_distance;
+          res.encode = static_cast<size_t>( (res_triangle.encode&1?1<<i:0) + (res_triangle.encode&2?1<<j:0) + (res_triangle.encode&4?8:0) );
+          res.parameterization[i] = res_triangle.parameterization[0];
+          res.parameterization[j] = res_triangle.parameterization[1];
+          res.parameterization[nexti[j]] = 0;
+          res.parameterization[3] = res_triangle.parameterization[2];
+        }
+      }
+    }
+
+    if(mindist < 0)
+    {
+      mindist = 0;
+      res.encode = 15;
+      res.parameterization[0] = triple(c - p, b - p, d - p) / vl;
+      res.parameterization[1] = triple(a - p, c - p, d - p) / vl;
+      res.parameterization[2] = triple(b - p, a - p, d - p) / vl;
+      res.parameterization[3] = 1 - (res.parameterization[0] + res.parameterization[1] + res.parameterization[2]);
+    }
+
+    res.sqr_distance = mindist;
+  }
+  else if(!ng)
+  {
+    res = projectTriangle(a, b, c, p);
+    res.parameterization[3] = 0;
+  }
+  return res;
+}
+
+//==============================================================================
+template <typename S>
+typename Project<S>::ProjectResult Project<S>::projectLineOrigin(const Vector3<S>& a, const Vector3<S>& b)
+{
+  ProjectResult res;
+
+  const Vector3<S> d = b - a;
+  const S l = d.squaredNorm();
+
+  if(l > 0)
+  {
+    const S t = - a.dot(d);
+    res.parameterization[1] = (t >= l) ? 1 : ((t <= 0) ? 0 : (t / l));
+    res.parameterization[0] = 1 - res.parameterization[1];
+    if(t >= l) { res.sqr_distance = b.squaredNorm(); res.encode = 2; /* 0x10 */ }
+    else if(t <= 0) { res.sqr_distance = a.squaredNorm(); res.encode = 1; /* 0x01 */ }
+    else { res.sqr_distance = (a + d * res.parameterization[1]).squaredNorm(); res.encode = 3; /* 0x00 */ }
+  }
+
+  return res;
+}
+
+//==============================================================================
+template <typename S>
+typename Project<S>::ProjectResult Project<S>::projectTriangleOrigin(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c)
+{
+  ProjectResult res;
+
+  static const size_t nexti[3] = {1, 2, 0};
+  const Vector3<S>* vt[] = {&a, &b, &c};
+  const Vector3<S> dl[] = {a - b, b - c, c - a};
+  const Vector3<S>& n = dl[0].cross(dl[1]);
+  const S l = n.squaredNorm();
+
+  if(l > 0)
+  {
+    S mindist = -1;
+    for(size_t i = 0; i < 3; ++i)
+    {
+      if(vt[i]->dot(dl[i].cross(n)) > 0) // origin is to the outside part of the triangle edge, then the optimal can only be on the edge
+      {
+        size_t j = nexti[i];
+        ProjectResult res_line = projectLineOrigin(*vt[i], *vt[j]);
+
+        if(mindist < 0 || res_line.sqr_distance < mindist)
+        {
+          mindist = res_line.sqr_distance;
+          res.encode = static_cast<size_t>(((res_line.encode&1)?1<<i:0) + ((res_line.encode&2)?1<<j:0));
+          res.parameterization[i] = res_line.parameterization[0];
+          res.parameterization[j] = res_line.parameterization[1];
+          res.parameterization[nexti[j]] = 0;
+        }
+      }
+    }
+
+    if(mindist < 0) // the origin project is within the triangle
+    {
+      S d = a.dot(n);
+      S s = sqrt(l);
+      Vector3<S> o_to_project = n * (d / l);
+      mindist = o_to_project.squaredNorm();
+      res.encode = 7; // m = 0x111
+      res.parameterization[0] = dl[1].cross(b - o_to_project).norm() / s;
+      res.parameterization[1] = dl[2].cross(c - o_to_project).norm() / s;
+      res.parameterization[2] = 1 - res.parameterization[0] - res.parameterization[1];
+    }
+
+    res.sqr_distance = mindist;
+  }
+
+  return  res;
+
+}
+
+//==============================================================================
+template <typename S>
+typename Project<S>::ProjectResult Project<S>::projectTetrahedraOrigin(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& d)
+{
+  ProjectResult res;
+
+  static const size_t nexti[] = {1, 2, 0};
+  const Vector3<S>* vt[] = {&a, &b, &c, &d};
+  const Vector3<S> dl[3] = {a-d, b-d, c-d};
+  S vl = triple(dl[0], dl[1], dl[2]);
+  bool ng = (vl * a.dot((b-c).cross(a-b))) <= 0;
+  if(ng && std::abs(vl) > 0) // abs(vl) == 0, the tetrahedron is degenerated; if ng is false, then the last vertex in the tetrahedron does not grow toward the origin (in fact origin is on the other side of the abc face)
+  {
+    S mindist = -1;
+
+    for(size_t i = 0; i < 3; ++i)
+    {
+      size_t j = nexti[i];
+      S s = vl * d.dot(dl[i].cross(dl[j]));
+      if(s > 0) // the origin is to the outside part of a triangle face, then the optimal can only be on the triangle face
+      {
+        ProjectResult res_triangle = projectTriangleOrigin(*vt[i], *vt[j], d);
+        if(mindist < 0 || res_triangle.sqr_distance < mindist)
+        {
+          mindist = res_triangle.sqr_distance;
+          res.encode = static_cast<size_t>( (res_triangle.encode&1?1<<i:0) + (res_triangle.encode&2?1<<j:0) + (res_triangle.encode&4?8:0) );
+          res.parameterization[i] = res_triangle.parameterization[0];
+          res.parameterization[j] = res_triangle.parameterization[1];
+          res.parameterization[nexti[j]] = 0;
+          res.parameterization[3] = res_triangle.parameterization[2];
+        }
+      }
+    }
+
+    if(mindist < 0)
+    {
+      mindist = 0;
+      res.encode = 15;
+      res.parameterization[0] = triple(c, b, d) / vl;
+      res.parameterization[1] = triple(a, c, d) / vl;
+      res.parameterization[2] = triple(b, a, d) / vl;
+      res.parameterization[3] = 1 - (res.parameterization[0] + res.parameterization[1] + res.parameterization[2]);
+    }
+
+    res.sqr_distance = mindist;
+  }
+  else if(!ng)
+  {
+    res = projectTriangleOrigin(a, b, c);
+    res.parameterization[3] = 0;
+  }
+  return res;
+}
+
+//==============================================================================
+template <typename S>
+Project<S>::ProjectResult::ProjectResult()
+  : parameterization{0.0, 0.0, 0.0, 0.0}, sqr_distance(-1), encode(0)
+{
+  // Do nothing
+}
+
+} // namespace detail
+} // namespace fcl
+
+#endif
diff --git a/include/fcl/math/detail/project.h b/include/fcl/math/detail/project.h
index 39311f2..b0b1b59 100644
--- a/include/fcl/math/detail/project.h
+++ b/include/fcl/math/detail/project.h
@@ -1,96 +1,96 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#ifndef FCL_NARROWPHASE_DETAIL_PROJECT_H
-#define FCL_NARROWPHASE_DETAIL_PROJECT_H
-
-#include "fcl/common/types.h"
-#include "fcl/math/geometry.h"
-
-namespace fcl
-{
-
-namespace detail
-{
-
-/// @brief Project functions
-template <typename S>
-class FCL_EXPORT Project
-{
-public:
-  struct ProjectResult
-  {
-    /// @brief Parameterization of the projected point (based on the simplex to be projected, use 2 or 3 or 4 of the array)
-    S parameterization[4];
-
-    /// @brief square distance from the query point to the projected simplex
-    S sqr_distance;
-
-    /// @brief the code of the projection type
-    unsigned int encode;
-
-    ProjectResult();
-  };
-
-  /// @brief Project point p onto line a-b
-  static ProjectResult projectLine(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& p);
-
-  /// @brief Project point p onto triangle a-b-c
-  static ProjectResult projectTriangle(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& p);
-
-  /// @brief Project point p onto tetrahedra a-b-c-d
-  static ProjectResult projectTetrahedra(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& d, const Vector3<S>& p);
-
-  /// @brief Project origin (0) onto line a-b
-  static ProjectResult projectLineOrigin(const Vector3<S>& a, const Vector3<S>& b);
-
-  /// @brief Project origin (0) onto triangle a-b-c
-  static ProjectResult projectTriangleOrigin(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c);
-
-  /// @brief Project origin (0) onto tetrahedran a-b-c-d
-  static ProjectResult projectTetrahedraOrigin(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& d);
-};
-
-using Projectf = Project<float>;
-using Projectd = Project<double>;
-
-} // namespace detail
-} // namespace fcl
-
-#include "fcl/math/detail/project-inl.h"
-
-#endif
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#ifndef FCL_NARROWPHASE_DETAIL_PROJECT_H
+#define FCL_NARROWPHASE_DETAIL_PROJECT_H
+
+#include "fcl/common/types.h"
+#include "fcl/math/geometry.h"
+
+namespace fcl
+{
+
+namespace detail
+{
+
+/// @brief Project functions
+template <typename S>
+class FCL_EXPORT Project
+{
+public:
+  struct ProjectResult
+  {
+    /// @brief Parameterization of the projected point (based on the simplex to be projected, use 2 or 3 or 4 of the array)
+    S parameterization[4];
+
+    /// @brief square distance from the query point to the projected simplex
+    S sqr_distance;
+
+    /// @brief the code of the projection type
+    unsigned int encode;
+
+    ProjectResult();
+  };
+
+  /// @brief Project point p onto line a-b
+  static ProjectResult projectLine(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& p);
+
+  /// @brief Project point p onto triangle a-b-c
+  static ProjectResult projectTriangle(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& p);
+
+  /// @brief Project point p onto tetrahedra a-b-c-d
+  static ProjectResult projectTetrahedra(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& d, const Vector3<S>& p);
+
+  /// @brief Project origin (0) onto line a-b
+  static ProjectResult projectLineOrigin(const Vector3<S>& a, const Vector3<S>& b);
+
+  /// @brief Project origin (0) onto triangle a-b-c
+  static ProjectResult projectTriangleOrigin(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c);
+
+  /// @brief Project origin (0) onto tetrahedran a-b-c-d
+  static ProjectResult projectTetrahedraOrigin(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>& d);
+};
+
+using Projectf = Project<float>;
+using Projectd = Project<double>;
+
+} // namespace detail
+} // namespace fcl
+
+#include "fcl/math/detail/project-inl.h"
+
+#endif
diff --git a/include/fcl/math/geometry-inl.h b/include/fcl/math/geometry-inl.h
index a9d3dc8..16c09c2 100644
--- a/include/fcl/math/geometry-inl.h
+++ b/include/fcl/math/geometry-inl.h
@@ -464,7 +464,7 @@ void eigen(const Matrix3<S>& m, Vector3<S>& dout, Matrix3<S>& vout)
   Eigen::SelfAdjointEigenSolver<Matrix3<S>> eigensolver(m);
   if (eigensolver.info() != Eigen::Success)
   {
-    std::cerr << "[eigen] Failed to compute eigendecomposition.\n";
+    FCL_CERR << "[eigen] Failed to compute eigendecomposition.\n";
     return;
   }
   dout = eigensolver.eigenvalues();
@@ -556,7 +556,7 @@ void eigen_old(const Matrix3<S>& m, Vector3<S>& dout, Matrix3<S>& vout)
     }
   }
 
-  std::cerr << "eigen: too many iterations in Jacobi transform.\n";
+  FCL_CERR << "eigen: too many iterations in Jacobi transform.\n";
 
   return;
 }
diff --git a/include/fcl/math/motion/interp_motion-inl.h b/include/fcl/math/motion/interp_motion-inl.h
index 384367a..0667e10 100644
--- a/include/fcl/math/motion/interp_motion-inl.h
+++ b/include/fcl/math/motion/interp_motion-inl.h
@@ -127,7 +127,7 @@ InterpMotion<S>::InterpMotion(
 
 //==============================================================================
 template <typename S>
-bool InterpMotion<S>::integrate(double dt) const
+bool InterpMotion<S>::integrate(S dt) const
 {
   if(dt > 1) dt = 1;
 
@@ -187,6 +187,71 @@ void InterpMotion<S>::getTaylorModel(TMatrix3<S>& tm, TVector3<S>& tv) const
 }
 
 //==============================================================================
+#if defined(FCL_MUSA_KERNEL_MODE)
+
+template <typename S>
+void InterpMotion<S>::computeVelocity()
+{
+  // Linear velocity: difference of reference point under start/end transforms.
+  linear_vel = tf2 * reference_p - tf1 * reference_p;
+
+  // Compute relative rotation R = R2 * R1^T.
+  const Matrix3<S> R = tf2.linear() * tf1.linear().transpose();
+
+  // Convert R to axis-angle without going through Eigen::AngleAxis stableNorm
+  // path, to keep stack usage small in kernel builds.
+  const S trace = R(0, 0) + R(1, 1) + R(2, 2);
+  Quaternion<S> q;
+  if(trace > S(0))
+  {
+    const S t = trace + S(1);
+    const S s = std::sqrt(t) * S(2);
+    q.w() = t / s;
+    q.x() = (R(2, 1) - R(1, 2)) / s;
+    q.y() = (R(0, 2) - R(2, 0)) / s;
+    q.z() = (R(1, 0) - R(0, 1)) / s;
+  }
+  else
+  {
+    int i = 0;
+    if(R(1, 1) > R(0, 0)) i = 1;
+    if(R(2, 2) > R(i, i)) i = 2;
+    const int j = (i + 1) % 3;
+    const int k = (i + 2) % 3;
+    const S t = (R(i, i) - R(j, j) - R(k, k)) + S(1);
+    const S s = std::sqrt(t) * S(2);
+    S* q_data = q.coeffs().data(); // x,y,z,w
+    q_data[i] = t / s;
+    q_data[3] = (R(k, j) - R(j, k)) / s;
+    q_data[j] = (R(j, i) + R(i, j)) / s;
+    q_data[k] = (R(k, i) + R(i, k)) / s;
+  }
+
+  // Normalize quaternion to be safe.
+  q.normalize();
+
+  // Extract angle and axis.
+  angular_vel = S(2) * std::acos(std::max(S(-1), std::min(S(1), q.w())));
+  const S sin_half = std::sqrt(std::max(S(0), S(1) - q.w() * q.w()));
+  if(sin_half > std::numeric_limits<S>::epsilon())
+  {
+    angular_axis = Vector3<S>(q.x(), q.y(), q.z()) / sin_half;
+  }
+  else
+  {
+    angular_axis = Vector3<S>::UnitX();
+    angular_vel = 0;
+  }
+
+  if(angular_vel < 0)
+  {
+    angular_vel = -angular_vel;
+    angular_axis = -angular_axis;
+  }
+}
+
+#else
+
 template <typename S>
 void InterpMotion<S>::computeVelocity()
 {
@@ -203,6 +268,8 @@ void InterpMotion<S>::computeVelocity()
   }
 }
 
+#endif
+
 //==============================================================================
 template <typename S>
 Quaternion<S> InterpMotion<S>::deltaRotation(S dt) const
diff --git a/include/fcl/math/motion/interp_motion.h b/include/fcl/math/motion/interp_motion.h
index a7f58eb..b3454b7 100644
--- a/include/fcl/math/motion/interp_motion.h
+++ b/include/fcl/math/motion/interp_motion.h
@@ -76,7 +76,7 @@ public:
 
   /// @brief Integrate the motion from 0 to dt
   /// We compute the current transformation from zero point instead of from last integrate time, for precision.
-  bool integrate(double dt) const;
+  bool integrate(S dt) const;
 
   /// @brief Compute the motion bound for a bounding volume along a given direction n, which is defined in the visitor
   S computeMotionBound(const BVMotionBoundVisitor<S>& mb_visitor) const;
diff --git a/include/fcl/math/motion/screw_motion-inl.h b/include/fcl/math/motion/screw_motion-inl.h
index 53c5c5b..ae72d6c 100644
--- a/include/fcl/math/motion/screw_motion-inl.h
+++ b/include/fcl/math/motion/screw_motion-inl.h
@@ -92,7 +92,7 @@ ScrewMotion<S>::ScrewMotion(
 
 //==============================================================================
 template <typename S>
-bool ScrewMotion<S>::integrate(double dt) const
+bool ScrewMotion<S>::integrate(S dt) const
 {
   if(dt > 1) dt = 1;
 
diff --git a/include/fcl/math/motion/screw_motion.h b/include/fcl/math/motion/screw_motion.h
index fce3387..1099ec3 100644
--- a/include/fcl/math/motion/screw_motion.h
+++ b/include/fcl/math/motion/screw_motion.h
@@ -65,7 +65,7 @@ public:
 
   /// @brief Integrate the motion from 0 to dt
   /// We compute the current transformation from zero point instead of from last integrate time, for precision.
-  bool integrate(double dt) const;
+  bool integrate(S dt) const;
 
   /// @brief Compute the motion bound for a bounding volume along a given direction n, which is defined in the visitor
   S computeMotionBound(const BVMotionBoundVisitor<S>& mb_visitor) const;
diff --git a/include/fcl/math/motion/taylor_model/interval-inl.h b/include/fcl/math/motion/taylor_model/interval-inl.h
index 2e2dbb1..01e8252 100644
--- a/include/fcl/math/motion/taylor_model/interval-inl.h
+++ b/include/fcl/math/motion/taylor_model/interval-inl.h
@@ -395,7 +395,11 @@ Interval<S>& Interval<S>::bound(const Interval<S>& other)
 template <typename S>
 void Interval<S>::print() const
 {
+#if FCL_ENABLE_STD_LOGGING
   std::cout << "[" << i_[0] << ", " << i_[1] << "]" << std::endl;
+#else
+  (void)i_;
+#endif
 }
 
 //==============================================================================
diff --git a/include/fcl/math/motion/taylor_model/interval_matrix-inl.h b/include/fcl/math/motion/taylor_model/interval_matrix-inl.h
index bda8fc0..effb3e9 100644
--- a/include/fcl/math/motion/taylor_model/interval_matrix-inl.h
+++ b/include/fcl/math/motion/taylor_model/interval_matrix-inl.h
@@ -313,9 +313,13 @@ IMatrix3<S>& IMatrix3<S>::rotationConstrain()
 template <typename S>
 void IMatrix3<S>::print() const
 {
+#if FCL_ENABLE_STD_LOGGING
   std::cout << "[" << v_[0][0][0] << "," << v_[0][0][1] << "]" << " [" << v_[0][1][0] << "," << v_[0][1][1] << "]" << " [" << v_[0][2][0] << "," << v_[0][2][1] << "]" << std::endl;
   std::cout << "[" << v_[1][0][0] << "," << v_[1][0][1] << "]" << " [" << v_[1][1][0] << "," << v_[1][1][1] << "]" << " [" << v_[1][2][0] << "," << v_[1][2][1] << "]" << std::endl;
   std::cout << "[" << v_[2][0][0] << "," << v_[2][0][1] << "]" << " [" << v_[2][1][0] << "," << v_[2][1][1] << "]" << " [" << v_[2][2][0] << "," << v_[2][2][1] << "]" << std::endl;
+#else
+  (void)v_;
+#endif
 }
 
 //==============================================================================
diff --git a/include/fcl/math/motion/taylor_model/interval_vector-inl.h b/include/fcl/math/motion/taylor_model/interval_vector-inl.h
index 5755f76..42b356d 100644
--- a/include/fcl/math/motion/taylor_model/interval_vector-inl.h
+++ b/include/fcl/math/motion/taylor_model/interval_vector-inl.h
@@ -295,9 +295,13 @@ S IVector3<S>::volumn() const
 template <typename S>
 void IVector3<S>::print() const
 {
+#if FCL_ENABLE_STD_LOGGING
   std::cout << "[" << i_[0][0] << "," << i_[0][1] << "]" << std::endl;
   std::cout << "[" << i_[1][0] << "," << i_[1][1] << "]" << std::endl;
   std::cout << "[" << i_[2][0] << "," << i_[2][1] << "]" << std::endl;
+#else
+  (void)i_;
+#endif
 }
 
 //==============================================================================
diff --git a/include/fcl/math/motion/taylor_model/taylor_model-inl.h b/include/fcl/math/motion/taylor_model/taylor_model-inl.h
index 861f72d..5ccb7e0 100644
--- a/include/fcl/math/motion/taylor_model/taylor_model-inl.h
+++ b/include/fcl/math/motion/taylor_model/taylor_model-inl.h
@@ -331,7 +331,12 @@ TaylorModel<S> TaylorModel<S>::operator - () const
 template <typename S>
 void TaylorModel<S>::print() const
 {
+#if FCL_ENABLE_STD_LOGGING
   std::cout << coeffs_[0] << "+" << coeffs_[1] << "*t+" << coeffs_[2] << "*t^2+" << coeffs_[3] << "*t^3+[" << r_[0] << "," << r_[1] << "]" << std::endl;
+#else
+  (void)coeffs_;
+  (void)r_;
+#endif
 }
 
 //==============================================================================
diff --git a/include/fcl/math/rng-inl.h b/include/fcl/math/rng-inl.h
index 8877c48..8a8d895 100644
--- a/include/fcl/math/rng-inl.h
+++ b/include/fcl/math/rng-inl.h
@@ -193,13 +193,13 @@ void RNG<S>::setSeed(uint_fast32_t seed)
 {
   if (detail::Seed::isFirstSeedGenerated())
   {
-    std::cerr << "Random number generation already started. Changing seed now "
+    FCL_CERR << "Random number generation already started. Changing seed now "
               << "will not lead to deterministic sampling.\n";
   }
 
   if (seed == 0)
   {
-    std::cerr << "Random generator seed cannot be 0. Using 1 instead.\n";
+    FCL_CERR << "Random generator seed cannot be 0. Using 1 instead.\n";
     detail::Seed::setUserSetSeed(1);
   }
   else
diff --git a/include/fcl/narrowphase/collision-inl.h b/include/fcl/narrowphase/collision-inl.h
index 69f4c2c..1fd35ba 100644
--- a/include/fcl/narrowphase/collision-inl.h
+++ b/include/fcl/narrowphase/collision-inl.h
@@ -110,7 +110,7 @@ std::size_t collide(
   std::size_t res;
   if(request.num_max_contacts == 0)
   {
-    std::cerr << "Warning: should stop early as num_max_contact is " << request.num_max_contacts << " !\n";
+    FCL_CERR << "Warning: should stop early as num_max_contact is " << request.num_max_contacts << " !\n";
     res = 0;
   }
   else
@@ -124,7 +124,7 @@ std::size_t collide(
     {
       if(!looktable.collision_matrix[node_type2][node_type1])
       {
-        std::cerr << "Warning: collision function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
+        FCL_CERR << "Warning: collision function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
         res = 0;
       }
       else
@@ -134,7 +134,7 @@ std::size_t collide(
     {
       if(!looktable.collision_matrix[node_type1][node_type2])
       {
-        std::cerr << "Warning: collision function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
+        FCL_CERR << "Warning: collision function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
         res = 0;
       }
       else
@@ -201,7 +201,7 @@ std::size_t collide(
       return collide(o1, tf1, o2, tf2, &solver, request, result);
     }
   default:
-    std::cerr << "Warning! Invalid GJK solver\n";
+    FCL_CERR << "Warning! Invalid GJK solver\n";
     return -1; // error
   }
 }
diff --git a/include/fcl/narrowphase/continuous_collision-inl.h b/include/fcl/narrowphase/continuous_collision-inl.h
index b24d0b8..4df23cf 100644
--- a/include/fcl/narrowphase/continuous_collision-inl.h
+++ b/include/fcl/narrowphase/continuous_collision-inl.h
@@ -291,7 +291,7 @@ S continuousCollideBVHPolynomial(
     ;
   }
 
-  std::cerr << "Warning: BV type not supported by polynomial solver CCD\n";
+  FCL_CERR << "Warning: BV type not supported by polynomial solver CCD\n";
 
   return -1;
 }
@@ -326,7 +326,7 @@ typename NarrowPhaseSolver::S continuousCollideConservativeAdvancement(
 
   if(!looktable.conservative_advancement_matrix[node_type1][node_type2])
   {
-    std::cerr << "Warning: collision function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
+    FCL_CERR << "Warning: collision function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
   }
   else
   {
@@ -412,7 +412,7 @@ S continuousCollide(
 
     }
     else
-      std::cerr << "Warning! Invalid continuous collision setting\n";
+      FCL_CERR << "Warning! Invalid continuous collision setting\n";
     break;
   case CCDC_POLYNOMIAL_SOLVER:
     if(o1->getObjectType() == OT_BVH && o2->getObjectType() == OT_BVH && request.ccd_motion_type == CCDM_TRANS)
@@ -422,10 +422,10 @@ S continuousCollide(
                                             request, result);
     }
     else
-      std::cerr << "Warning! Invalid continuous collision checking\n";
+      FCL_CERR << "Warning! Invalid continuous collision checking\n";
     break;
   default:
-    std::cerr << "Warning! Invalid continuous collision setting\n";
+    FCL_CERR << "Warning! Invalid continuous collision setting\n";
   }
 
   return -1;
diff --git a/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd-inl.h b/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd-inl.h
index 60fd0ad..b205581 100644
--- a/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd-inl.h
+++ b/include/fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd-inl.h
@@ -38,15 +38,16 @@
 #ifndef FCL_NARROWPHASE_DETAIL_GJKLIBCCD_INL_H
 #define FCL_NARROWPHASE_DETAIL_GJKLIBCCD_INL_H
 
-#include "fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd.h"
-#include "fcl/narrowphase/detail/failed_at_this_configuration.h"
-
 #include <array>
+#include <string>
 #include <unordered_map>
 #include <unordered_set>
 
 #include "fcl/common/unused.h"
 #include "fcl/common/warning.h"
+#include "fcl/logging.h"
+#include "fcl/narrowphase/detail/convexity_based_algorithm/gjk_libccd.h"
+#include "fcl/narrowphase/detail/failed_at_this_configuration.h"
 
 namespace fcl
 {
@@ -186,6 +187,46 @@ struct ccd_triangle_t : public ccd_obj_t
 namespace libccd_extension
 {
 
+// These two functions contain the only "valid" invocations of
+// ccdVec3PointTriDist2(). Any other invocations should be considered a defect.
+// We can remove these safety layers if/when the issue noted below gets
+// resolved upstream.
+
+// The code in this file (and elsewhere if it comes up), should *not* ever call
+// `ccdVec3PointTriDist2()` directly. It has some precision quirks. For those
+// invocations that want the squared distance without a witness point, call
+// *this* function.
+static ccd_real_t ccdVec3PointTriDist2NoWitness(const ccd_vec3_t* P,
+                                                const ccd_vec3_t* a,
+                                                const ccd_vec3_t* b,
+                                                const ccd_vec3_t* c) {
+  // When called, ccdVec3PointTriDist2 can optionally compute the value of the
+  // "witness" point. When we don't need the witness point, we skip it. However,
+  // the libccd implementation takes two different code paths based on whether
+  // we request the witness point producing different answers due to numerical
+  // precision issues. So, when FCL doesn't want/need a witness point, we use
+  // this wrapper to force the witness point to get a more consistent and
+  // reliable answer. See
+  // https://github.com/danfis/libccd/issues/55 for an explanation.
+  //
+  // Any actual invocation of ccdVec3PointTriDist2() in the code should request
+  // a witness point *or* call this invocation.
+  ccd_vec3_t unused;
+  return ccdVec3PointTriDist2(P, a, b, c, &unused);
+}
+
+// The code in this file (and elsewhere if it comes up), should *not* ever call
+// `ccdVec3PointTriDist2()` directly. It has some precision quirks. For those
+// invocations that want the squared distance *with* a witness point, call
+// *this* function.
+static ccd_real_t ccdVec3PointTriDist2WithWitness(const ccd_vec3_t* P,
+                                                  const ccd_vec3_t* a,
+                                                  const ccd_vec3_t* b,
+                                                  const ccd_vec3_t* c,
+                                                  ccd_vec3_t* w) {
+  return ccdVec3PointTriDist2(P, a, b, c, w);
+}
+
 static ccd_real_t simplexReduceToTriangle(ccd_simplex_t *simplex,
                                           ccd_real_t dist,
                                           ccd_vec3_t *best_witness)
@@ -197,11 +238,10 @@ static ccd_real_t simplexReduceToTriangle(ccd_simplex_t *simplex,
 
   // try the fourth point in all three positions
   for (i = 0; i < 3; i++){
-    newdist = ccdVec3PointTriDist2(ccd_vec3_origin,
-                                   &ccdSimplexPoint(simplex, (i == 0 ? 3 : 0))->v,
-                                   &ccdSimplexPoint(simplex, (i == 1 ? 3 : 1))->v,
-                                   &ccdSimplexPoint(simplex, (i == 2 ? 3 : 2))->v,
-                                   &witness);
+    newdist = ccdVec3PointTriDist2WithWitness(
+        ccd_vec3_origin, &ccdSimplexPoint(simplex, (i == 0 ? 3 : 0))->v,
+        &ccdSimplexPoint(simplex, (i == 1 ? 3 : 1))->v,
+        &ccdSimplexPoint(simplex, (i == 2 ? 3 : 2))->v, &witness);
     newdist = CCD_SQRT(newdist);
 
     // record the best triangle
@@ -398,13 +438,8 @@ static int doSimplex3(ccd_simplex_t *simplex, ccd_vec3_t *dir)
   C = ccdSimplexPoint(simplex, 0);
 
   // check touching contact
-  // Compute origin_projection as well. Without computing the origin projection,
-  // libccd could give inaccurate result. See
-  // https://github.com/danfis/libccd/issues/55.
-  ccd_vec3_t origin_projection_unused;
-
-  const ccd_real_t dist_squared = ccdVec3PointTriDist2(
-      ccd_vec3_origin, &A->v, &B->v, &C->v, &origin_projection_unused);
+  const ccd_real_t dist_squared = ccdVec3PointTriDist2NoWitness(
+      ccd_vec3_origin, &A->v, &B->v, &C->v);
   if (isAbsValueLessThanEpsSquared(dist_squared)) {
     return 1;
   }
@@ -493,30 +528,25 @@ static int doSimplex4(ccd_simplex_t *simplex, ccd_vec3_t *dir)
   // check if tetrahedron is really tetrahedron (has volume > 0)
   // if it is not simplex can't be expanded and thus no intersection is
   // found.
-  // point_projection_on_triangle_unused is not used. We ask
-  // ccdVec3PointTriDist2 to compute this witness point, so as to get a
-  // numerical robust dist_squared. See
-  // https://github.com/danfis/libccd/issues/55 for an explanation.
-  ccd_vec3_t point_projection_on_triangle_unused;
-  ccd_real_t dist_squared = ccdVec3PointTriDist2(
-      &A->v, &B->v, &C->v, &D->v, &point_projection_on_triangle_unused);
+  ccd_real_t dist_squared = ccdVec3PointTriDist2NoWitness(
+      &A->v, &B->v, &C->v, &D->v);
   if (isAbsValueLessThanEpsSquared(dist_squared)) {
     return -1;
   }
 
   // check if origin lies on some of tetrahedron's face - if so objects
   // intersect
-  dist_squared = ccdVec3PointTriDist2(ccd_vec3_origin, &A->v, &B->v, &C->v,
-                                      &point_projection_on_triangle_unused);
+  dist_squared =
+      ccdVec3PointTriDist2NoWitness(ccd_vec3_origin, &A->v, &B->v, &C->v);
   if (isAbsValueLessThanEpsSquared((dist_squared))) return 1;
-  dist_squared = ccdVec3PointTriDist2(ccd_vec3_origin, &A->v, &C->v, &D->v,
-                                      &point_projection_on_triangle_unused);
+  dist_squared =
+      ccdVec3PointTriDist2NoWitness(ccd_vec3_origin, &A->v, &C->v, &D->v);
   if (isAbsValueLessThanEpsSquared((dist_squared))) return 1;
-  dist_squared = ccdVec3PointTriDist2(ccd_vec3_origin, &A->v, &B->v, &D->v,
-                                      &point_projection_on_triangle_unused);
+  dist_squared =
+      ccdVec3PointTriDist2NoWitness(ccd_vec3_origin, &A->v, &B->v, &D->v);
   if (isAbsValueLessThanEpsSquared(dist_squared)) return 1;
-  dist_squared = ccdVec3PointTriDist2(ccd_vec3_origin, &B->v, &C->v, &D->v,
-                                      &point_projection_on_triangle_unused);
+  dist_squared =
+      ccdVec3PointTriDist2NoWitness(ccd_vec3_origin, &B->v, &C->v, &D->v);
   if (isAbsValueLessThanEpsSquared(dist_squared)) return 1;
 
   // compute AO, AB, AC, AD segments and ABC, ACD, ADB normal vectors
@@ -757,15 +787,14 @@ static int convert2SimplexToTetrahedron(const void* obj1, const void* obj2,
   ccdVec3Sub2(&ac, &c->v, &a->v);
   ccdVec3Cross(&dir, &ab, &ac);
   __ccdSupport(obj1, obj2, &dir, ccd, &d);
-  ccd_vec3_t point_projection_on_triangle_unused;
-  const ccd_real_t dist_squared = ccdVec3PointTriDist2(
-      &d.v, &a->v, &b->v, &c->v, &point_projection_on_triangle_unused);
+  const ccd_real_t dist_squared =
+      ccdVec3PointTriDist2NoWitness(&d.v, &a->v, &b->v, &c->v);
 
   // and second one take in opposite direction
   ccdVec3Scale(&dir, -CCD_ONE);
   __ccdSupport(obj1, obj2, &dir, ccd, &d2);
-  const ccd_real_t dist_squared_opposite = ccdVec3PointTriDist2(
-      &d2.v, &a->v, &b->v, &c->v, &point_projection_on_triangle_unused);
+  const ccd_real_t dist_squared_opposite =
+      ccdVec3PointTriDist2NoWitness(&d2.v, &a->v, &b->v, &c->v);
 
   // check if face isn't already on edge of minkowski sum and thus we
   // have touching contact
@@ -844,14 +873,15 @@ static int simplexToPolytope4(const void* obj1, const void* obj2,
   // of the simplex to that face and then attempt to construct the polytope from
   // the resulting face. We simply take the first face which exhibited the
   // trait.
+
   ccd_real_t dist_squared =
-      ccdVec3PointTriDist2(ccd_vec3_origin, &a->v, &b->v, &c->v, NULL);
+      ccdVec3PointTriDist2NoWitness(ccd_vec3_origin, &a->v, &b->v, &c->v);
   if (isAbsValueLessThanEpsSquared(dist_squared)) {
     use_polytope3 = true;
   }
   if (!use_polytope3) {
     dist_squared =
-        ccdVec3PointTriDist2(ccd_vec3_origin, &a->v, &c->v, &d->v, NULL);
+        ccdVec3PointTriDist2NoWitness(ccd_vec3_origin, &a->v, &c->v, &d->v);
     if (isAbsValueLessThanEpsSquared(dist_squared)) {
       use_polytope3 = true;
       ccdSimplexSet(simplex, 1, c);
@@ -860,7 +890,7 @@ static int simplexToPolytope4(const void* obj1, const void* obj2,
   }
   if (!use_polytope3) {
     dist_squared =
-        ccdVec3PointTriDist2(ccd_vec3_origin, &a->v, &b->v, &d->v, NULL);
+        ccdVec3PointTriDist2NoWitness(ccd_vec3_origin, &a->v, &b->v, &d->v);
     if (isAbsValueLessThanEpsSquared(dist_squared)) {
       use_polytope3 = true;
       ccdSimplexSet(simplex, 2, d);
@@ -868,7 +898,7 @@ static int simplexToPolytope4(const void* obj1, const void* obj2,
   }
   if (!use_polytope3) {
     dist_squared =
-        ccdVec3PointTriDist2(ccd_vec3_origin, &b->v, &c->v, &d->v, NULL);
+        ccdVec3PointTriDist2NoWitness(ccd_vec3_origin, &b->v, &c->v, &d->v);
     if (isAbsValueLessThanEpsSquared(dist_squared)) {
       use_polytope3 = true;
       ccdSimplexSet(simplex, 0, b);
@@ -1583,9 +1613,7 @@ static int nextSupport(const ccd_pt_t* polytope, const void* obj1,
     ccdPtFaceVec3(reinterpret_cast<const ccd_pt_face_t*>(el), &a, &b, &c);
 
     // check if new point can significantly expand polytope
-    ccd_vec3_t point_projection_on_triangle_unused;
-    dist_squared = ccdVec3PointTriDist2(&out->v, a, b, c,
-                                        &point_projection_on_triangle_unused);
+    dist_squared = ccdVec3PointTriDist2NoWitness(&out->v, a, b, c);
   }
 
   if (std::sqrt(dist_squared) < ccd->epa_tolerance) return -1;
@@ -1716,9 +1744,12 @@ static void validateNearestFeatureOfPolytopeBeingEdge(ccd_pt_t* polytope) {
     // distance to be considered zero. We assume that the GJK/EPA code
     // ultimately classifies inside/outside around *zero* and *not* epsilon.
     if (origin_to_face_distance[i] > plane_threshold) {
-      FCL_THROW_FAILED_AT_THIS_CONFIGURATION(
-          "The origin is outside of the polytope. This should already have "
-          "been identified as separating.");
+      fcl::logging::StringBuilder builder;
+      builder << "The origin is outside of the polytope by "
+              << origin_to_face_distance[i] << ", exceeding the threshold "
+              << plane_threshold
+              << ". This should already have been identified as separating.";
+      FCL_THROW_FAILED_AT_THIS_CONFIGURATION(builder.str());
     }
   }
 
@@ -2065,11 +2096,10 @@ static inline ccd_real_t _ccdDist(const void *obj1, const void *obj2,
     }
     else if (ccdSimplexSize(simplex) == 3)
     {
-      dist = ccdVec3PointTriDist2(ccd_vec3_origin,
-                                  &ccdSimplexPoint(simplex, 0)->v,
-                                  &ccdSimplexPoint(simplex, 1)->v,
-                                  &ccdSimplexPoint(simplex, 2)->v,
-                                  &closest_p);
+      dist = ccdVec3PointTriDist2WithWitness(
+          ccd_vec3_origin, &ccdSimplexPoint(simplex, 0)->v,
+          &ccdSimplexPoint(simplex, 1)->v, &ccdSimplexPoint(simplex, 2)->v,
+          &closest_p);
       dist = CCD_SQRT(dist);
     }
     else
diff --git a/include/fcl/narrowphase/detail/failed_at_this_configuration.h b/include/fcl/narrowphase/detail/failed_at_this_configuration.h
index b36bb59..e52a934 100644
--- a/include/fcl/narrowphase/detail/failed_at_this_configuration.h
+++ b/include/fcl/narrowphase/detail/failed_at_this_configuration.h
@@ -38,12 +38,16 @@
 #define FCL_FAILED_AT_THIS_CONFIGURATION_H
 
 #include <exception>
-#include <iomanip>
-#include <iostream>
-#include <sstream>
 #include <stdexcept>
 #include <string>
 
+#if FCL_ENABLE_STD_LOGGING
+#include <iomanip>
+#include <ostream>
+#include <sstream>
+#endif
+
+#include "fcl/common/types.h"
 #include "fcl/export.h"
 
 namespace fcl {
@@ -85,6 +89,48 @@ class FCL_EXPORT FailedAtThisConfiguration final
 FCL_EXPORT void ThrowFailedAtThisConfiguration(
     const std::string& message, const char* func, const char* file, int line);
 
+/** Works in conjuction with ThrowDetailedConfiguration() to format the pose
+ in a more python-like repr() way (facilitating error reproduction). In this
+ case, just doing comma-delimited print outs makes copying-and-pasting the
+ error message contents into code easier.
+
+ The intention is that the matrix is printed out as:
+
+      a, b, c, d,
+      e, f, g, h,
+      i, j, k, l,
+      m, n, o, p;
+
+ so, that it can easily be copied and pasted into code like this:
+
+ Transform3<S> X;
+ X.matrix() << a, b, c, d,
+               e, f, g, h,
+               i, j, k, l,
+               m, n, o, p; */
+#if FCL_ENABLE_STD_LOGGING
+
+template <typename S>
+void WriteCommaSeparated(
+    std::stringstream* sstream,
+    const Transform3<S>& p) {
+  const auto& m = p.matrix();
+  std::stringstream& ss = *sstream;
+  for (int row = 0; row < 4; ++row) {
+    for (int col = 0; col < 4; ++col) {
+      ss << m(row, col);
+      if (col < 3) {
+        ss << ", ";
+      }
+    }
+    if (row < 3) {
+      ss << ",\n";
+    } else {
+      ss << ";";
+    }
+  }
+}
+
 /** Helper class for propagating a low-level exception upwards but with
  configuration-specific details appended. The parameters
  
@@ -99,22 +145,36 @@ FCL_EXPORT void ThrowFailedAtThisConfiguration(
  @tparam Solver   The solver type (with scalar type erase).
  @tparam Pose     The pose type (a Transform<S> with scalar type erased).
  */
-template <typename Shape1, typename Shape2, typename Solver, typename Pose>
-void ThrowDetailedConfiguration(const Shape1& s1, const Pose& X_FS1,
-                                const Shape2& s2, const Pose& X_FS2,
+template <typename Shape1, typename Shape2, typename Solver, typename S>
+void ThrowDetailedConfiguration(const Shape1& s1, const Transform3<S>& X_FS1,
+                                const Shape2& s2, const Transform3<S>& X_FS2,
                                 const Solver& solver, const std::exception& e) {
   std::stringstream ss;
-  ss << std::setprecision(20);
+  const int digits = 20;
+  ss << std::setprecision(digits);
   ss << "Error with configuration"
      << "\n  Original error message: " << e.what()
-     << "\n  Shape 1: " << s1
-     << "\n  X_FS1\n" << X_FS1.matrix()
-     << "\n  Shape 2: " << s2
-     << "\n  X_FS2\n" << X_FS2.matrix()
-     << "\n  Solver: " << solver;
+     << "\n  Shape 1:\n" << s1.representation(digits)
+     << "\n  X_FS1\n";
+  WriteCommaSeparated(&ss, X_FS1);
+  ss << "\n  Shape 2:\n" << s2.representation(digits)
+     << "\n  X_FS2\n";
+  WriteCommaSeparated(&ss, X_FS2);
+  ss << "\n  Solver: " << solver;
   throw std::logic_error(ss.str());
 }
 
+#else
+
+template <typename Shape1, typename Shape2, typename Solver, typename S>
+void ThrowDetailedConfiguration(const Shape1&, const Transform3<S>&,
+                                const Shape2&, const Transform3<S>&,
+                                const Solver&, const std::exception& e) {
+  throw std::logic_error(e.what());
+}
+
+#endif
+
 }  // namespace detail
 }  // namespace fcl
 
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance-inl.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance-inl.h
index 33a1d4f..c6f6502 100644
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance-inl.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance-inl.h
@@ -1,467 +1,467 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#ifndef FCL_NARROWPHASE_DETAIL_TRIANGLEDISTANCE_INL_H
-#define FCL_NARROWPHASE_DETAIL_TRIANGLEDISTANCE_INL_H
-
-#include "fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance.h"
-
-namespace fcl
-{
-
-namespace detail
-{
-
-//==============================================================================
-extern template
-class FCL_EXPORT TriangleDistance<double>;
-
-//==============================================================================
-template <typename S>
-void TriangleDistance<S>::segPoints(const Vector3<S>& P, const Vector3<S>& A, const Vector3<S>& Q, const Vector3<S>& B,
-                                 Vector3<S>& VEC, Vector3<S>& X, Vector3<S>& Y)
-{
-  Vector3<S> T;
-  S A_dot_A, B_dot_B, A_dot_B, A_dot_T, B_dot_T;
-  Vector3<S> TMP;
-
-  T = Q - P;
-  A_dot_A = A.dot(A);
-  B_dot_B = B.dot(B);
-  A_dot_B = A.dot(B);
-  A_dot_T = A.dot(T);
-  B_dot_T = B.dot(T);
-
-  // t parameterizes ray P,A
-  // u parameterizes ray Q,B
-
-  S t, u;
-
-  // compute t for the closest point on ray P,A to
-  // ray Q,B
-
-  S denom = A_dot_A*B_dot_B - A_dot_B*A_dot_B;
-
-  t = (A_dot_T*B_dot_B - B_dot_T*A_dot_B) / denom;
-
-  // clamp result so t is on the segment P,A
-
-  if((t < 0) || std::isnan(t)) t = 0; else if(t > 1) t = 1;
-
-  // find u for point on ray Q,B closest to point at t
-
-  u = (t*A_dot_B - B_dot_T) / B_dot_B;
-
-  // if u is on segment Q,B, t and u correspond to
-  // closest points, otherwise, clamp u, recompute and
-  // clamp t
-
-  if((u <= 0) || std::isnan(u))
-  {
-    Y = Q;
-
-    t = A_dot_T / A_dot_A;
-
-    if((t <= 0) || std::isnan(t))
-    {
-      X = P;
-      VEC = Q - P;
-    }
-    else if(t >= 1)
-    {
-      X = P + A;
-      VEC = Q - X;
-    }
-    else
-    {
-      X = P + A * t;
-      TMP = T.cross(A);
-      VEC = A.cross(TMP);
-    }
-  }
-  else if (u >= 1)
-  {
-    Y = Q + B;
-
-    t = (A_dot_B + A_dot_T) / A_dot_A;
-
-    if((t <= 0) || std::isnan(t))
-    {
-      X = P;
-      VEC = Y - P;
-    }
-    else if(t >= 1)
-    {
-      X = P + A;
-      VEC = Y - X;
-    }
-    else
-    {
-      X = P + A * t;
-      T = Y - P;
-      TMP = T.cross(A);
-      VEC= A.cross(TMP);
-    }
-  }
-  else
-  {
-    Y = Q + B * u;
-
-    if((t <= 0) || std::isnan(t))
-    {
-      X = P;
-      TMP = T.cross(B);
-      VEC = B.cross(TMP);
-    }
-    else if(t >= 1)
-    {
-      X = P + A;
-      T = Q - X;
-      TMP = T.cross(B);
-      VEC = B.cross(TMP);
-    }
-    else
-    {
-      X = P + A * t;
-      VEC = A.cross(B);
-      if(VEC.dot(T) < 0)
-      {
-        VEC = VEC * (-1);
-      }
-    }
-  }
-}
-
-//==============================================================================
-template <typename S>
-S TriangleDistance<S>::triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3], Vector3<S>& P, Vector3<S>& Q)
-{
-  // Compute vectors along the 6 sides
-
-  Vector3<S> Sv[3];
-  Vector3<S> Tv[3];
-  Vector3<S> VEC;
-
-  Sv[0] = T1[1] - T1[0];
-  Sv[1] = T1[2] - T1[1];
-  Sv[2] = T1[0] - T1[2];
-
-  Tv[0] = T2[1] - T2[0];
-  Tv[1] = T2[2] - T2[1];
-  Tv[2] = T2[0] - T2[2];
-
-  // For each edge pair, the vector connecting the closest points
-  // of the edges defines a slab (parallel planes at head and tail
-  // enclose the slab). If we can show that the off-edge vertex of
-  // each triangle is outside of the slab, then the closest points
-  // of the edges are the closest points for the triangles.
-  // Even if these tests fail, it may be helpful to know the closest
-  // points found, and whether the triangles were shown disjoint
-
-  Vector3<S> V;
-  Vector3<S> Z;
-  Vector3<S> minP = Vector3<S>::Zero();
-  Vector3<S> minQ = Vector3<S>::Zero();
-  S mindd;
-  int shown_disjoint = 0;
-
-  mindd = (T1[0] - T2[0]).squaredNorm() + 1; // Set first minimum safely high
-
-  for(int i = 0; i < 3; ++i)
-  {
-    for(int j = 0; j < 3; ++j)
-    {
-      // Find closest points on edges i & j, plus the
-      // vector (and distance squared) between these points
-      segPoints(T1[i], Sv[i], T2[j], Tv[j], VEC, P, Q);
-
-      V = Q - P;
-      S dd = V.dot(V);
-
-      // Verify this closest point pair only if the distance
-      // squared is less than the minimum found thus far.
-
-      if(dd <= mindd)
-      {
-        minP = P;
-        minQ = Q;
-        mindd = dd;
-
-        Z = T1[(i+2)%3] - P;
-        S a = Z.dot(VEC);
-        Z = T2[(j+2)%3] - Q;
-        S b = Z.dot(VEC);
-
-        if((a <= 0) && (b >= 0)) return sqrt(dd);
-
-        S p = V.dot(VEC);
-
-        if(a < 0) a = 0;
-        if(b > 0) b = 0;
-        if((p - a + b) > 0) shown_disjoint = 1;
-      }
-    }
-  }
-
-  // No edge pairs contained the closest points.
-  // either:
-  // 1. one of the closest points is a vertex, and the
-  //    other point is interior to a face.
-  // 2. the triangles are overlapping.
-  // 3. an edge of one triangle is parallel to the other's face. If
-  //    cases 1 and 2 are not true, then the closest points from the 9
-  //    edge pairs checks above can be taken as closest points for the
-  //    triangles.
-  // 4. possibly, the triangles were degenerate.  When the
-  //    triangle points are nearly colinear or coincident, one
-  //    of above tests might fail even though the edges tested
-  //    contain the closest points.
-
-  // First check for case 1
-
-  Vector3<S> Sn;
-  S Snl;
-
-  Sn = Sv[0].cross(Sv[1]); // Compute normal to T1 triangle
-  Snl = Sn.dot(Sn);        // Compute square of length of normal
-
-  // If cross product is long enough,
-
-  if(Snl > 1e-15)
-  {
-    // Get projection lengths of T2 points
-
-    Vector3<S> Tp;
-
-    V = T1[0] - T2[0];
-    Tp[0] = V.dot(Sn);
-
-    V = T1[0] - T2[1];
-    Tp[1] = V.dot(Sn);
-
-    V = T1[0] - T2[2];
-    Tp[2] = V.dot(Sn);
-
-    // If Sn is a separating direction,
-    // find point with smallest projection
-
-    int point = -1;
-    if((Tp[0] > 0) && (Tp[1] > 0) && (Tp[2] > 0))
-    {
-      if(Tp[0] < Tp[1]) point = 0; else point = 1;
-      if(Tp[2] < Tp[point]) point = 2;
-    }
-    else if((Tp[0] < 0) && (Tp[1] < 0) && (Tp[2] < 0))
-    {
-      if(Tp[0] > Tp[1]) point = 0; else point = 1;
-      if(Tp[2] > Tp[point]) point = 2;
-    }
-
-    // If Sn is a separating direction,
-
-    if(point >= 0)
-    {
-      shown_disjoint = 1;
-
-      // Test whether the point found, when projected onto the
-      // other triangle, lies within the face.
-
-      V = T2[point] - T1[0];
-      Z = Sn.cross(Sv[0]);
-      if(V.dot(Z) > 0)
-      {
-        V = T2[point] - T1[1];
-        Z = Sn.cross(Sv[1]);
-        if(V.dot(Z) > 0)
-        {
-          V = T2[point] - T1[2];
-          Z = Sn.cross(Sv[2]);
-          if(V.dot(Z) > 0)
-          {
-            // T[point] passed the test - it's a closest point for
-            // the T2 triangle; the other point is on the face of T1
-            P = T2[point] + Sn * (Tp[point] / Snl);
-            Q = T2[point];
-            return (P - Q).norm();
-          }
-        }
-      }
-    }
-  }
-
-  Vector3<S> Tn;
-  S Tnl;
-
-  Tn = Tv[0].cross(Tv[1]);
-  Tnl = Tn.dot(Tn);
-
-  if(Tnl > 1e-15)
-  {
-    Vector3<S> Sp;
-
-    V = T2[0] - T1[0];
-    Sp[0] = V.dot(Tn);
-
-    V = T2[0] - T1[1];
-    Sp[1] = V.dot(Tn);
-
-    V = T2[0] - T1[2];
-    Sp[2] = V.dot(Tn);
-
-    int point = -1;
-    if((Sp[0] > 0) && (Sp[1] > 0) && (Sp[2] > 0))
-    {
-      if(Sp[0] < Sp[1]) point = 0; else point = 1;
-      if(Sp[2] < Sp[point]) point = 2;
-    }
-    else if((Sp[0] < 0) && (Sp[1] < 0) && (Sp[2] < 0))
-    {
-      if(Sp[0] > Sp[1]) point = 0; else point = 1;
-      if(Sp[2] > Sp[point]) point = 2;
-    }
-
-    if(point >= 0)
-    {
-      shown_disjoint = 1;
-
-      V = T1[point] - T2[0];
-      Z = Tn.cross(Tv[0]);
-      if(V.dot(Z) > 0)
-      {
-        V = T1[point] - T2[1];
-        Z = Tn.cross(Tv[1]);
-        if(V.dot(Z) > 0)
-        {
-          V = T1[point] - T2[2];
-          Z = Tn.cross(Tv[2]);
-          if(V.dot(Z) > 0)
-          {
-            P = T1[point];
-            Q = T1[point] + Tn * (Sp[point] / Tnl);
-            return (P - Q).norm();
-          }
-        }
-      }
-    }
-  }
-
-  // Case 1 can't be shown.
-  // If one of these tests showed the triangles disjoint,
-  // we assume case 3 or 4, otherwise we conclude case 2,
-  // that the triangles overlap.
-
-  if(shown_disjoint)
-  {
-    P = minP;
-    Q = minQ;
-    return sqrt(mindd);
-  }
-  else return 0;
-}
-
-//==============================================================================
-template <typename S>
-S TriangleDistance<S>::triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
-                                       const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
-                                       Vector3<S>& P, Vector3<S>& Q)
-{
-  Vector3<S> U[3];
-  Vector3<S> T[3];
-  U[0] = S1; U[1] = S2; U[2] = S3;
-  T[0] = T1; T[1] = T2; T[2] = T3;
-
-  return triDistance(U, T, P, Q);
-}
-
-//==============================================================================
-template <typename S>
-S TriangleDistance<S>::triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3],
-                                       const Matrix3<S>& R, const Vector3<S>& Tl,
-                                       Vector3<S>& P, Vector3<S>& Q)
-{
-  Vector3<S> T_transformed[3];
-  T_transformed[0] = R * T2[0] + Tl;
-  T_transformed[1] = R * T2[1] + Tl;
-  T_transformed[2] = R * T2[2] + Tl;
-
-  return triDistance(T1, T_transformed, P, Q);
-}
-
-//==============================================================================
-template <typename S>
-S TriangleDistance<S>::triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3],
-                                       const Transform3<S>& tf,
-                                       Vector3<S>& P, Vector3<S>& Q)
-{
-  Vector3<S> T_transformed[3];
-  T_transformed[0] = tf * T2[0];
-  T_transformed[1] = tf * T2[1];
-  T_transformed[2] = tf * T2[2];
-
-  return triDistance(T1, T_transformed, P, Q);
-}
-
-//==============================================================================
-template <typename S>
-S TriangleDistance<S>::triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
-                                       const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
-                                       const Matrix3<S>& R, const Vector3<S>& Tl,
-                                       Vector3<S>& P, Vector3<S>& Q)
-{
-  Vector3<S> T1_transformed = R * T1 + Tl;
-  Vector3<S> T2_transformed = R * T2 + Tl;
-  Vector3<S> T3_transformed = R * T3 + Tl;
-  return triDistance(S1, S2, S3, T1_transformed, T2_transformed, T3_transformed, P, Q);
-}
-
-//==============================================================================
-template <typename S>
-S TriangleDistance<S>::triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
-                                       const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
-                                       const Transform3<S>& tf,
-                                       Vector3<S>& P, Vector3<S>& Q)
-{
-  Vector3<S> T1_transformed = tf * T1;
-  Vector3<S> T2_transformed = tf * T2;
-  Vector3<S> T3_transformed = tf * T3;
-  return triDistance(S1, S2, S3, T1_transformed, T2_transformed, T3_transformed, P, Q);
-}
-
-} // namespace detail
-} // namespace fcl
-
-#endif
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#ifndef FCL_NARROWPHASE_DETAIL_TRIANGLEDISTANCE_INL_H
+#define FCL_NARROWPHASE_DETAIL_TRIANGLEDISTANCE_INL_H
+
+#include "fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance.h"
+
+namespace fcl
+{
+
+namespace detail
+{
+
+//==============================================================================
+extern template
+class FCL_EXPORT TriangleDistance<double>;
+
+//==============================================================================
+template <typename S>
+void TriangleDistance<S>::segPoints(const Vector3<S>& P, const Vector3<S>& A, const Vector3<S>& Q, const Vector3<S>& B,
+                                 Vector3<S>& VEC, Vector3<S>& X, Vector3<S>& Y)
+{
+  Vector3<S> T;
+  S A_dot_A, B_dot_B, A_dot_B, A_dot_T, B_dot_T;
+  Vector3<S> TMP;
+
+  T = Q - P;
+  A_dot_A = A.dot(A);
+  B_dot_B = B.dot(B);
+  A_dot_B = A.dot(B);
+  A_dot_T = A.dot(T);
+  B_dot_T = B.dot(T);
+
+  // t parameterizes ray P,A
+  // u parameterizes ray Q,B
+
+  S t, u;
+
+  // compute t for the closest point on ray P,A to
+  // ray Q,B
+
+  S denom = A_dot_A*B_dot_B - A_dot_B*A_dot_B;
+
+  t = (A_dot_T*B_dot_B - B_dot_T*A_dot_B) / denom;
+
+  // clamp result so t is on the segment P,A
+
+  if((t < 0) || std::isnan(t)) t = 0; else if(t > 1) t = 1;
+
+  // find u for point on ray Q,B closest to point at t
+
+  u = (t*A_dot_B - B_dot_T) / B_dot_B;
+
+  // if u is on segment Q,B, t and u correspond to
+  // closest points, otherwise, clamp u, recompute and
+  // clamp t
+
+  if((u <= 0) || std::isnan(u))
+  {
+    Y = Q;
+
+    t = A_dot_T / A_dot_A;
+
+    if((t <= 0) || std::isnan(t))
+    {
+      X = P;
+      VEC = Q - P;
+    }
+    else if(t >= 1)
+    {
+      X = P + A;
+      VEC = Q - X;
+    }
+    else
+    {
+      X = P + A * t;
+      TMP = T.cross(A);
+      VEC = A.cross(TMP);
+    }
+  }
+  else if (u >= 1)
+  {
+    Y = Q + B;
+
+    t = (A_dot_B + A_dot_T) / A_dot_A;
+
+    if((t <= 0) || std::isnan(t))
+    {
+      X = P;
+      VEC = Y - P;
+    }
+    else if(t >= 1)
+    {
+      X = P + A;
+      VEC = Y - X;
+    }
+    else
+    {
+      X = P + A * t;
+      T = Y - P;
+      TMP = T.cross(A);
+      VEC= A.cross(TMP);
+    }
+  }
+  else
+  {
+    Y = Q + B * u;
+
+    if((t <= 0) || std::isnan(t))
+    {
+      X = P;
+      TMP = T.cross(B);
+      VEC = B.cross(TMP);
+    }
+    else if(t >= 1)
+    {
+      X = P + A;
+      T = Q - X;
+      TMP = T.cross(B);
+      VEC = B.cross(TMP);
+    }
+    else
+    {
+      X = P + A * t;
+      VEC = A.cross(B);
+      if(VEC.dot(T) < 0)
+      {
+        VEC = VEC * (-1);
+      }
+    }
+  }
+}
+
+//==============================================================================
+template <typename S>
+S TriangleDistance<S>::triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3], Vector3<S>& P, Vector3<S>& Q)
+{
+  // Compute vectors along the 6 sides
+
+  Vector3<S> Sv[3];
+  Vector3<S> Tv[3];
+  Vector3<S> VEC;
+
+  Sv[0] = T1[1] - T1[0];
+  Sv[1] = T1[2] - T1[1];
+  Sv[2] = T1[0] - T1[2];
+
+  Tv[0] = T2[1] - T2[0];
+  Tv[1] = T2[2] - T2[1];
+  Tv[2] = T2[0] - T2[2];
+
+  // For each edge pair, the vector connecting the closest points
+  // of the edges defines a slab (parallel planes at head and tail
+  // enclose the slab). If we can show that the off-edge vertex of
+  // each triangle is outside of the slab, then the closest points
+  // of the edges are the closest points for the triangles.
+  // Even if these tests fail, it may be helpful to know the closest
+  // points found, and whether the triangles were shown disjoint
+
+  Vector3<S> V;
+  Vector3<S> Z;
+  Vector3<S> minP = Vector3<S>::Zero();
+  Vector3<S> minQ = Vector3<S>::Zero();
+  S mindd;
+  int shown_disjoint = 0;
+
+  mindd = (T1[0] - T2[0]).squaredNorm() + 1; // Set first minimum safely high
+
+  for(int i = 0; i < 3; ++i)
+  {
+    for(int j = 0; j < 3; ++j)
+    {
+      // Find closest points on edges i & j, plus the
+      // vector (and distance squared) between these points
+      segPoints(T1[i], Sv[i], T2[j], Tv[j], VEC, P, Q);
+
+      V = Q - P;
+      S dd = V.dot(V);
+
+      // Verify this closest point pair only if the distance
+      // squared is less than the minimum found thus far.
+
+      if(dd <= mindd)
+      {
+        minP = P;
+        minQ = Q;
+        mindd = dd;
+
+        Z = T1[(i+2)%3] - P;
+        S a = Z.dot(VEC);
+        Z = T2[(j+2)%3] - Q;
+        S b = Z.dot(VEC);
+
+        if((a <= 0) && (b >= 0)) return sqrt(dd);
+
+        S p = V.dot(VEC);
+
+        if(a < 0) a = 0;
+        if(b > 0) b = 0;
+        if((p - a + b) > 0) shown_disjoint = 1;
+      }
+    }
+  }
+
+  // No edge pairs contained the closest points.
+  // either:
+  // 1. one of the closest points is a vertex, and the
+  //    other point is interior to a face.
+  // 2. the triangles are overlapping.
+  // 3. an edge of one triangle is parallel to the other's face. If
+  //    cases 1 and 2 are not true, then the closest points from the 9
+  //    edge pairs checks above can be taken as closest points for the
+  //    triangles.
+  // 4. possibly, the triangles were degenerate.  When the
+  //    triangle points are nearly colinear or coincident, one
+  //    of above tests might fail even though the edges tested
+  //    contain the closest points.
+
+  // First check for case 1
+
+  Vector3<S> Sn;
+  S Snl;
+
+  Sn = Sv[0].cross(Sv[1]); // Compute normal to T1 triangle
+  Snl = Sn.dot(Sn);        // Compute square of length of normal
+
+  // If cross product is long enough,
+
+  if(Snl > 1e-15)
+  {
+    // Get projection lengths of T2 points
+
+    Vector3<S> Tp;
+
+    V = T1[0] - T2[0];
+    Tp[0] = V.dot(Sn);
+
+    V = T1[0] - T2[1];
+    Tp[1] = V.dot(Sn);
+
+    V = T1[0] - T2[2];
+    Tp[2] = V.dot(Sn);
+
+    // If Sn is a separating direction,
+    // find point with smallest projection
+
+    int point = -1;
+    if((Tp[0] > 0) && (Tp[1] > 0) && (Tp[2] > 0))
+    {
+      if(Tp[0] < Tp[1]) point = 0; else point = 1;
+      if(Tp[2] < Tp[point]) point = 2;
+    }
+    else if((Tp[0] < 0) && (Tp[1] < 0) && (Tp[2] < 0))
+    {
+      if(Tp[0] > Tp[1]) point = 0; else point = 1;
+      if(Tp[2] > Tp[point]) point = 2;
+    }
+
+    // If Sn is a separating direction,
+
+    if(point >= 0)
+    {
+      shown_disjoint = 1;
+
+      // Test whether the point found, when projected onto the
+      // other triangle, lies within the face.
+
+      V = T2[point] - T1[0];
+      Z = Sn.cross(Sv[0]);
+      if(V.dot(Z) > 0)
+      {
+        V = T2[point] - T1[1];
+        Z = Sn.cross(Sv[1]);
+        if(V.dot(Z) > 0)
+        {
+          V = T2[point] - T1[2];
+          Z = Sn.cross(Sv[2]);
+          if(V.dot(Z) > 0)
+          {
+            // T[point] passed the test - it's a closest point for
+            // the T2 triangle; the other point is on the face of T1
+            P = T2[point] + Sn * (Tp[point] / Snl);
+            Q = T2[point];
+            return (P - Q).norm();
+          }
+        }
+      }
+    }
+  }
+
+  Vector3<S> Tn;
+  S Tnl;
+
+  Tn = Tv[0].cross(Tv[1]);
+  Tnl = Tn.dot(Tn);
+
+  if(Tnl > 1e-15)
+  {
+    Vector3<S> Sp;
+
+    V = T2[0] - T1[0];
+    Sp[0] = V.dot(Tn);
+
+    V = T2[0] - T1[1];
+    Sp[1] = V.dot(Tn);
+
+    V = T2[0] - T1[2];
+    Sp[2] = V.dot(Tn);
+
+    int point = -1;
+    if((Sp[0] > 0) && (Sp[1] > 0) && (Sp[2] > 0))
+    {
+      if(Sp[0] < Sp[1]) point = 0; else point = 1;
+      if(Sp[2] < Sp[point]) point = 2;
+    }
+    else if((Sp[0] < 0) && (Sp[1] < 0) && (Sp[2] < 0))
+    {
+      if(Sp[0] > Sp[1]) point = 0; else point = 1;
+      if(Sp[2] > Sp[point]) point = 2;
+    }
+
+    if(point >= 0)
+    {
+      shown_disjoint = 1;
+
+      V = T1[point] - T2[0];
+      Z = Tn.cross(Tv[0]);
+      if(V.dot(Z) > 0)
+      {
+        V = T1[point] - T2[1];
+        Z = Tn.cross(Tv[1]);
+        if(V.dot(Z) > 0)
+        {
+          V = T1[point] - T2[2];
+          Z = Tn.cross(Tv[2]);
+          if(V.dot(Z) > 0)
+          {
+            P = T1[point];
+            Q = T1[point] + Tn * (Sp[point] / Tnl);
+            return (P - Q).norm();
+          }
+        }
+      }
+    }
+  }
+
+  // Case 1 can't be shown.
+  // If one of these tests showed the triangles disjoint,
+  // we assume case 3 or 4, otherwise we conclude case 2,
+  // that the triangles overlap.
+
+  if(shown_disjoint)
+  {
+    P = minP;
+    Q = minQ;
+    return sqrt(mindd);
+  }
+  else return 0;
+}
+
+//==============================================================================
+template <typename S>
+S TriangleDistance<S>::triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
+                                       const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
+                                       Vector3<S>& P, Vector3<S>& Q)
+{
+  Vector3<S> U[3];
+  Vector3<S> T[3];
+  U[0] = S1; U[1] = S2; U[2] = S3;
+  T[0] = T1; T[1] = T2; T[2] = T3;
+
+  return triDistance(U, T, P, Q);
+}
+
+//==============================================================================
+template <typename S>
+S TriangleDistance<S>::triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3],
+                                       const Matrix3<S>& R, const Vector3<S>& Tl,
+                                       Vector3<S>& P, Vector3<S>& Q)
+{
+  Vector3<S> T_transformed[3];
+  T_transformed[0] = R * T2[0] + Tl;
+  T_transformed[1] = R * T2[1] + Tl;
+  T_transformed[2] = R * T2[2] + Tl;
+
+  return triDistance(T1, T_transformed, P, Q);
+}
+
+//==============================================================================
+template <typename S>
+S TriangleDistance<S>::triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3],
+                                       const Transform3<S>& tf,
+                                       Vector3<S>& P, Vector3<S>& Q)
+{
+  Vector3<S> T_transformed[3];
+  T_transformed[0] = tf * T2[0];
+  T_transformed[1] = tf * T2[1];
+  T_transformed[2] = tf * T2[2];
+
+  return triDistance(T1, T_transformed, P, Q);
+}
+
+//==============================================================================
+template <typename S>
+S TriangleDistance<S>::triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
+                                       const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
+                                       const Matrix3<S>& R, const Vector3<S>& Tl,
+                                       Vector3<S>& P, Vector3<S>& Q)
+{
+  Vector3<S> T1_transformed = R * T1 + Tl;
+  Vector3<S> T2_transformed = R * T2 + Tl;
+  Vector3<S> T3_transformed = R * T3 + Tl;
+  return triDistance(S1, S2, S3, T1_transformed, T2_transformed, T3_transformed, P, Q);
+}
+
+//==============================================================================
+template <typename S>
+S TriangleDistance<S>::triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
+                                       const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
+                                       const Transform3<S>& tf,
+                                       Vector3<S>& P, Vector3<S>& Q)
+{
+  Vector3<S> T1_transformed = tf * T1;
+  Vector3<S> T2_transformed = tf * T2;
+  Vector3<S> T3_transformed = tf * T3;
+  return triDistance(S1, S2, S3, T1_transformed, T2_transformed, T3_transformed, P, Q);
+}
+
+} // namespace detail
+} // namespace fcl
+
+#endif
diff --git a/include/fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance.h b/include/fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance.h
index cb4b2e6..ca83880 100644
--- a/include/fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance.h
+++ b/include/fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance.h
@@ -1,114 +1,114 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#ifndef FCL_NARROWPHASE_DETAIL_TRIANGLEDISTANCE_H
-#define FCL_NARROWPHASE_DETAIL_TRIANGLEDISTANCE_H
-
-#include "fcl/common/types.h"
-
-namespace fcl
-{
-
-namespace detail
-{
-
-/// @brief Triangle distance functions
-template <typename S>
-class FCL_EXPORT TriangleDistance
-{
-public:
-
-  /// @brief Returns closest points between an segment pair.
-  /// The first segment is P + t * A
-  /// The second segment is Q + t * B
-  /// X, Y are the closest points on the two segments
-  /// VEC is the vector between X and Y
-  static void segPoints(const Vector3<S>& P, const Vector3<S>& A, const Vector3<S>& Q, const Vector3<S>& B,
-                        Vector3<S>& VEC, Vector3<S>& X, Vector3<S>& Y);
-
-  /// @brief Compute the closest points on two triangles given their absolute coordinate, and returns the distance between them
-  /// T1 and T2 are two triangles
-  /// If the triangles are disjoint, P and Q give the closet points of T1 and T2 respectively. However,
-  /// if the triangles overlap, P and Q are basically a random pair of points from the triangles, not
-  /// coincident points on the intersection of the triangles, as might be expected.
-  static S triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3], Vector3<S>& P, Vector3<S>& Q);
-
-  static S triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
-                              const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
-                              Vector3<S>& P, Vector3<S>& Q);
-
-  /// @brief Compute the closest points on two triangles given the relative transform between them, and returns the distance between them
-  /// T1 and T2 are two triangles
-  /// If the triangles are disjoint, P and Q give the closet points of T1 and T2 respectively. However,
-  /// if the triangles overlap, P and Q are basically a random pair of points from the triangles, not
-  /// coincident points on the intersection of the triangles, as might be expected.
-  /// The returned P and Q are both in the coordinate of the first triangle's coordinate
-  static S triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3],
-                              const Matrix3<S>& R, const Vector3<S>& Tl,
-                              Vector3<S>& P, Vector3<S>& Q);
-
-  static S triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3],
-                              const Transform3<S>& tf,
-                              Vector3<S>& P, Vector3<S>& Q);
-
-  static S triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
-                              const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
-                              const Matrix3<S>& R, const Vector3<S>& Tl,
-                              Vector3<S>& P, Vector3<S>& Q);
-
-  static S triDistance(
-      const Vector3<S>& S1,
-      const Vector3<S>& S2,
-      const Vector3<S>& S3,
-      const Vector3<S>& T1,
-      const Vector3<S>& T2,
-      const Vector3<S>& T3,
-      const Transform3<S>& tf,
-      Vector3<S>& P,
-      Vector3<S>& Q);
-
-};
-
-using TriangleDistancef = TriangleDistance<float>;
-using TriangleDistanced = TriangleDistance<double>;
-
-} // namespace detail
-} // namespace fcl
-
-#include "fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance-inl.h"
-
-#endif
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#ifndef FCL_NARROWPHASE_DETAIL_TRIANGLEDISTANCE_H
+#define FCL_NARROWPHASE_DETAIL_TRIANGLEDISTANCE_H
+
+#include "fcl/common/types.h"
+
+namespace fcl
+{
+
+namespace detail
+{
+
+/// @brief Triangle distance functions
+template <typename S>
+class FCL_EXPORT TriangleDistance
+{
+public:
+
+  /// @brief Returns closest points between an segment pair.
+  /// The first segment is P + t * A
+  /// The second segment is Q + t * B
+  /// X, Y are the closest points on the two segments
+  /// VEC is the vector between X and Y
+  static void segPoints(const Vector3<S>& P, const Vector3<S>& A, const Vector3<S>& Q, const Vector3<S>& B,
+                        Vector3<S>& VEC, Vector3<S>& X, Vector3<S>& Y);
+
+  /// @brief Compute the closest points on two triangles given their absolute coordinate, and returns the distance between them
+  /// T1 and T2 are two triangles
+  /// If the triangles are disjoint, P and Q give the closet points of T1 and T2 respectively. However,
+  /// if the triangles overlap, P and Q are basically a random pair of points from the triangles, not
+  /// coincident points on the intersection of the triangles, as might be expected.
+  static S triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3], Vector3<S>& P, Vector3<S>& Q);
+
+  static S triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
+                              const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
+                              Vector3<S>& P, Vector3<S>& Q);
+
+  /// @brief Compute the closest points on two triangles given the relative transform between them, and returns the distance between them
+  /// T1 and T2 are two triangles
+  /// If the triangles are disjoint, P and Q give the closet points of T1 and T2 respectively. However,
+  /// if the triangles overlap, P and Q are basically a random pair of points from the triangles, not
+  /// coincident points on the intersection of the triangles, as might be expected.
+  /// The returned P and Q are both in the coordinate of the first triangle's coordinate
+  static S triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3],
+                              const Matrix3<S>& R, const Vector3<S>& Tl,
+                              Vector3<S>& P, Vector3<S>& Q);
+
+  static S triDistance(const Vector3<S> T1[3], const Vector3<S> T2[3],
+                              const Transform3<S>& tf,
+                              Vector3<S>& P, Vector3<S>& Q);
+
+  static S triDistance(const Vector3<S>& S1, const Vector3<S>& S2, const Vector3<S>& S3,
+                              const Vector3<S>& T1, const Vector3<S>& T2, const Vector3<S>& T3,
+                              const Matrix3<S>& R, const Vector3<S>& Tl,
+                              Vector3<S>& P, Vector3<S>& Q);
+
+  static S triDistance(
+      const Vector3<S>& S1,
+      const Vector3<S>& S2,
+      const Vector3<S>& S3,
+      const Vector3<S>& T1,
+      const Vector3<S>& T2,
+      const Vector3<S>& T3,
+      const Transform3<S>& tf,
+      Vector3<S>& P,
+      Vector3<S>& Q);
+
+};
+
+using TriangleDistancef = TriangleDistance<float>;
+using TriangleDistanced = TriangleDistance<double>;
+
+} // namespace detail
+} // namespace fcl
+
+#include "fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance-inl.h"
+
+#endif
diff --git a/include/fcl/narrowphase/detail/traversal/collision/intersect-inl.h b/include/fcl/narrowphase/detail/traversal/collision/intersect-inl.h
index 4c9d606..ceea97f 100644
--- a/include/fcl/narrowphase/detail/traversal/collision/intersect-inl.h
+++ b/include/fcl/narrowphase/detail/traversal/collision/intersect-inl.h
@@ -1,1146 +1,1146 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#ifndef FCL_NARROWPHASE_DETAIL_INTERSECT_INL_H
-#define FCL_NARROWPHASE_DETAIL_INTERSECT_INL_H
-
-#include "fcl/narrowphase/detail/traversal/collision/intersect.h"
-
-namespace fcl
-{
-
-namespace detail
-{
-
-//==============================================================================
-extern template
-class FCL_EXPORT Intersect<double>;
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::isZero(S v)
-{
-  return (v < getNearZeroThreshold()) && (v > -getNearZeroThreshold());
-}
-
-//==============================================================================
-/// @brief data: only used for EE, return the intersect point
-template <typename S>
-bool Intersect<S>::solveCubicWithIntervalNewton(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                             const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
-                                             S& l, S& r, bool bVF, S coeffs[], Vector3<S>* data)
-{
-  S v2[2]= {l*l,r*r};
-  S v[2]= {l,r};
-  S r_backup;
-
-  unsigned char min3, min2, min1, max3, max2, max1;
-
-  min3= *((unsigned char*)&coeffs[3]+7)>>7; max3=min3^1;
-  min2= *((unsigned char*)&coeffs[2]+7)>>7; max2=min2^1;
-  min1= *((unsigned char*)&coeffs[1]+7)>>7; max1=min1^1;
-
-  // bound the cubic
-
-  S minor = coeffs[3]*v2[min3]*v[min3]+coeffs[2]*v2[min2]+coeffs[1]*v[min1]+coeffs[0];
-  S major = coeffs[3]*v2[max3]*v[max3]+coeffs[2]*v2[max2]+coeffs[1]*v[max1]+coeffs[0];
-
-  if(major<0) return false;
-  if(minor>0) return false;
-
-  // starting here, the bounds have opposite values
-  S m = 0.5 * (r + l);
-
-  // bound the derivative
-  S dminor = 3.0*coeffs[3]*v2[min3]+2.0*coeffs[2]*v[min2]+coeffs[1];
-  S dmajor = 3.0*coeffs[3]*v2[max3]+2.0*coeffs[2]*v[max2]+coeffs[1];
-
-  if((dminor > 0)||(dmajor < 0)) // we can use Newton
-  {
-    S m2 = m*m;
-    S fm = coeffs[3]*m2*m+coeffs[2]*m2+coeffs[1]*m+coeffs[0];
-    S nl = m;
-    S nu = m;
-    if(fm>0)
-    {
-      nl-=(fm/dminor);
-      nu-=(fm/dmajor);
-    }
-    else
-    {
-      nu-=(fm/dminor);
-      nl-=(fm/dmajor);
-    }
-
-    //intersect with [l,r]
-
-    if(nl>r) return false;
-    if(nu<l) return false;
-    if(nl>l)
-    {
-      if(nu<r) { l=nl; r=nu; m=0.5*(l+r); }
-      else { l=nl; m=0.5*(l+r); }
-    }
-    else
-    {
-      if(nu<r) { r=nu; m=0.5*(l+r); }
-    }
-  }
-
-  // sufficient temporal resolution, check root validity
-  if((r-l)< getCcdResolution())
-  {
-    if(bVF)
-      return checkRootValidity_VF(a0, b0, c0, d0, va, vb, vc, vd, r);
-    else
-      return checkRootValidity_EE(a0, b0, c0, d0, va, vb, vc, vd, r, data);
-  }
-
-  r_backup = r, r = m;
-  if(solveCubicWithIntervalNewton(a0, b0, c0, d0, va, vb, vc, vd, l, r, bVF, coeffs, data))
-    return true;
-
-  l = m, r = r_backup;
-  return solveCubicWithIntervalNewton(a0, b0, c0, d0, va, vb, vc, vd, l, r, bVF, coeffs, data);
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::insideTriangle(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>&p)
-{
-  Vector3<S> ab = b - a;
-  Vector3<S> ac = c - a;
-  Vector3<S> n = ab.cross(ac);
-
-  Vector3<S> pa = a - p;
-  Vector3<S> pb = b - p;
-  Vector3<S> pc = c - p;
-
-  if((pb.cross(pc)).dot(n) < -getEpsilon()) return false;
-  if((pc.cross(pa)).dot(n) < -getEpsilon()) return false;
-  if((pa.cross(pb)).dot(n) < -getEpsilon()) return false;
-
-  return true;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::insideLineSegment(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& p)
-{
-  return (p - a).dot(p - b) <= 0;
-}
-
-//==============================================================================
-/// @brief Calculate the line segment papb that is the shortest route between
-/// two lines p1p2 and p3p4. Calculate also the values of mua and mub where
-///    pa = p1 + mua (p2 - p1)
-///    pb = p3 + mub (p4 - p3)
-/// Return FALSE if no solution exists.
-template <typename S>
-bool Intersect<S>::linelineIntersect(const Vector3<S>& p1, const Vector3<S>& p2, const Vector3<S>& p3, const Vector3<S>& p4,
-                                  Vector3<S>* pa, Vector3<S>* pb, S* mua, S* mub)
-{
-  Vector3<S> p31 = p1 - p3;
-  Vector3<S> p34 = p4 - p3;
-  if(fabs(p34[0]) < getEpsilon() && fabs(p34[1]) < getEpsilon() && fabs(p34[2]) < getEpsilon())
-    return false;
-
-  Vector3<S> p12 = p2 - p1;
-  if(fabs(p12[0]) < getEpsilon() && fabs(p12[1]) < getEpsilon() && fabs(p12[2]) < getEpsilon())
-    return false;
-
-  S d3134 = p31.dot(p34);
-  S d3412 = p34.dot(p12);
-  S d3112 = p31.dot(p12);
-  S d3434 = p34.dot(p34);
-  S d1212 = p12.dot(p12);
-
-  S denom = d1212 * d3434 - d3412 * d3412;
-  if(fabs(denom) < getEpsilon())
-    return false;
-  S numer = d3134 * d3412 - d3112 * d3434;
-
-  *mua = numer / denom;
-  if(*mua < 0 || *mua > 1)
-    return false;
-
-  *mub = (d3134 + d3412 * (*mua)) / d3434;
-  if(*mub < 0 || *mub > 1)
-    return false;
-
-  *pa = p1 + p12 * (*mua);
-  *pb = p3 + p34 * (*mub);
-  return true;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::checkRootValidity_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
-                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vp,
-                                     S t)
-{
-  return insideTriangle(a0 + va * t, b0 + vb * t, c0 + vc * t, p0 + vp * t);
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::checkRootValidity_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
-                                     S t, Vector3<S>* q_i)
-{
-  Vector3<S> a = a0 + va * t;
-  Vector3<S> b = b0 + vb * t;
-  Vector3<S> c = c0 + vc * t;
-  Vector3<S> d = d0 + vd * t;
-  Vector3<S> p1, p2;
-  S t_ab, t_cd;
-  if(linelineIntersect(a, b, c, d, &p1, &p2, &t_ab, &t_cd))
-  {
-    if(q_i) *q_i = p1;
-    return true;
-  }
-
-  return false;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::checkRootValidity_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
-                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp,
-                                     S t)
-{
-  return insideLineSegment(a0 + va * t, b0 + vb * t, p0 + vp * t);
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::solveSquare(S a, S b, S c,
-                            const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                            const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
-                            bool bVF,
-                            S* ret)
-{
-  S discriminant = b * b - 4 * a * c;
-  if(discriminant < 0)
-    return false;
-
-  S sqrt_dis = sqrt(discriminant);
-  S r1 = (-b + sqrt_dis) / (2 * a);
-  bool v1 = (r1 >= 0.0 && r1 <= 1.0) ? ((bVF) ? checkRootValidity_VF(a0, b0, c0, d0, va, vb, vc, vd, r1) : checkRootValidity_EE(a0, b0, c0, d0, va, vb, vc, vd, r1)) : false;
-
-  S r2 = (-b - sqrt_dis) / (2 * a);
-  bool v2 = (r2 >= 0.0 && r2 <= 1.0) ? ((bVF) ? checkRootValidity_VF(a0, b0, c0, d0, va, vb, vc, vd, r2) : checkRootValidity_EE(a0, b0, c0, d0, va, vb, vc, vd, r2)) : false;
-
-  if(v1 && v2)
-  {
-    *ret = (r1 > r2) ? r2 : r1;
-    return true;
-  }
-  if(v1)
-  {
-    *ret = r1;
-    return true;
-  }
-  if(v2)
-  {
-    *ret = r2;
-    return true;
-  }
-
-  return false;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::solveSquare(S a, S b, S c,
-                            const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
-                            const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp)
-{
-  if(isZero(a))
-  {
-    S t = -c/b;
-    return (t >= 0 && t <= 1) ? checkRootValidity_VE(a0, b0, p0, va, vb, vp, t) : false;
-  }
-
-  S discriminant = b*b-4*a*c;
-  if(discriminant < 0)
-    return false;
-
-  S sqrt_dis = sqrt(discriminant);
-
-  S r1 = (-b+sqrt_dis) / (2 * a);
-  bool v1 = (r1 >= 0.0 && r1 <= 1.0) ? checkRootValidity_VE(a0, b0, p0, va, vb, vp, r1) : false;
-  if(v1) return true;
-
-  S r2 = (-b-sqrt_dis) / (2 * a);
-  bool v2 = (r2 >= 0.0 && r2 <= 1.0) ? checkRootValidity_VE(a0, b0, p0, va, vb, vp, r2) : false;
-  return v2;
-}
-
-//==============================================================================
-/// @brief Compute the cubic coefficients for VF case
-/// See Paper "Interactive Continuous Collision Detection between Deformable Models using Connectivity-Based Culling", Equation 1.
-template <typename S>
-void Intersect<S>::computeCubicCoeff_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
-                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vp,
-                                     S* a, S* b, S* c, S* d)
-{
-  Vector3<S> vavb = vb - va;
-  Vector3<S> vavc = vc - va;
-  Vector3<S> vavp = vp - va;
-  Vector3<S> a0b0 = b0 - a0;
-  Vector3<S> a0c0 = c0 - a0;
-  Vector3<S> a0p0 = p0 - a0;
-
-  Vector3<S> vavb_cross_vavc = vavb.cross(vavc);
-  Vector3<S> vavb_cross_a0c0 = vavb.cross(a0c0);
-  Vector3<S> a0b0_cross_vavc = a0b0.cross(vavc);
-  Vector3<S> a0b0_cross_a0c0 = a0b0.cross(a0c0);
-
-  *a = vavp.dot(vavb_cross_vavc);
-  *b = a0p0.dot(vavb_cross_vavc) + vavp.dot(vavb_cross_a0c0 + a0b0_cross_vavc);
-  *c = vavp.dot(a0b0_cross_a0c0) + a0p0.dot(vavb_cross_a0c0 + a0b0_cross_vavc);
-  *d = a0p0.dot(a0b0_cross_a0c0);
-}
-
-//==============================================================================
-template <typename S>
-void Intersect<S>::computeCubicCoeff_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
-                                     S* a, S* b, S* c, S* d)
-{
-  Vector3<S> vavb = vb - va;
-  Vector3<S> vcvd = vd - vc;
-  Vector3<S> vavc = vc - va;
-  Vector3<S> c0d0 = d0 - c0;
-  Vector3<S> a0b0 = b0 - a0;
-  Vector3<S> a0c0 = c0 - a0;
-  Vector3<S> vavb_cross_vcvd = vavb.cross(vcvd);
-  Vector3<S> vavb_cross_c0d0 = vavb.cross(c0d0);
-  Vector3<S> a0b0_cross_vcvd = a0b0.cross(vcvd);
-  Vector3<S> a0b0_cross_c0d0 = a0b0.cross(c0d0);
-
-  *a = vavc.dot(vavb_cross_vcvd);
-  *b = a0c0.dot(vavb_cross_vcvd) + vavc.dot(vavb_cross_c0d0 + a0b0_cross_vcvd);
-  *c = vavc.dot(a0b0_cross_c0d0) + a0c0.dot(vavb_cross_c0d0 + a0b0_cross_vcvd);
-  *d = a0c0.dot(a0b0_cross_c0d0);
-}
-
-//==============================================================================
-template <typename S>
-void Intersect<S>::computeCubicCoeff_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
-                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp,
-                                     const Vector3<S>& L,
-                                     S* a, S* b, S* c)
-{
-  Vector3<S> vbva = va - vb;
-  Vector3<S> vbvp = vp - vb;
-  Vector3<S> b0a0 = a0 - b0;
-  Vector3<S> b0p0 = p0 - b0;
-
-  Vector3<S> L_cross_vbvp = L.cross(vbvp);
-  Vector3<S> L_cross_b0p0 = L.cross(b0p0);
-
-  *a = L_cross_vbvp.dot(vbva);
-  *b = L_cross_vbvp.dot(b0a0) + L_cross_b0p0.dot(vbva);
-  *c = L_cross_b0p0.dot(b0a0);
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::intersect_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
-                             const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& p1,
-                             S* collision_time, Vector3<S>* p_i, bool useNewton)
-{
-  *collision_time = 2.0;
-
-  Vector3<S> vp, va, vb, vc;
-  vp = p1 - p0;
-  va = a1 - a0;
-  vb = b1 - b0;
-  vc = c1 - c0;
-
-  S a, b, c, d;
-  computeCubicCoeff_VF(a0, b0, c0, p0, va, vb, vc, vp, &a, &b, &c, &d);
-
-  if(isZero(a) && isZero(b) && isZero(c) && isZero(d))
-  {
-    return false;
-  }
-
-
-  /// if(isZero(a))
-  /// {
-  ///   return solveSquare(b, c, d, a0, b0, c0, p0, va, vb, vc, vp, true, collision_time);
-  /// }
-
-  S coeffs[4];
-  coeffs[3] = a, coeffs[2] = b, coeffs[1] = c, coeffs[0] = d;
-
-  if(useNewton)
-  {
-    S l = 0;
-    S r = 1;
-
-    if(solveCubicWithIntervalNewton(a0, b0, c0, p0, va, vb, vc, vp, l, r, true, coeffs))
-    {
-      *collision_time = 0.5 * (l + r);
-    }
-  }
-  else
-  {
-    S roots[3];
-    int num = PolySolver<S>::solveCubic(coeffs, roots);
-    for(int i = 0; i < num; ++i)
-    {
-      S r = roots[i];
-      if(r < 0 || r > 1) continue;
-      if(checkRootValidity_VF(a0, b0, c0, p0, va, vb, vc, vp, r))
-      {
-        *collision_time = r;
-        break;
-      }
-    }
-  }
-
-  if(*collision_time > 1)
-  {
-    return false;
-  }
-
-  *p_i = vp * (*collision_time) + p0;
-  return true;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::intersect_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                             const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1,
-                             S* collision_time, Vector3<S>* p_i, bool useNewton)
-{
-  *collision_time = 2.0;
-
-  Vector3<S> va, vb, vc, vd;
-  va = a1 - a0;
-  vb = b1 - b0;
-  vc = c1 - c0;
-  vd = d1 - d0;
-
-  S a, b, c, d;
-  computeCubicCoeff_EE(a0, b0, c0, d0, va, vb, vc, vd, &a, &b, &c, &d);
-
-  if(isZero(a) && isZero(b) && isZero(c) && isZero(d))
-  {
-    return false;
-  }
-
-  /// if(isZero(a))
-  /// {
-  ///   return solveSquare(b, c, d, a0, b0, c0, d0, va, vb, vc, vd, collision_time, false);
-  /// }
-
-
-  S coeffs[4];
-  coeffs[3] = a, coeffs[2] = b, coeffs[1] = c, coeffs[0] = d;
-
-  if(useNewton)
-  {
-    S l = 0;
-    S r = 1;
-
-    if(solveCubicWithIntervalNewton(a0, b0, c0, d0, va, vb, vc, vd, l, r, false, coeffs, p_i))
-    {
-      *collision_time  = (l + r) * 0.5;
-    }
-  }
-  else
-  {
-    S roots[3];
-    int num = PolySolver<S>::solveCubic(coeffs, roots);
-    for(int i = 0; i < num; ++i)
-    {
-      S r = roots[i];
-      if(r < 0 || r > 1) continue;
-
-      if(checkRootValidity_EE(a0, b0, c0, d0, va, vb, vc, vd, r, p_i))
-      {
-        *collision_time = r;
-        break;
-      }
-    }
-  }
-
-  if(*collision_time > 1)
-  {
-    return false;
-  }
-
-  return true;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::intersect_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
-                             const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& p1,
-                             const Vector3<S>& L)
-{
-  Vector3<S> va, vb, vp;
-  va = a1 - a0;
-  vb = b1 - b0;
-  vp = p1 - p0;
-
-  S a, b, c;
-  computeCubicCoeff_VE(a0, b0, p0, va, vb, vp, L, &a, &b, &c);
-
-  if(isZero(a) && isZero(b) && isZero(c))
-    return true;
-
-  return solveSquare(a, b, c, a0, b0, p0, va, vb, vp);
-
-}
-
-//==============================================================================
-/// @brief Prefilter for intersection, works for both VF and EE
-template <typename S>
-bool Intersect<S>::intersectPreFiltering(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                      const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1)
-{
-  Vector3<S> n0 = (b0 - a0).cross(c0 - a0);
-  Vector3<S> n1 = (b1 - a1).cross(c1 - a1);
-  Vector3<S> a0a1 = a1 - a0;
-  Vector3<S> b0b1 = b1 - b0;
-  Vector3<S> c0c1 = c1 - c0;
-  Vector3<S> delta = (b0b1 - a0a1).cross(c0c1 - a0a1);
-  Vector3<S> nx = (n0 + n1 - delta) * 0.5;
-
-  Vector3<S> a0d0 = d0 - a0;
-  Vector3<S> a1d1 = d1 - a1;
-
-  S A = n0.dot(a0d0);
-  S B = n1.dot(a1d1);
-  S C = nx.dot(a0d0);
-  S D = nx.dot(a1d1);
-  S E = n1.dot(a0d0);
-  S F = n0.dot(a1d1);
-
-  if(A > 0 && B > 0 && (2*C +F) > 0 && (2*D+E) > 0)
-    return false;
-  if(A < 0 && B < 0 && (2*C +F) < 0 && (2*D+E) < 0)
-    return false;
-
-  return true;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::intersect_VF_filtered(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
-                                      const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& p1,
-                                      S* collision_time, Vector3<S>* p_i, bool useNewton)
-{
-  if(intersectPreFiltering(a0, b0, c0, p0, a1, b1, c1, p1))
-  {
-    return intersect_VF(a0, b0, c0, p0, a1, b1, c1, p1, collision_time, p_i, useNewton);
-  }
-  else
-    return false;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::intersect_EE_filtered(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                      const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1,
-                                      S* collision_time, Vector3<S>* p_i, bool useNewton)
-{
-  if(intersectPreFiltering(a0, b0, c0, d0, a1, b1, c1, d1))
-  {
-    return intersect_EE(a0, b0, c0, d0, a1, b1, c1, d1, collision_time, p_i, useNewton);
-  }
-  else
-    return false;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::intersect_Triangle(
-    const Vector3<S>& P1,
-    const Vector3<S>& P2,
-    const Vector3<S>& P3,
-    const Vector3<S>& Q1,
-    const Vector3<S>& Q2,
-    const Vector3<S>& Q3,
-    const Matrix3<S>& R,
-    const Vector3<S>& T,
-    Vector3<S>* contact_points,
-    unsigned int* num_contact_points,
-    S* penetration_depth,
-    Vector3<S>* normal)
-{
-  Vector3<S> Q1_ = R * Q1 + T;
-  Vector3<S> Q2_ = R * Q2 + T;
-  Vector3<S> Q3_ = R * Q3 + T;
-
-  return intersect_Triangle(P1, P2, P3, Q1_, Q2_, Q3_, contact_points, num_contact_points, penetration_depth, normal);
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::intersect_Triangle(
-    const Vector3<S>& P1,
-    const Vector3<S>& P2,
-    const Vector3<S>& P3,
-    const Vector3<S>& Q1,
-    const Vector3<S>& Q2,
-    const Vector3<S>& Q3,
-    const Transform3<S>& tf,
-    Vector3<S>* contact_points,
-    unsigned int* num_contact_points,
-    S* penetration_depth,
-    Vector3<S>* normal)
-{
-  Vector3<S> Q1_ = tf * Q1;
-  Vector3<S> Q2_ = tf * Q2;
-  Vector3<S> Q3_ = tf * Q3;
-
-  return intersect_Triangle(P1, P2, P3, Q1_, Q2_, Q3_, contact_points, num_contact_points, penetration_depth, normal);
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::intersect_Triangle_ODE_style(
-    const Vector3<S>& P1, const Vector3<S>& P2, const Vector3<S>& P3,
-    const Vector3<S>& Q1, const Vector3<S>& Q2, const Vector3<S>& Q3,
-    Vector3<S>* contact_points,
-    unsigned int* num_contact_points,
-    S* penetration_depth,
-    Vector3<S>* normal)
-{
-  Vector3<S> n1;
-  S t1;
-  bool b1 = buildTrianglePlane(P1, P2, P3, &n1, &t1);
-  if(!b1) return false;
-
-  Vector3<S> n2;
-  S t2;
-  bool b2 = buildTrianglePlane(Q1, Q2, Q3, &n2, &t2);
-  if(!b2) return false;
-
-  if(sameSideOfPlane(P1, P2, P3, n2, t2))
-    return false;
-
-  if(sameSideOfPlane(Q1, Q2, Q3, n1, t1))
-    return false;
-
-  Vector3<S> clipped_points1[getMaxTriangleClips()];
-  unsigned int num_clipped_points1 = 0;
-  Vector3<S> clipped_points2[getMaxTriangleClips()];
-  unsigned int num_clipped_points2 = 0;
-
-  Vector3<S> deepest_points1[getMaxTriangleClips()];
-  unsigned int num_deepest_points1 = 0;
-  Vector3<S> deepest_points2[getMaxTriangleClips()];
-  unsigned int num_deepest_points2 = 0;
-  S penetration_depth1 = -1, penetration_depth2 = -1;
-
-  clipTriangleByTriangleAndEdgePlanes(Q1, Q2, Q3, P1, P2, P3, n1, t1, clipped_points2, &num_clipped_points2);
-
-  if(num_clipped_points2 == 0)
-    return false;
-
-  computeDeepestPoints(clipped_points2, num_clipped_points2, n1, t1, &penetration_depth2, deepest_points2, &num_deepest_points2);
-  if(num_deepest_points2 == 0)
-    return false;
-
-  clipTriangleByTriangleAndEdgePlanes(P1, P2, P3, Q1, Q2, Q3, n2, t2, clipped_points1, &num_clipped_points1);
-  if(num_clipped_points1 == 0)
-    return false;
-
-  computeDeepestPoints(clipped_points1, num_clipped_points1, n2, t2, &penetration_depth1, deepest_points1, &num_deepest_points1);
-  if(num_deepest_points1 == 0)
-    return false;
-
-
-  /// Return contact information
-  if(contact_points && num_contact_points && penetration_depth && normal)
-  {
-    if(penetration_depth1 > penetration_depth2)
-    {
-      *num_contact_points = num_deepest_points2;
-      for(unsigned int i = 0; i < num_deepest_points2; ++i)
-      {
-        contact_points[i] = deepest_points2[i];
-      }
-
-      *normal = n1;
-      *penetration_depth = penetration_depth2;
-    }
-    else
-    {
-      *num_contact_points = num_deepest_points1;
-      for(unsigned int i = 0; i < num_deepest_points1; ++i)
-      {
-        contact_points[i] = deepest_points1[i];
-      }
-
-      *normal = -n2;
-      *penetration_depth = penetration_depth1;
-    }
-  }
-
-  return true;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::intersect_Triangle(
-    const Vector3<S>& P1, const Vector3<S>& P2, const Vector3<S>& P3,
-    const Vector3<S>& Q1, const Vector3<S>& Q2, const Vector3<S>& Q3,
-    Vector3<S>* contact_points,
-    unsigned int* num_contact_points,
-    S* penetration_depth,
-    Vector3<S>* normal)
-{
-  Vector3<S> p1 = P1 - P1;
-  Vector3<S> p2 = P2 - P1;
-  Vector3<S> p3 = P3 - P1;
-  Vector3<S> q1 = Q1 - P1;
-  Vector3<S> q2 = Q2 - P1;
-  Vector3<S> q3 = Q3 - P1;
-
-  Vector3<S> e1 = p2 - p1;
-  Vector3<S> e2 = p3 - p2;
-  Vector3<S> n1 = e1.cross(e2);
-  if (!project6(n1, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> f1 = q2 - q1;
-  Vector3<S> f2 = q3 - q2;
-  Vector3<S> m1 = f1.cross(f2);
-  if (!project6(m1, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> ef11 = e1.cross(f1);
-  if (!project6(ef11, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> ef12 = e1.cross(f2);
-  if (!project6(ef12, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> f3 = q1 - q3;
-  Vector3<S> ef13 = e1.cross(f3);
-  if (!project6(ef13, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> ef21 = e2.cross(f1);
-  if (!project6(ef21, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> ef22 = e2.cross(f2);
-  if (!project6(ef22, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> ef23 = e2.cross(f3);
-  if (!project6(ef23, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> e3 = p1 - p3;
-  Vector3<S> ef31 = e3.cross(f1);
-  if (!project6(ef31, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> ef32 = e3.cross(f2);
-  if (!project6(ef32, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> ef33 = e3.cross(f3);
-  if (!project6(ef33, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> g1 = e1.cross(n1);
-  if (!project6(g1, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> g2 = e2.cross(n1);
-  if (!project6(g2, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> g3 = e3.cross(n1);
-  if (!project6(g3, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> h1 = f1.cross(m1);
-  if (!project6(h1, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> h2 = f2.cross(m1);
-  if (!project6(h2, p1, p2, p3, q1, q2, q3)) return false;
-
-  Vector3<S> h3 = f3.cross(m1);
-  if (!project6(h3, p1, p2, p3, q1, q2, q3)) return false;
-
-  if(contact_points && num_contact_points && penetration_depth && normal)
-  {
-    Vector3<S> n1, n2;
-    S t1, t2;
-    buildTrianglePlane(P1, P2, P3, &n1, &t1);
-    buildTrianglePlane(Q1, Q2, Q3, &n2, &t2);
-
-    Vector3<S> deepest_points1[3];
-    unsigned int num_deepest_points1 = 0;
-    Vector3<S> deepest_points2[3];
-    unsigned int num_deepest_points2 = 0;
-    S penetration_depth1, penetration_depth2;
-
-    Vector3<S> P[3] = {P1, P2, P3};
-    Vector3<S> Q[3] = {Q1, Q2, Q3};
-
-    computeDeepestPoints(Q, 3, n1, t1, &penetration_depth2, deepest_points2, &num_deepest_points2);
-    computeDeepestPoints(P, 3, n2, t2, &penetration_depth1, deepest_points1, &num_deepest_points1);
-
-
-    if(penetration_depth1 > penetration_depth2)
-    {
-      *num_contact_points = std::min(num_deepest_points2, (unsigned int)2);
-      for(unsigned int i = 0; i < *num_contact_points; ++i)
-      {
-        contact_points[i] = deepest_points2[i];
-      }
-
-      *normal = n1;
-      *penetration_depth = penetration_depth2;
-    }
-    else
-    {
-      *num_contact_points = std::min(num_deepest_points1, (unsigned int)2);
-      for(unsigned int i = 0; i < *num_contact_points; ++i)
-      {
-        contact_points[i] = deepest_points1[i];
-      }
-
-      *normal = -n2;
-      *penetration_depth = penetration_depth1;
-    }
-  }
-
-  return true;
-}
-
-//==============================================================================
-template <typename S>
-void Intersect<S>::computeDeepestPoints(Vector3<S>* clipped_points, unsigned int num_clipped_points, const Vector3<S>& n, S t, S* penetration_depth, Vector3<S>* deepest_points, unsigned int* num_deepest_points)
-{
-  *num_deepest_points = 0;
-  S max_depth = -std::numeric_limits<S>::max();
-  unsigned int num_deepest_points_ = 0;
-  unsigned int num_neg = 0;
-  unsigned int num_pos = 0;
-  unsigned int num_zero = 0;
-
-  for(unsigned int i = 0; i < num_clipped_points; ++i)
-  {
-    S dist = -distanceToPlane(n, t, clipped_points[i]);
-    if(dist > getEpsilon()) num_pos++;
-    else if(dist < -getEpsilon()) num_neg++;
-    else num_zero++;
-    if(dist > max_depth)
-    {
-      max_depth = dist;
-      num_deepest_points_ = 1;
-      deepest_points[num_deepest_points_ - 1] = clipped_points[i];
-    }
-    else if(dist + 1e-6 >= max_depth)
-    {
-      num_deepest_points_++;
-      deepest_points[num_deepest_points_ - 1] = clipped_points[i];
-    }
-  }
-
-  if(max_depth < -getEpsilon())
-    num_deepest_points_ = 0;
-
-  if(num_zero == 0 && ((num_neg == 0) || (num_pos == 0)))
-    num_deepest_points_ = 0;
-
-  *penetration_depth = max_depth;
-  *num_deepest_points = num_deepest_points_;
-}
-
-//==============================================================================
-template <typename S>
-void Intersect<S>::clipTriangleByTriangleAndEdgePlanes(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3,
-                                                    const Vector3<S>& t1, const Vector3<S>& t2, const Vector3<S>& t3,
-                                                    const Vector3<S>& tn, S to,
-                                                    Vector3<S> clipped_points[], unsigned int* num_clipped_points,
-                                                    bool clip_triangle)
-{
-  *num_clipped_points = 0;
-  Vector3<S> temp_clip[getMaxTriangleClips()];
-  Vector3<S> temp_clip2[getMaxTriangleClips()];
-  unsigned int num_temp_clip = 0;
-  unsigned int num_temp_clip2 = 0;
-  Vector3<S> v[3] = {v1, v2, v3};
-
-  Vector3<S> plane_n;
-  S plane_dist;
-
-  if(buildEdgePlane(t1, t2, tn, &plane_n, &plane_dist))
-  {
-    clipPolygonByPlane(v, 3, plane_n, plane_dist, temp_clip, &num_temp_clip);
-    if(num_temp_clip > 0)
-    {
-      if(buildEdgePlane(t2, t3, tn, &plane_n, &plane_dist))
-      {
-        clipPolygonByPlane(temp_clip, num_temp_clip, plane_n, plane_dist, temp_clip2, &num_temp_clip2);
-        if(num_temp_clip2 > 0)
-        {
-          if(buildEdgePlane(t3, t1, tn, &plane_n, &plane_dist))
-          {
-            if(clip_triangle)
-            {
-              num_temp_clip = 0;
-              clipPolygonByPlane(temp_clip2, num_temp_clip2, plane_n, plane_dist, temp_clip, &num_temp_clip);
-              if(num_temp_clip > 0)
-              {
-                clipPolygonByPlane(temp_clip, num_temp_clip, tn, to, clipped_points, num_clipped_points);
-              }
-            }
-            else
-            {
-              clipPolygonByPlane(temp_clip2, num_temp_clip2, plane_n, plane_dist, clipped_points, num_clipped_points);
-            }
-          }
-        }
-      }
-    }
-  }
-}
-
-//==============================================================================
-template <typename S>
-void Intersect<S>::clipPolygonByPlane(Vector3<S>* polygon_points, unsigned int num_polygon_points, const Vector3<S>& n, S t, Vector3<S> clipped_points[], unsigned int* num_clipped_points)
-{
-  *num_clipped_points = 0;
-
-  unsigned int num_clipped_points_ = 0;
-  unsigned int vi;
-  unsigned int prev_classify = 2;
-  unsigned int classify;
-  for(unsigned int i = 0; i <= num_polygon_points; ++i)
-  {
-    vi = (i % num_polygon_points);
-    S d = distanceToPlane(n, t, polygon_points[i]);
-    classify = ((d > getEpsilon()) ? 1 : 0);
-    if(classify == 0)
-    {
-      if(prev_classify == 1)
-      {
-        if(num_clipped_points_ < getMaxTriangleClips())
-        {
-          Vector3<S> tmp;
-          clipSegmentByPlane(polygon_points[i - 1], polygon_points[vi], n, t, &tmp);
-          if(num_clipped_points_ > 0)
-          {
-            if((tmp - clipped_points[num_clipped_points_ - 1]).squaredNorm() > getEpsilon())
-            {
-              clipped_points[num_clipped_points_] = tmp;
-              num_clipped_points_++;
-            }
-          }
-          else
-          {
-            clipped_points[num_clipped_points_] = tmp;
-            num_clipped_points_++;
-          }
-        }
-      }
-
-      if(num_clipped_points_ < getMaxTriangleClips() && i < num_polygon_points)
-      {
-        clipped_points[num_clipped_points_] = polygon_points[vi];
-        num_clipped_points_++;
-      }
-    }
-    else
-    {
-      if(prev_classify == 0)
-      {
-        if(num_clipped_points_ < getMaxTriangleClips())
-        {
-          Vector3<S> tmp;
-          clipSegmentByPlane(polygon_points[i - 1], polygon_points[vi], n, t, &tmp);
-          if(num_clipped_points_ > 0)
-          {
-            if((tmp - clipped_points[num_clipped_points_ - 1]).squaredNorm() > getEpsilon())
-            {
-              clipped_points[num_clipped_points_] = tmp;
-              num_clipped_points_++;
-            }
-          }
-          else
-          {
-            clipped_points[num_clipped_points_] = tmp;
-            num_clipped_points_++;
-          }
-        }
-      }
-    }
-
-    prev_classify = classify;
-  }
-
-  if(num_clipped_points_ > 2)
-  {
-    if((clipped_points[0] - clipped_points[num_clipped_points_ - 1]).squaredNorm() < getEpsilon())
-    {
-      num_clipped_points_--;
-    }
-  }
-
-  *num_clipped_points = num_clipped_points_;
-}
-
-//==============================================================================
-template <typename S>
-void Intersect<S>::clipSegmentByPlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& n, S t, Vector3<S>* clipped_point)
-{
-  S dist1 = distanceToPlane(n, t, v1);
-  Vector3<S> tmp = v2 - v1;
-  S dist2 = tmp.dot(n);
-  *clipped_point = tmp * (-dist1 / dist2) + v1;
-}
-
-//==============================================================================
-template <typename S>
-S Intersect<S>::distanceToPlane(const Vector3<S>& n, S t, const Vector3<S>& v)
-{
-  return n.dot(v) - t;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::buildTrianglePlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3, Vector3<S>* n, S* t)
-{
-  Vector3<S> n_ = (v2 - v1).cross(v3 - v1);
-  bool can_normalize = false;
-  normalize(n_, &can_normalize);
-  if(can_normalize)
-  {
-    *n = n_;
-    *t = n_.dot(v1);
-    return true;
-  }
-
-  return false;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::buildEdgePlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& tn, Vector3<S>* n, S* t)
-{
-  Vector3<S> n_ = (v2 - v1).cross(tn);
-  bool can_normalize = false;
-  normalize(n_, &can_normalize);
-  if(can_normalize)
-  {
-    *n = n_;
-    *t = n_.dot(v1);
-    return true;
-  }
-
-  return false;
-}
-
-//==============================================================================
-template <typename S>
-bool Intersect<S>::sameSideOfPlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3, const Vector3<S>& n, S t)
-{
-  S dist1 = distanceToPlane(n, t, v1);
-  S dist2 = dist1 * distanceToPlane(n, t, v2);
-  S dist3 = dist1 * distanceToPlane(n, t, v3);
-  if((dist2 > 0) && (dist3 > 0))
-    return true;
-  return false;
-}
-
-//==============================================================================
-template <typename S>
-int Intersect<S>::project6(const Vector3<S>& ax,
-                        const Vector3<S>& p1, const Vector3<S>& p2, const Vector3<S>& p3,
-                        const Vector3<S>& q1, const Vector3<S>& q2, const Vector3<S>& q3)
-{
-  S P1 = ax.dot(p1);
-  S P2 = ax.dot(p2);
-  S P3 = ax.dot(p3);
-  S Q1 = ax.dot(q1);
-  S Q2 = ax.dot(q2);
-  S Q3 = ax.dot(q3);
-
-  S mn1 = std::min(P1, std::min(P2, P3));
-  S mx2 = std::max(Q1, std::max(Q2, Q3));
-  if(mn1 > mx2) return 0;
-
-  S mx1 = std::max(P1, std::max(P2, P3));
-  S mn2 = std::min(Q1, std::min(Q2, Q3));
-
-  if(mn2 > mx1) return 0;
-  return 1;
-}
-
-//==============================================================================
-template <typename S>
-S Intersect<S>::gaussianCDF(S x)
-{
-  return 0.5 * std::erfc(-x / sqrt(2.0));
-}
-
-//==============================================================================
-template <typename S>
-constexpr S Intersect<S>::getEpsilon()
-{
-  return 1e-5;
-}
-
-//==============================================================================
-template <typename S>
-constexpr S Intersect<S>::getNearZeroThreshold()
-{
-  return 1e-7;
-}
-
-//==============================================================================
-template <typename S>
-constexpr S Intersect<S>::getCcdResolution()
-{
-  return 1e-7;
-}
-
-//==============================================================================
-template <typename S>
-constexpr unsigned int Intersect<S>::getMaxTriangleClips()
-{
-  return 8;
-}
-
-} // namespace detail
-} // namespace fcl
-
-#endif
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#ifndef FCL_NARROWPHASE_DETAIL_INTERSECT_INL_H
+#define FCL_NARROWPHASE_DETAIL_INTERSECT_INL_H
+
+#include "fcl/narrowphase/detail/traversal/collision/intersect.h"
+
+namespace fcl
+{
+
+namespace detail
+{
+
+//==============================================================================
+extern template
+class FCL_EXPORT Intersect<double>;
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::isZero(S v)
+{
+  return (v < getNearZeroThreshold()) && (v > -getNearZeroThreshold());
+}
+
+//==============================================================================
+/// @brief data: only used for EE, return the intersect point
+template <typename S>
+bool Intersect<S>::solveCubicWithIntervalNewton(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                             const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
+                                             S& l, S& r, bool bVF, S coeffs[], Vector3<S>* data)
+{
+  S v2[2]= {l*l,r*r};
+  S v[2]= {l,r};
+  S r_backup;
+
+  unsigned char min3, min2, min1, max3, max2, max1;
+
+  min3= *((unsigned char*)&coeffs[3]+7)>>7; max3=min3^1;
+  min2= *((unsigned char*)&coeffs[2]+7)>>7; max2=min2^1;
+  min1= *((unsigned char*)&coeffs[1]+7)>>7; max1=min1^1;
+
+  // bound the cubic
+
+  S minor = coeffs[3]*v2[min3]*v[min3]+coeffs[2]*v2[min2]+coeffs[1]*v[min1]+coeffs[0];
+  S major = coeffs[3]*v2[max3]*v[max3]+coeffs[2]*v2[max2]+coeffs[1]*v[max1]+coeffs[0];
+
+  if(major<0) return false;
+  if(minor>0) return false;
+
+  // starting here, the bounds have opposite values
+  S m = 0.5 * (r + l);
+
+  // bound the derivative
+  S dminor = 3.0*coeffs[3]*v2[min3]+2.0*coeffs[2]*v[min2]+coeffs[1];
+  S dmajor = 3.0*coeffs[3]*v2[max3]+2.0*coeffs[2]*v[max2]+coeffs[1];
+
+  if((dminor > 0)||(dmajor < 0)) // we can use Newton
+  {
+    S m2 = m*m;
+    S fm = coeffs[3]*m2*m+coeffs[2]*m2+coeffs[1]*m+coeffs[0];
+    S nl = m;
+    S nu = m;
+    if(fm>0)
+    {
+      nl-=(fm/dminor);
+      nu-=(fm/dmajor);
+    }
+    else
+    {
+      nu-=(fm/dminor);
+      nl-=(fm/dmajor);
+    }
+
+    //intersect with [l,r]
+
+    if(nl>r) return false;
+    if(nu<l) return false;
+    if(nl>l)
+    {
+      if(nu<r) { l=nl; r=nu; m=0.5*(l+r); }
+      else { l=nl; m=0.5*(l+r); }
+    }
+    else
+    {
+      if(nu<r) { r=nu; m=0.5*(l+r); }
+    }
+  }
+
+  // sufficient temporal resolution, check root validity
+  if((r-l)< getCcdResolution())
+  {
+    if(bVF)
+      return checkRootValidity_VF(a0, b0, c0, d0, va, vb, vc, vd, r);
+    else
+      return checkRootValidity_EE(a0, b0, c0, d0, va, vb, vc, vd, r, data);
+  }
+
+  r_backup = r, r = m;
+  if(solveCubicWithIntervalNewton(a0, b0, c0, d0, va, vb, vc, vd, l, r, bVF, coeffs, data))
+    return true;
+
+  l = m, r = r_backup;
+  return solveCubicWithIntervalNewton(a0, b0, c0, d0, va, vb, vc, vd, l, r, bVF, coeffs, data);
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::insideTriangle(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>&p)
+{
+  Vector3<S> ab = b - a;
+  Vector3<S> ac = c - a;
+  Vector3<S> n = ab.cross(ac);
+
+  Vector3<S> pa = a - p;
+  Vector3<S> pb = b - p;
+  Vector3<S> pc = c - p;
+
+  if((pb.cross(pc)).dot(n) < -getEpsilon()) return false;
+  if((pc.cross(pa)).dot(n) < -getEpsilon()) return false;
+  if((pa.cross(pb)).dot(n) < -getEpsilon()) return false;
+
+  return true;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::insideLineSegment(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& p)
+{
+  return (p - a).dot(p - b) <= 0;
+}
+
+//==============================================================================
+/// @brief Calculate the line segment papb that is the shortest route between
+/// two lines p1p2 and p3p4. Calculate also the values of mua and mub where
+///    pa = p1 + mua (p2 - p1)
+///    pb = p3 + mub (p4 - p3)
+/// Return FALSE if no solution exists.
+template <typename S>
+bool Intersect<S>::linelineIntersect(const Vector3<S>& p1, const Vector3<S>& p2, const Vector3<S>& p3, const Vector3<S>& p4,
+                                  Vector3<S>* pa, Vector3<S>* pb, S* mua, S* mub)
+{
+  Vector3<S> p31 = p1 - p3;
+  Vector3<S> p34 = p4 - p3;
+  if(fabs(p34[0]) < getEpsilon() && fabs(p34[1]) < getEpsilon() && fabs(p34[2]) < getEpsilon())
+    return false;
+
+  Vector3<S> p12 = p2 - p1;
+  if(fabs(p12[0]) < getEpsilon() && fabs(p12[1]) < getEpsilon() && fabs(p12[2]) < getEpsilon())
+    return false;
+
+  S d3134 = p31.dot(p34);
+  S d3412 = p34.dot(p12);
+  S d3112 = p31.dot(p12);
+  S d3434 = p34.dot(p34);
+  S d1212 = p12.dot(p12);
+
+  S denom = d1212 * d3434 - d3412 * d3412;
+  if(fabs(denom) < getEpsilon())
+    return false;
+  S numer = d3134 * d3412 - d3112 * d3434;
+
+  *mua = numer / denom;
+  if(*mua < 0 || *mua > 1)
+    return false;
+
+  *mub = (d3134 + d3412 * (*mua)) / d3434;
+  if(*mub < 0 || *mub > 1)
+    return false;
+
+  *pa = p1 + p12 * (*mua);
+  *pb = p3 + p34 * (*mub);
+  return true;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::checkRootValidity_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
+                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vp,
+                                     S t)
+{
+  return insideTriangle(a0 + va * t, b0 + vb * t, c0 + vc * t, p0 + vp * t);
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::checkRootValidity_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
+                                     S t, Vector3<S>* q_i)
+{
+  Vector3<S> a = a0 + va * t;
+  Vector3<S> b = b0 + vb * t;
+  Vector3<S> c = c0 + vc * t;
+  Vector3<S> d = d0 + vd * t;
+  Vector3<S> p1, p2;
+  S t_ab, t_cd;
+  if(linelineIntersect(a, b, c, d, &p1, &p2, &t_ab, &t_cd))
+  {
+    if(q_i) *q_i = p1;
+    return true;
+  }
+
+  return false;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::checkRootValidity_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
+                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp,
+                                     S t)
+{
+  return insideLineSegment(a0 + va * t, b0 + vb * t, p0 + vp * t);
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::solveSquare(S a, S b, S c,
+                            const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                            const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
+                            bool bVF,
+                            S* ret)
+{
+  S discriminant = b * b - 4 * a * c;
+  if(discriminant < 0)
+    return false;
+
+  S sqrt_dis = sqrt(discriminant);
+  S r1 = (-b + sqrt_dis) / (2 * a);
+  bool v1 = (r1 >= 0.0 && r1 <= 1.0) ? ((bVF) ? checkRootValidity_VF(a0, b0, c0, d0, va, vb, vc, vd, r1) : checkRootValidity_EE(a0, b0, c0, d0, va, vb, vc, vd, r1)) : false;
+
+  S r2 = (-b - sqrt_dis) / (2 * a);
+  bool v2 = (r2 >= 0.0 && r2 <= 1.0) ? ((bVF) ? checkRootValidity_VF(a0, b0, c0, d0, va, vb, vc, vd, r2) : checkRootValidity_EE(a0, b0, c0, d0, va, vb, vc, vd, r2)) : false;
+
+  if(v1 && v2)
+  {
+    *ret = (r1 > r2) ? r2 : r1;
+    return true;
+  }
+  if(v1)
+  {
+    *ret = r1;
+    return true;
+  }
+  if(v2)
+  {
+    *ret = r2;
+    return true;
+  }
+
+  return false;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::solveSquare(S a, S b, S c,
+                            const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
+                            const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp)
+{
+  if(isZero(a))
+  {
+    S t = -c/b;
+    return (t >= 0 && t <= 1) ? checkRootValidity_VE(a0, b0, p0, va, vb, vp, t) : false;
+  }
+
+  S discriminant = b*b-4*a*c;
+  if(discriminant < 0)
+    return false;
+
+  S sqrt_dis = sqrt(discriminant);
+
+  S r1 = (-b+sqrt_dis) / (2 * a);
+  bool v1 = (r1 >= 0.0 && r1 <= 1.0) ? checkRootValidity_VE(a0, b0, p0, va, vb, vp, r1) : false;
+  if(v1) return true;
+
+  S r2 = (-b-sqrt_dis) / (2 * a);
+  bool v2 = (r2 >= 0.0 && r2 <= 1.0) ? checkRootValidity_VE(a0, b0, p0, va, vb, vp, r2) : false;
+  return v2;
+}
+
+//==============================================================================
+/// @brief Compute the cubic coefficients for VF case
+/// See Paper "Interactive Continuous Collision Detection between Deformable Models using Connectivity-Based Culling", Equation 1.
+template <typename S>
+void Intersect<S>::computeCubicCoeff_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
+                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vp,
+                                     S* a, S* b, S* c, S* d)
+{
+  Vector3<S> vavb = vb - va;
+  Vector3<S> vavc = vc - va;
+  Vector3<S> vavp = vp - va;
+  Vector3<S> a0b0 = b0 - a0;
+  Vector3<S> a0c0 = c0 - a0;
+  Vector3<S> a0p0 = p0 - a0;
+
+  Vector3<S> vavb_cross_vavc = vavb.cross(vavc);
+  Vector3<S> vavb_cross_a0c0 = vavb.cross(a0c0);
+  Vector3<S> a0b0_cross_vavc = a0b0.cross(vavc);
+  Vector3<S> a0b0_cross_a0c0 = a0b0.cross(a0c0);
+
+  *a = vavp.dot(vavb_cross_vavc);
+  *b = a0p0.dot(vavb_cross_vavc) + vavp.dot(vavb_cross_a0c0 + a0b0_cross_vavc);
+  *c = vavp.dot(a0b0_cross_a0c0) + a0p0.dot(vavb_cross_a0c0 + a0b0_cross_vavc);
+  *d = a0p0.dot(a0b0_cross_a0c0);
+}
+
+//==============================================================================
+template <typename S>
+void Intersect<S>::computeCubicCoeff_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
+                                     S* a, S* b, S* c, S* d)
+{
+  Vector3<S> vavb = vb - va;
+  Vector3<S> vcvd = vd - vc;
+  Vector3<S> vavc = vc - va;
+  Vector3<S> c0d0 = d0 - c0;
+  Vector3<S> a0b0 = b0 - a0;
+  Vector3<S> a0c0 = c0 - a0;
+  Vector3<S> vavb_cross_vcvd = vavb.cross(vcvd);
+  Vector3<S> vavb_cross_c0d0 = vavb.cross(c0d0);
+  Vector3<S> a0b0_cross_vcvd = a0b0.cross(vcvd);
+  Vector3<S> a0b0_cross_c0d0 = a0b0.cross(c0d0);
+
+  *a = vavc.dot(vavb_cross_vcvd);
+  *b = a0c0.dot(vavb_cross_vcvd) + vavc.dot(vavb_cross_c0d0 + a0b0_cross_vcvd);
+  *c = vavc.dot(a0b0_cross_c0d0) + a0c0.dot(vavb_cross_c0d0 + a0b0_cross_vcvd);
+  *d = a0c0.dot(a0b0_cross_c0d0);
+}
+
+//==============================================================================
+template <typename S>
+void Intersect<S>::computeCubicCoeff_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
+                                     const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp,
+                                     const Vector3<S>& L,
+                                     S* a, S* b, S* c)
+{
+  Vector3<S> vbva = va - vb;
+  Vector3<S> vbvp = vp - vb;
+  Vector3<S> b0a0 = a0 - b0;
+  Vector3<S> b0p0 = p0 - b0;
+
+  Vector3<S> L_cross_vbvp = L.cross(vbvp);
+  Vector3<S> L_cross_b0p0 = L.cross(b0p0);
+
+  *a = L_cross_vbvp.dot(vbva);
+  *b = L_cross_vbvp.dot(b0a0) + L_cross_b0p0.dot(vbva);
+  *c = L_cross_b0p0.dot(b0a0);
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::intersect_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
+                             const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& p1,
+                             S* collision_time, Vector3<S>* p_i, bool useNewton)
+{
+  *collision_time = 2.0;
+
+  Vector3<S> vp, va, vb, vc;
+  vp = p1 - p0;
+  va = a1 - a0;
+  vb = b1 - b0;
+  vc = c1 - c0;
+
+  S a, b, c, d;
+  computeCubicCoeff_VF(a0, b0, c0, p0, va, vb, vc, vp, &a, &b, &c, &d);
+
+  if(isZero(a) && isZero(b) && isZero(c) && isZero(d))
+  {
+    return false;
+  }
+
+
+  /// if(isZero(a))
+  /// {
+  ///   return solveSquare(b, c, d, a0, b0, c0, p0, va, vb, vc, vp, true, collision_time);
+  /// }
+
+  S coeffs[4];
+  coeffs[3] = a, coeffs[2] = b, coeffs[1] = c, coeffs[0] = d;
+
+  if(useNewton)
+  {
+    S l = 0;
+    S r = 1;
+
+    if(solveCubicWithIntervalNewton(a0, b0, c0, p0, va, vb, vc, vp, l, r, true, coeffs))
+    {
+      *collision_time = 0.5 * (l + r);
+    }
+  }
+  else
+  {
+    S roots[3];
+    int num = PolySolver<S>::solveCubic(coeffs, roots);
+    for(int i = 0; i < num; ++i)
+    {
+      S r = roots[i];
+      if(r < 0 || r > 1) continue;
+      if(checkRootValidity_VF(a0, b0, c0, p0, va, vb, vc, vp, r))
+      {
+        *collision_time = r;
+        break;
+      }
+    }
+  }
+
+  if(*collision_time > 1)
+  {
+    return false;
+  }
+
+  *p_i = vp * (*collision_time) + p0;
+  return true;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::intersect_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                             const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1,
+                             S* collision_time, Vector3<S>* p_i, bool useNewton)
+{
+  *collision_time = 2.0;
+
+  Vector3<S> va, vb, vc, vd;
+  va = a1 - a0;
+  vb = b1 - b0;
+  vc = c1 - c0;
+  vd = d1 - d0;
+
+  S a, b, c, d;
+  computeCubicCoeff_EE(a0, b0, c0, d0, va, vb, vc, vd, &a, &b, &c, &d);
+
+  if(isZero(a) && isZero(b) && isZero(c) && isZero(d))
+  {
+    return false;
+  }
+
+  /// if(isZero(a))
+  /// {
+  ///   return solveSquare(b, c, d, a0, b0, c0, d0, va, vb, vc, vd, collision_time, false);
+  /// }
+
+
+  S coeffs[4];
+  coeffs[3] = a, coeffs[2] = b, coeffs[1] = c, coeffs[0] = d;
+
+  if(useNewton)
+  {
+    S l = 0;
+    S r = 1;
+
+    if(solveCubicWithIntervalNewton(a0, b0, c0, d0, va, vb, vc, vd, l, r, false, coeffs, p_i))
+    {
+      *collision_time  = (l + r) * 0.5;
+    }
+  }
+  else
+  {
+    S roots[3];
+    int num = PolySolver<S>::solveCubic(coeffs, roots);
+    for(int i = 0; i < num; ++i)
+    {
+      S r = roots[i];
+      if(r < 0 || r > 1) continue;
+
+      if(checkRootValidity_EE(a0, b0, c0, d0, va, vb, vc, vd, r, p_i))
+      {
+        *collision_time = r;
+        break;
+      }
+    }
+  }
+
+  if(*collision_time > 1)
+  {
+    return false;
+  }
+
+  return true;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::intersect_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
+                             const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& p1,
+                             const Vector3<S>& L)
+{
+  Vector3<S> va, vb, vp;
+  va = a1 - a0;
+  vb = b1 - b0;
+  vp = p1 - p0;
+
+  S a, b, c;
+  computeCubicCoeff_VE(a0, b0, p0, va, vb, vp, L, &a, &b, &c);
+
+  if(isZero(a) && isZero(b) && isZero(c))
+    return true;
+
+  return solveSquare(a, b, c, a0, b0, p0, va, vb, vp);
+
+}
+
+//==============================================================================
+/// @brief Prefilter for intersection, works for both VF and EE
+template <typename S>
+bool Intersect<S>::intersectPreFiltering(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                      const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1)
+{
+  Vector3<S> n0 = (b0 - a0).cross(c0 - a0);
+  Vector3<S> n1 = (b1 - a1).cross(c1 - a1);
+  Vector3<S> a0a1 = a1 - a0;
+  Vector3<S> b0b1 = b1 - b0;
+  Vector3<S> c0c1 = c1 - c0;
+  Vector3<S> delta = (b0b1 - a0a1).cross(c0c1 - a0a1);
+  Vector3<S> nx = (n0 + n1 - delta) * 0.5;
+
+  Vector3<S> a0d0 = d0 - a0;
+  Vector3<S> a1d1 = d1 - a1;
+
+  S A = n0.dot(a0d0);
+  S B = n1.dot(a1d1);
+  S C = nx.dot(a0d0);
+  S D = nx.dot(a1d1);
+  S E = n1.dot(a0d0);
+  S F = n0.dot(a1d1);
+
+  if(A > 0 && B > 0 && (2*C +F) > 0 && (2*D+E) > 0)
+    return false;
+  if(A < 0 && B < 0 && (2*C +F) < 0 && (2*D+E) < 0)
+    return false;
+
+  return true;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::intersect_VF_filtered(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
+                                      const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& p1,
+                                      S* collision_time, Vector3<S>* p_i, bool useNewton)
+{
+  if(intersectPreFiltering(a0, b0, c0, p0, a1, b1, c1, p1))
+  {
+    return intersect_VF(a0, b0, c0, p0, a1, b1, c1, p1, collision_time, p_i, useNewton);
+  }
+  else
+    return false;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::intersect_EE_filtered(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                      const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1,
+                                      S* collision_time, Vector3<S>* p_i, bool useNewton)
+{
+  if(intersectPreFiltering(a0, b0, c0, d0, a1, b1, c1, d1))
+  {
+    return intersect_EE(a0, b0, c0, d0, a1, b1, c1, d1, collision_time, p_i, useNewton);
+  }
+  else
+    return false;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::intersect_Triangle(
+    const Vector3<S>& P1,
+    const Vector3<S>& P2,
+    const Vector3<S>& P3,
+    const Vector3<S>& Q1,
+    const Vector3<S>& Q2,
+    const Vector3<S>& Q3,
+    const Matrix3<S>& R,
+    const Vector3<S>& T,
+    Vector3<S>* contact_points,
+    unsigned int* num_contact_points,
+    S* penetration_depth,
+    Vector3<S>* normal)
+{
+  Vector3<S> Q1_ = R * Q1 + T;
+  Vector3<S> Q2_ = R * Q2 + T;
+  Vector3<S> Q3_ = R * Q3 + T;
+
+  return intersect_Triangle(P1, P2, P3, Q1_, Q2_, Q3_, contact_points, num_contact_points, penetration_depth, normal);
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::intersect_Triangle(
+    const Vector3<S>& P1,
+    const Vector3<S>& P2,
+    const Vector3<S>& P3,
+    const Vector3<S>& Q1,
+    const Vector3<S>& Q2,
+    const Vector3<S>& Q3,
+    const Transform3<S>& tf,
+    Vector3<S>* contact_points,
+    unsigned int* num_contact_points,
+    S* penetration_depth,
+    Vector3<S>* normal)
+{
+  Vector3<S> Q1_ = tf * Q1;
+  Vector3<S> Q2_ = tf * Q2;
+  Vector3<S> Q3_ = tf * Q3;
+
+  return intersect_Triangle(P1, P2, P3, Q1_, Q2_, Q3_, contact_points, num_contact_points, penetration_depth, normal);
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::intersect_Triangle_ODE_style(
+    const Vector3<S>& P1, const Vector3<S>& P2, const Vector3<S>& P3,
+    const Vector3<S>& Q1, const Vector3<S>& Q2, const Vector3<S>& Q3,
+    Vector3<S>* contact_points,
+    unsigned int* num_contact_points,
+    S* penetration_depth,
+    Vector3<S>* normal)
+{
+  Vector3<S> n1;
+  S t1;
+  bool b1 = buildTrianglePlane(P1, P2, P3, &n1, &t1);
+  if(!b1) return false;
+
+  Vector3<S> n2;
+  S t2;
+  bool b2 = buildTrianglePlane(Q1, Q2, Q3, &n2, &t2);
+  if(!b2) return false;
+
+  if(sameSideOfPlane(P1, P2, P3, n2, t2))
+    return false;
+
+  if(sameSideOfPlane(Q1, Q2, Q3, n1, t1))
+    return false;
+
+  Vector3<S> clipped_points1[getMaxTriangleClips()];
+  unsigned int num_clipped_points1 = 0;
+  Vector3<S> clipped_points2[getMaxTriangleClips()];
+  unsigned int num_clipped_points2 = 0;
+
+  Vector3<S> deepest_points1[getMaxTriangleClips()];
+  unsigned int num_deepest_points1 = 0;
+  Vector3<S> deepest_points2[getMaxTriangleClips()];
+  unsigned int num_deepest_points2 = 0;
+  S penetration_depth1 = -1, penetration_depth2 = -1;
+
+  clipTriangleByTriangleAndEdgePlanes(Q1, Q2, Q3, P1, P2, P3, n1, t1, clipped_points2, &num_clipped_points2);
+
+  if(num_clipped_points2 == 0)
+    return false;
+
+  computeDeepestPoints(clipped_points2, num_clipped_points2, n1, t1, &penetration_depth2, deepest_points2, &num_deepest_points2);
+  if(num_deepest_points2 == 0)
+    return false;
+
+  clipTriangleByTriangleAndEdgePlanes(P1, P2, P3, Q1, Q2, Q3, n2, t2, clipped_points1, &num_clipped_points1);
+  if(num_clipped_points1 == 0)
+    return false;
+
+  computeDeepestPoints(clipped_points1, num_clipped_points1, n2, t2, &penetration_depth1, deepest_points1, &num_deepest_points1);
+  if(num_deepest_points1 == 0)
+    return false;
+
+
+  /// Return contact information
+  if(contact_points && num_contact_points && penetration_depth && normal)
+  {
+    if(penetration_depth1 > penetration_depth2)
+    {
+      *num_contact_points = num_deepest_points2;
+      for(unsigned int i = 0; i < num_deepest_points2; ++i)
+      {
+        contact_points[i] = deepest_points2[i];
+      }
+
+      *normal = n1;
+      *penetration_depth = penetration_depth2;
+    }
+    else
+    {
+      *num_contact_points = num_deepest_points1;
+      for(unsigned int i = 0; i < num_deepest_points1; ++i)
+      {
+        contact_points[i] = deepest_points1[i];
+      }
+
+      *normal = -n2;
+      *penetration_depth = penetration_depth1;
+    }
+  }
+
+  return true;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::intersect_Triangle(
+    const Vector3<S>& P1, const Vector3<S>& P2, const Vector3<S>& P3,
+    const Vector3<S>& Q1, const Vector3<S>& Q2, const Vector3<S>& Q3,
+    Vector3<S>* contact_points,
+    unsigned int* num_contact_points,
+    S* penetration_depth,
+    Vector3<S>* normal)
+{
+  Vector3<S> p1 = P1 - P1;
+  Vector3<S> p2 = P2 - P1;
+  Vector3<S> p3 = P3 - P1;
+  Vector3<S> q1 = Q1 - P1;
+  Vector3<S> q2 = Q2 - P1;
+  Vector3<S> q3 = Q3 - P1;
+
+  Vector3<S> e1 = p2 - p1;
+  Vector3<S> e2 = p3 - p2;
+  Vector3<S> n1 = e1.cross(e2);
+  if (!project6(n1, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> f1 = q2 - q1;
+  Vector3<S> f2 = q3 - q2;
+  Vector3<S> m1 = f1.cross(f2);
+  if (!project6(m1, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> ef11 = e1.cross(f1);
+  if (!project6(ef11, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> ef12 = e1.cross(f2);
+  if (!project6(ef12, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> f3 = q1 - q3;
+  Vector3<S> ef13 = e1.cross(f3);
+  if (!project6(ef13, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> ef21 = e2.cross(f1);
+  if (!project6(ef21, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> ef22 = e2.cross(f2);
+  if (!project6(ef22, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> ef23 = e2.cross(f3);
+  if (!project6(ef23, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> e3 = p1 - p3;
+  Vector3<S> ef31 = e3.cross(f1);
+  if (!project6(ef31, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> ef32 = e3.cross(f2);
+  if (!project6(ef32, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> ef33 = e3.cross(f3);
+  if (!project6(ef33, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> g1 = e1.cross(n1);
+  if (!project6(g1, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> g2 = e2.cross(n1);
+  if (!project6(g2, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> g3 = e3.cross(n1);
+  if (!project6(g3, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> h1 = f1.cross(m1);
+  if (!project6(h1, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> h2 = f2.cross(m1);
+  if (!project6(h2, p1, p2, p3, q1, q2, q3)) return false;
+
+  Vector3<S> h3 = f3.cross(m1);
+  if (!project6(h3, p1, p2, p3, q1, q2, q3)) return false;
+
+  if(contact_points && num_contact_points && penetration_depth && normal)
+  {
+    Vector3<S> n1, n2;
+    S t1, t2;
+    buildTrianglePlane(P1, P2, P3, &n1, &t1);
+    buildTrianglePlane(Q1, Q2, Q3, &n2, &t2);
+
+    Vector3<S> deepest_points1[3];
+    unsigned int num_deepest_points1 = 0;
+    Vector3<S> deepest_points2[3];
+    unsigned int num_deepest_points2 = 0;
+    S penetration_depth1, penetration_depth2;
+
+    Vector3<S> P[3] = {P1, P2, P3};
+    Vector3<S> Q[3] = {Q1, Q2, Q3};
+
+    computeDeepestPoints(Q, 3, n1, t1, &penetration_depth2, deepest_points2, &num_deepest_points2);
+    computeDeepestPoints(P, 3, n2, t2, &penetration_depth1, deepest_points1, &num_deepest_points1);
+
+
+    if(penetration_depth1 > penetration_depth2)
+    {
+      *num_contact_points = std::min(num_deepest_points2, (unsigned int)2);
+      for(unsigned int i = 0; i < *num_contact_points; ++i)
+      {
+        contact_points[i] = deepest_points2[i];
+      }
+
+      *normal = n1;
+      *penetration_depth = penetration_depth2;
+    }
+    else
+    {
+      *num_contact_points = std::min(num_deepest_points1, (unsigned int)2);
+      for(unsigned int i = 0; i < *num_contact_points; ++i)
+      {
+        contact_points[i] = deepest_points1[i];
+      }
+
+      *normal = -n2;
+      *penetration_depth = penetration_depth1;
+    }
+  }
+
+  return true;
+}
+
+//==============================================================================
+template <typename S>
+void Intersect<S>::computeDeepestPoints(Vector3<S>* clipped_points, unsigned int num_clipped_points, const Vector3<S>& n, S t, S* penetration_depth, Vector3<S>* deepest_points, unsigned int* num_deepest_points)
+{
+  *num_deepest_points = 0;
+  S max_depth = -std::numeric_limits<S>::max();
+  unsigned int num_deepest_points_ = 0;
+  unsigned int num_neg = 0;
+  unsigned int num_pos = 0;
+  unsigned int num_zero = 0;
+
+  for(unsigned int i = 0; i < num_clipped_points; ++i)
+  {
+    S dist = -distanceToPlane(n, t, clipped_points[i]);
+    if(dist > getEpsilon()) num_pos++;
+    else if(dist < -getEpsilon()) num_neg++;
+    else num_zero++;
+    if(dist > max_depth)
+    {
+      max_depth = dist;
+      num_deepest_points_ = 1;
+      deepest_points[num_deepest_points_ - 1] = clipped_points[i];
+    }
+    else if(dist + 1e-6 >= max_depth)
+    {
+      num_deepest_points_++;
+      deepest_points[num_deepest_points_ - 1] = clipped_points[i];
+    }
+  }
+
+  if(max_depth < -getEpsilon())
+    num_deepest_points_ = 0;
+
+  if(num_zero == 0 && ((num_neg == 0) || (num_pos == 0)))
+    num_deepest_points_ = 0;
+
+  *penetration_depth = max_depth;
+  *num_deepest_points = num_deepest_points_;
+}
+
+//==============================================================================
+template <typename S>
+void Intersect<S>::clipTriangleByTriangleAndEdgePlanes(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3,
+                                                    const Vector3<S>& t1, const Vector3<S>& t2, const Vector3<S>& t3,
+                                                    const Vector3<S>& tn, S to,
+                                                    Vector3<S> clipped_points[], unsigned int* num_clipped_points,
+                                                    bool clip_triangle)
+{
+  *num_clipped_points = 0;
+  Vector3<S> temp_clip[getMaxTriangleClips()];
+  Vector3<S> temp_clip2[getMaxTriangleClips()];
+  unsigned int num_temp_clip = 0;
+  unsigned int num_temp_clip2 = 0;
+  Vector3<S> v[3] = {v1, v2, v3};
+
+  Vector3<S> plane_n;
+  S plane_dist;
+
+  if(buildEdgePlane(t1, t2, tn, &plane_n, &plane_dist))
+  {
+    clipPolygonByPlane(v, 3, plane_n, plane_dist, temp_clip, &num_temp_clip);
+    if(num_temp_clip > 0)
+    {
+      if(buildEdgePlane(t2, t3, tn, &plane_n, &plane_dist))
+      {
+        clipPolygonByPlane(temp_clip, num_temp_clip, plane_n, plane_dist, temp_clip2, &num_temp_clip2);
+        if(num_temp_clip2 > 0)
+        {
+          if(buildEdgePlane(t3, t1, tn, &plane_n, &plane_dist))
+          {
+            if(clip_triangle)
+            {
+              num_temp_clip = 0;
+              clipPolygonByPlane(temp_clip2, num_temp_clip2, plane_n, plane_dist, temp_clip, &num_temp_clip);
+              if(num_temp_clip > 0)
+              {
+                clipPolygonByPlane(temp_clip, num_temp_clip, tn, to, clipped_points, num_clipped_points);
+              }
+            }
+            else
+            {
+              clipPolygonByPlane(temp_clip2, num_temp_clip2, plane_n, plane_dist, clipped_points, num_clipped_points);
+            }
+          }
+        }
+      }
+    }
+  }
+}
+
+//==============================================================================
+template <typename S>
+void Intersect<S>::clipPolygonByPlane(Vector3<S>* polygon_points, unsigned int num_polygon_points, const Vector3<S>& n, S t, Vector3<S> clipped_points[], unsigned int* num_clipped_points)
+{
+  *num_clipped_points = 0;
+
+  unsigned int num_clipped_points_ = 0;
+  unsigned int vi;
+  unsigned int prev_classify = 2;
+  unsigned int classify;
+  for(unsigned int i = 0; i <= num_polygon_points; ++i)
+  {
+    vi = (i % num_polygon_points);
+    S d = distanceToPlane(n, t, polygon_points[i]);
+    classify = ((d > getEpsilon()) ? 1 : 0);
+    if(classify == 0)
+    {
+      if(prev_classify == 1)
+      {
+        if(num_clipped_points_ < getMaxTriangleClips())
+        {
+          Vector3<S> tmp;
+          clipSegmentByPlane(polygon_points[i - 1], polygon_points[vi], n, t, &tmp);
+          if(num_clipped_points_ > 0)
+          {
+            if((tmp - clipped_points[num_clipped_points_ - 1]).squaredNorm() > getEpsilon())
+            {
+              clipped_points[num_clipped_points_] = tmp;
+              num_clipped_points_++;
+            }
+          }
+          else
+          {
+            clipped_points[num_clipped_points_] = tmp;
+            num_clipped_points_++;
+          }
+        }
+      }
+
+      if(num_clipped_points_ < getMaxTriangleClips() && i < num_polygon_points)
+      {
+        clipped_points[num_clipped_points_] = polygon_points[vi];
+        num_clipped_points_++;
+      }
+    }
+    else
+    {
+      if(prev_classify == 0)
+      {
+        if(num_clipped_points_ < getMaxTriangleClips())
+        {
+          Vector3<S> tmp;
+          clipSegmentByPlane(polygon_points[i - 1], polygon_points[vi], n, t, &tmp);
+          if(num_clipped_points_ > 0)
+          {
+            if((tmp - clipped_points[num_clipped_points_ - 1]).squaredNorm() > getEpsilon())
+            {
+              clipped_points[num_clipped_points_] = tmp;
+              num_clipped_points_++;
+            }
+          }
+          else
+          {
+            clipped_points[num_clipped_points_] = tmp;
+            num_clipped_points_++;
+          }
+        }
+      }
+    }
+
+    prev_classify = classify;
+  }
+
+  if(num_clipped_points_ > 2)
+  {
+    if((clipped_points[0] - clipped_points[num_clipped_points_ - 1]).squaredNorm() < getEpsilon())
+    {
+      num_clipped_points_--;
+    }
+  }
+
+  *num_clipped_points = num_clipped_points_;
+}
+
+//==============================================================================
+template <typename S>
+void Intersect<S>::clipSegmentByPlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& n, S t, Vector3<S>* clipped_point)
+{
+  S dist1 = distanceToPlane(n, t, v1);
+  Vector3<S> tmp = v2 - v1;
+  S dist2 = tmp.dot(n);
+  *clipped_point = tmp * (-dist1 / dist2) + v1;
+}
+
+//==============================================================================
+template <typename S>
+S Intersect<S>::distanceToPlane(const Vector3<S>& n, S t, const Vector3<S>& v)
+{
+  return n.dot(v) - t;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::buildTrianglePlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3, Vector3<S>* n, S* t)
+{
+  Vector3<S> n_ = (v2 - v1).cross(v3 - v1);
+  bool can_normalize = false;
+  normalize(n_, &can_normalize);
+  if(can_normalize)
+  {
+    *n = n_;
+    *t = n_.dot(v1);
+    return true;
+  }
+
+  return false;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::buildEdgePlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& tn, Vector3<S>* n, S* t)
+{
+  Vector3<S> n_ = (v2 - v1).cross(tn);
+  bool can_normalize = false;
+  normalize(n_, &can_normalize);
+  if(can_normalize)
+  {
+    *n = n_;
+    *t = n_.dot(v1);
+    return true;
+  }
+
+  return false;
+}
+
+//==============================================================================
+template <typename S>
+bool Intersect<S>::sameSideOfPlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3, const Vector3<S>& n, S t)
+{
+  S dist1 = distanceToPlane(n, t, v1);
+  S dist2 = dist1 * distanceToPlane(n, t, v2);
+  S dist3 = dist1 * distanceToPlane(n, t, v3);
+  if((dist2 > 0) && (dist3 > 0))
+    return true;
+  return false;
+}
+
+//==============================================================================
+template <typename S>
+int Intersect<S>::project6(const Vector3<S>& ax,
+                        const Vector3<S>& p1, const Vector3<S>& p2, const Vector3<S>& p3,
+                        const Vector3<S>& q1, const Vector3<S>& q2, const Vector3<S>& q3)
+{
+  S P1 = ax.dot(p1);
+  S P2 = ax.dot(p2);
+  S P3 = ax.dot(p3);
+  S Q1 = ax.dot(q1);
+  S Q2 = ax.dot(q2);
+  S Q3 = ax.dot(q3);
+
+  S mn1 = std::min(P1, std::min(P2, P3));
+  S mx2 = std::max(Q1, std::max(Q2, Q3));
+  if(mn1 > mx2) return 0;
+
+  S mx1 = std::max(P1, std::max(P2, P3));
+  S mn2 = std::min(Q1, std::min(Q2, Q3));
+
+  if(mn2 > mx1) return 0;
+  return 1;
+}
+
+//==============================================================================
+template <typename S>
+S Intersect<S>::gaussianCDF(S x)
+{
+  return 0.5 * std::erfc(-x / sqrt(2.0));
+}
+
+//==============================================================================
+template <typename S>
+constexpr S Intersect<S>::getEpsilon()
+{
+  return 1e-5;
+}
+
+//==============================================================================
+template <typename S>
+constexpr S Intersect<S>::getNearZeroThreshold()
+{
+  return 1e-7;
+}
+
+//==============================================================================
+template <typename S>
+constexpr S Intersect<S>::getCcdResolution()
+{
+  return 1e-7;
+}
+
+//==============================================================================
+template <typename S>
+constexpr unsigned int Intersect<S>::getMaxTriangleClips()
+{
+  return 8;
+}
+
+} // namespace detail
+} // namespace fcl
+
+#endif
diff --git a/include/fcl/narrowphase/detail/traversal/collision/intersect.h b/include/fcl/narrowphase/detail/traversal/collision/intersect.h
index d653b87..79ca483 100644
--- a/include/fcl/narrowphase/detail/traversal/collision/intersect.h
+++ b/include/fcl/narrowphase/detail/traversal/collision/intersect.h
@@ -1,265 +1,265 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#ifndef FCL_NARROWPHASE_DETAIL_INTERSECT_H
-#define FCL_NARROWPHASE_DETAIL_INTERSECT_H
-
-#include <limits>
-#include "fcl/common/types.h"
-#include "fcl/math/geometry.h"
-#include "fcl/math/detail/polysolver.h"
-
-namespace fcl
-{
-
-namespace detail
-{
-
-/// @brief CCD intersect kernel among primitives 
-template <typename S>
-class FCL_EXPORT Intersect
-{
-
-public:
-
-  /// @brief CCD intersect between one vertex and one face
-  /// [a0, b0, c0] and [a1, b1, c1] are points for the triangle face in time t0 and t1
-  /// p0 and p1 are points for vertex in time t0 and t1
-  /// p_i returns the coordinate of the collision point
-  static bool intersect_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
-                           const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& p1,
-                           S* collision_time, Vector3<S>* p_i, bool useNewton = true);
-
-  /// @brief CCD intersect between two edges
-  /// [a0, b0] and [a1, b1] are points for one edge in time t0 and t1
-  /// [c0, d0] and [c1, d1] are points for the other edge in time t0 and t1
-  /// p_i returns the coordinate of the collision point
-  static bool intersect_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                           const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1,
-                           S* collision_time, Vector3<S>* p_i, bool useNewton = true);
-
-  /// @brief CCD intersect between one vertex and one face, using additional filter 
-  static bool intersect_VF_filtered(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
-                                    const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& p1,
-                                    S* collision_time, Vector3<S>* p_i, bool useNewton = true);
-
-  /// @brief CCD intersect between two edges, using additional filter 
-  static bool intersect_EE_filtered(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                    const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1,
-                                    S* collision_time, Vector3<S>* p_i, bool useNewton = true);
-
-  /// @brief CCD intersect between one vertex and and one edge 
-  static bool intersect_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
-                           const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& p1,
-                           const Vector3<S>& L);
-
-  /// @brief CD intersect between two triangles [P1, P2, P3] and [Q1, Q2, Q3]
-  static bool intersect_Triangle(
-      const Vector3<S>& P1,
-      const Vector3<S>& P2,
-      const Vector3<S>& P3,
-      const Vector3<S>& Q1,
-      const Vector3<S>& Q2,
-      const Vector3<S>& Q3,
-      Vector3<S>* contact_points = nullptr,
-      unsigned int* num_contact_points = nullptr,
-      S* penetration_depth = nullptr,
-      Vector3<S>* normal = nullptr);
-
-  /// @brief CD intersect between two triangles [P1, P2, P3] and [Q1, Q2, Q3]
-  static bool intersect_Triangle_ODE_style(
-      const Vector3<S>& P1,
-      const Vector3<S>& P2,
-      const Vector3<S>& P3,
-      const Vector3<S>& Q1,
-      const Vector3<S>& Q2,
-      const Vector3<S>& Q3,
-      Vector3<S>* contact_points = nullptr,
-      unsigned int* num_contact_points = nullptr,
-      S* penetration_depth = nullptr,
-      Vector3<S>* normal = nullptr);
-
-  static bool intersect_Triangle(
-      const Vector3<S>& P1,
-      const Vector3<S>& P2,
-      const Vector3<S>& P3,
-      const Vector3<S>& Q1,
-      const Vector3<S>& Q2,
-      const Vector3<S>& Q3,
-      const Matrix3<S>& R,
-      const Vector3<S>& T,
-      Vector3<S>* contact_points = nullptr,
-      unsigned int* num_contact_points = nullptr,
-      S* penetration_depth = nullptr,
-      Vector3<S>* normal = nullptr);
-
-  static bool intersect_Triangle(
-      const Vector3<S>& P1,
-      const Vector3<S>& P2,
-      const Vector3<S>& P3,
-      const Vector3<S>& Q1,
-      const Vector3<S>& Q2,
-      const Vector3<S>& Q3,
-      const Transform3<S>& tf,
-      Vector3<S>* contact_points = nullptr,
-      unsigned int* num_contact_points = nullptr,
-      S* penetration_depth = nullptr,
-      Vector3<S>* normal = nullptr);
-  
-private:
-
-  /// @brief Project function used in intersect_Triangle() 
-  static int project6(const Vector3<S>& ax,
-                      const Vector3<S>& p1, const Vector3<S>& p2, const Vector3<S>& p3,
-                      const Vector3<S>& q1, const Vector3<S>& q2, const Vector3<S>& q3);
-
-  /// @brief Check whether one value is zero 
-  static bool isZero(S v);
-
-  /// @brief Solve the cubic function using Newton method, also satisfies the interval restriction 
-  static bool solveCubicWithIntervalNewton(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                           const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
-                                           S& l, S& r, bool bVF, S coeffs[], Vector3<S>* data = nullptr);
-
-  /// @brief Check whether one point p is within triangle [a, b, c] 
-  static bool insideTriangle(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>&p);
-
-  /// @brief Check whether one point p is within a line segment [a, b] 
-  static bool insideLineSegment(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& p);
-
-  /// @brief Calculate the line segment papb that is the shortest route between
-  /// two lines p1p2 and p3p4. Calculate also the values of mua and mub where
-  ///                    pa = p1 + mua (p2 - p1)
-  ///                    pb = p3 + mub (p4 - p3)
-  /// return FALSE if no solution exists.
-  static bool linelineIntersect(const Vector3<S>& p1, const Vector3<S>& p2, const Vector3<S>& p3, const Vector3<S>& p4,
-                                Vector3<S>* pa, Vector3<S>* pb, S* mua, S* mub);
-
-  /// @brief Check whether a root for VF intersection is valid (i.e. within the triangle at intersection t 
-  static bool checkRootValidity_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
-                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vp,
-                                   S t);
-
-  /// @brief Check whether a root for EE intersection is valid (i.e. within the two edges intersected at the given time 
-  static bool checkRootValidity_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
-                                   S t, Vector3<S>* q_i = nullptr);
-
-  /// @brief Check whether a root for VE intersection is valid 
-  static bool checkRootValidity_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
-                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp,
-                                   S t);
-
-  /// @brief Solve a square function for EE intersection (with interval restriction) 
-  static bool solveSquare(S a, S b, S c,
-                          const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                          const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
-                          bool bVF,
-                          S* ret);
-
-  /// @brief Solve a square function for VE intersection (with interval restriction) 
-  static bool solveSquare(S a, S b, S c,
-                          const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
-                          const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp);
-
-  /// @brief Compute the cubic coefficients for VF intersection
-  /// See Paper "Interactive Continuous Collision Detection between Deformable Models using Connectivity-Based Culling", Equation 1.
-   
-  static void computeCubicCoeff_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
-                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vp,
-                                   S* a, S* b, S* c, S* d);
-
-  /// @brief Compute the cubic coefficients for EE intersection 
-  static void computeCubicCoeff_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
-                                   S* a, S* b, S* c, S* d);
-
-  /// @brief Compute the cubic coefficients for VE intersection 
-  static void computeCubicCoeff_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
-                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp,
-                                   const Vector3<S>& L,
-                                   S* a, S* b, S* c);
-
-  /// @brief filter for intersection, works for both VF and EE 
-  static bool intersectPreFiltering(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
-                                    const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1);
-
-  /// @brief distance of point v to a plane n * x - t = 0 
-  static S distanceToPlane(const Vector3<S>& n, S t, const Vector3<S>& v);
-
-  /// @brief check wether points v1, v2, v2 are on the same side of plane n * x - t = 0 
-  static bool sameSideOfPlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3, const Vector3<S>& n, S t);
-
-  /// @brief clip triangle v1, v2, v3 by the prism made by t1, t2 and t3. The normal of the prism is tn and is cutted up by to 
-  static void clipTriangleByTriangleAndEdgePlanes(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3,
-                                                  const Vector3<S>& t1, const Vector3<S>& t2, const Vector3<S>& t3,
-                                                  const Vector3<S>& tn, S to,
-                                                  Vector3<S> clipped_points[], unsigned int* num_clipped_points, bool clip_triangle = false);
-
-  /// @brief build a plane passed through triangle v1 v2 v3 
-  static bool buildTrianglePlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3, Vector3<S>* n, S* t);
-
-  /// @brief build a plane pass through edge v1 and v2, normal is tn 
-  static bool buildEdgePlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& tn, Vector3<S>* n, S* t);
-
-  /// @brief compute the points which has deepest penetration depth 
-  static void computeDeepestPoints(Vector3<S>* clipped_points, unsigned int num_clipped_points, const Vector3<S>& n, S t, S* penetration_depth, Vector3<S>* deepest_points, unsigned int* num_deepest_points);
-
-  /// @brief clip polygon by plane 
-  static void clipPolygonByPlane(Vector3<S>* polygon_points, unsigned int num_polygon_points, const Vector3<S>& n, S t, Vector3<S> clipped_points[], unsigned int* num_clipped_points);
-
-  /// @brief clip a line segment by plane 
-  static void clipSegmentByPlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& n, S t, Vector3<S>* clipped_point);
-
-  /// @brief compute the cdf(x) 
-  static S gaussianCDF(S x);
-
-  static constexpr S getEpsilon();
-  static constexpr S getNearZeroThreshold();
-  static constexpr S getCcdResolution();
-  static constexpr unsigned int getMaxTriangleClips();
-};
-
-using Intersectf = Intersect<float>;
-using Intersectd = Intersect<double>;
-
-} // namespace detail
-} // namespace fcl
-
-#include "fcl/narrowphase/detail/traversal/collision/intersect-inl.h"
-
-#endif
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#ifndef FCL_NARROWPHASE_DETAIL_INTERSECT_H
+#define FCL_NARROWPHASE_DETAIL_INTERSECT_H
+
+#include <limits>
+#include "fcl/common/types.h"
+#include "fcl/math/geometry.h"
+#include "fcl/math/detail/polysolver.h"
+
+namespace fcl
+{
+
+namespace detail
+{
+
+/// @brief CCD intersect kernel among primitives 
+template <typename S>
+class FCL_EXPORT Intersect
+{
+
+public:
+
+  /// @brief CCD intersect between one vertex and one face
+  /// [a0, b0, c0] and [a1, b1, c1] are points for the triangle face in time t0 and t1
+  /// p0 and p1 are points for vertex in time t0 and t1
+  /// p_i returns the coordinate of the collision point
+  static bool intersect_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
+                           const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& p1,
+                           S* collision_time, Vector3<S>* p_i, bool useNewton = true);
+
+  /// @brief CCD intersect between two edges
+  /// [a0, b0] and [a1, b1] are points for one edge in time t0 and t1
+  /// [c0, d0] and [c1, d1] are points for the other edge in time t0 and t1
+  /// p_i returns the coordinate of the collision point
+  static bool intersect_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                           const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1,
+                           S* collision_time, Vector3<S>* p_i, bool useNewton = true);
+
+  /// @brief CCD intersect between one vertex and one face, using additional filter 
+  static bool intersect_VF_filtered(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
+                                    const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& p1,
+                                    S* collision_time, Vector3<S>* p_i, bool useNewton = true);
+
+  /// @brief CCD intersect between two edges, using additional filter 
+  static bool intersect_EE_filtered(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                    const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1,
+                                    S* collision_time, Vector3<S>* p_i, bool useNewton = true);
+
+  /// @brief CCD intersect between one vertex and and one edge 
+  static bool intersect_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
+                           const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& p1,
+                           const Vector3<S>& L);
+
+  /// @brief CD intersect between two triangles [P1, P2, P3] and [Q1, Q2, Q3]
+  static bool intersect_Triangle(
+      const Vector3<S>& P1,
+      const Vector3<S>& P2,
+      const Vector3<S>& P3,
+      const Vector3<S>& Q1,
+      const Vector3<S>& Q2,
+      const Vector3<S>& Q3,
+      Vector3<S>* contact_points = nullptr,
+      unsigned int* num_contact_points = nullptr,
+      S* penetration_depth = nullptr,
+      Vector3<S>* normal = nullptr);
+
+  /// @brief CD intersect between two triangles [P1, P2, P3] and [Q1, Q2, Q3]
+  static bool intersect_Triangle_ODE_style(
+      const Vector3<S>& P1,
+      const Vector3<S>& P2,
+      const Vector3<S>& P3,
+      const Vector3<S>& Q1,
+      const Vector3<S>& Q2,
+      const Vector3<S>& Q3,
+      Vector3<S>* contact_points = nullptr,
+      unsigned int* num_contact_points = nullptr,
+      S* penetration_depth = nullptr,
+      Vector3<S>* normal = nullptr);
+
+  static bool intersect_Triangle(
+      const Vector3<S>& P1,
+      const Vector3<S>& P2,
+      const Vector3<S>& P3,
+      const Vector3<S>& Q1,
+      const Vector3<S>& Q2,
+      const Vector3<S>& Q3,
+      const Matrix3<S>& R,
+      const Vector3<S>& T,
+      Vector3<S>* contact_points = nullptr,
+      unsigned int* num_contact_points = nullptr,
+      S* penetration_depth = nullptr,
+      Vector3<S>* normal = nullptr);
+
+  static bool intersect_Triangle(
+      const Vector3<S>& P1,
+      const Vector3<S>& P2,
+      const Vector3<S>& P3,
+      const Vector3<S>& Q1,
+      const Vector3<S>& Q2,
+      const Vector3<S>& Q3,
+      const Transform3<S>& tf,
+      Vector3<S>* contact_points = nullptr,
+      unsigned int* num_contact_points = nullptr,
+      S* penetration_depth = nullptr,
+      Vector3<S>* normal = nullptr);
+  
+private:
+
+  /// @brief Project function used in intersect_Triangle() 
+  static int project6(const Vector3<S>& ax,
+                      const Vector3<S>& p1, const Vector3<S>& p2, const Vector3<S>& p3,
+                      const Vector3<S>& q1, const Vector3<S>& q2, const Vector3<S>& q3);
+
+  /// @brief Check whether one value is zero 
+  static bool isZero(S v);
+
+  /// @brief Solve the cubic function using Newton method, also satisfies the interval restriction 
+  static bool solveCubicWithIntervalNewton(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                           const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
+                                           S& l, S& r, bool bVF, S coeffs[], Vector3<S>* data = nullptr);
+
+  /// @brief Check whether one point p is within triangle [a, b, c] 
+  static bool insideTriangle(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& c, const Vector3<S>&p);
+
+  /// @brief Check whether one point p is within a line segment [a, b] 
+  static bool insideLineSegment(const Vector3<S>& a, const Vector3<S>& b, const Vector3<S>& p);
+
+  /// @brief Calculate the line segment papb that is the shortest route between
+  /// two lines p1p2 and p3p4. Calculate also the values of mua and mub where
+  ///                    pa = p1 + mua (p2 - p1)
+  ///                    pb = p3 + mub (p4 - p3)
+  /// return FALSE if no solution exists.
+  static bool linelineIntersect(const Vector3<S>& p1, const Vector3<S>& p2, const Vector3<S>& p3, const Vector3<S>& p4,
+                                Vector3<S>* pa, Vector3<S>* pb, S* mua, S* mub);
+
+  /// @brief Check whether a root for VF intersection is valid (i.e. within the triangle at intersection t 
+  static bool checkRootValidity_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
+                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vp,
+                                   S t);
+
+  /// @brief Check whether a root for EE intersection is valid (i.e. within the two edges intersected at the given time 
+  static bool checkRootValidity_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
+                                   S t, Vector3<S>* q_i = nullptr);
+
+  /// @brief Check whether a root for VE intersection is valid 
+  static bool checkRootValidity_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
+                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp,
+                                   S t);
+
+  /// @brief Solve a square function for EE intersection (with interval restriction) 
+  static bool solveSquare(S a, S b, S c,
+                          const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                          const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
+                          bool bVF,
+                          S* ret);
+
+  /// @brief Solve a square function for VE intersection (with interval restriction) 
+  static bool solveSquare(S a, S b, S c,
+                          const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
+                          const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp);
+
+  /// @brief Compute the cubic coefficients for VF intersection
+  /// See Paper "Interactive Continuous Collision Detection between Deformable Models using Connectivity-Based Culling", Equation 1.
+   
+  static void computeCubicCoeff_VF(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& p0,
+                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vp,
+                                   S* a, S* b, S* c, S* d);
+
+  /// @brief Compute the cubic coefficients for EE intersection 
+  static void computeCubicCoeff_EE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vc, const Vector3<S>& vd,
+                                   S* a, S* b, S* c, S* d);
+
+  /// @brief Compute the cubic coefficients for VE intersection 
+  static void computeCubicCoeff_VE(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& p0,
+                                   const Vector3<S>& va, const Vector3<S>& vb, const Vector3<S>& vp,
+                                   const Vector3<S>& L,
+                                   S* a, S* b, S* c);
+
+  /// @brief filter for intersection, works for both VF and EE 
+  static bool intersectPreFiltering(const Vector3<S>& a0, const Vector3<S>& b0, const Vector3<S>& c0, const Vector3<S>& d0,
+                                    const Vector3<S>& a1, const Vector3<S>& b1, const Vector3<S>& c1, const Vector3<S>& d1);
+
+  /// @brief distance of point v to a plane n * x - t = 0 
+  static S distanceToPlane(const Vector3<S>& n, S t, const Vector3<S>& v);
+
+  /// @brief check wether points v1, v2, v2 are on the same side of plane n * x - t = 0 
+  static bool sameSideOfPlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3, const Vector3<S>& n, S t);
+
+  /// @brief clip triangle v1, v2, v3 by the prism made by t1, t2 and t3. The normal of the prism is tn and is cutted up by to 
+  static void clipTriangleByTriangleAndEdgePlanes(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3,
+                                                  const Vector3<S>& t1, const Vector3<S>& t2, const Vector3<S>& t3,
+                                                  const Vector3<S>& tn, S to,
+                                                  Vector3<S> clipped_points[], unsigned int* num_clipped_points, bool clip_triangle = false);
+
+  /// @brief build a plane passed through triangle v1 v2 v3 
+  static bool buildTrianglePlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& v3, Vector3<S>* n, S* t);
+
+  /// @brief build a plane pass through edge v1 and v2, normal is tn 
+  static bool buildEdgePlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& tn, Vector3<S>* n, S* t);
+
+  /// @brief compute the points which has deepest penetration depth 
+  static void computeDeepestPoints(Vector3<S>* clipped_points, unsigned int num_clipped_points, const Vector3<S>& n, S t, S* penetration_depth, Vector3<S>* deepest_points, unsigned int* num_deepest_points);
+
+  /// @brief clip polygon by plane 
+  static void clipPolygonByPlane(Vector3<S>* polygon_points, unsigned int num_polygon_points, const Vector3<S>& n, S t, Vector3<S> clipped_points[], unsigned int* num_clipped_points);
+
+  /// @brief clip a line segment by plane 
+  static void clipSegmentByPlane(const Vector3<S>& v1, const Vector3<S>& v2, const Vector3<S>& n, S t, Vector3<S>* clipped_point);
+
+  /// @brief compute the cdf(x) 
+  static S gaussianCDF(S x);
+
+  static constexpr S getEpsilon();
+  static constexpr S getNearZeroThreshold();
+  static constexpr S getCcdResolution();
+  static constexpr unsigned int getMaxTriangleClips();
+};
+
+using Intersectf = Intersect<float>;
+using Intersectd = Intersect<double>;
+
+} // namespace detail
+} // namespace fcl
+
+#include "fcl/narrowphase/detail/traversal/collision/intersect-inl.h"
+
+#endif
diff --git a/include/fcl/narrowphase/distance-inl.h b/include/fcl/narrowphase/distance-inl.h
index 3244631..e406efc 100644
--- a/include/fcl/narrowphase/distance-inl.h
+++ b/include/fcl/narrowphase/distance-inl.h
@@ -118,7 +118,7 @@ typename NarrowPhaseSolver::S distance(
   {
     if(!looktable.distance_matrix[node_type2][node_type1])
     {
-      std::cerr << "Warning: distance function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
+      FCL_CERR << "Warning: distance function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
     }
     else
     {
@@ -129,7 +129,7 @@ typename NarrowPhaseSolver::S distance(
   {
     if(!looktable.distance_matrix[node_type1][node_type2])
     {
-      std::cerr << "Warning: distance function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
+      FCL_CERR << "Warning: distance function between node type " << node_type1 << " and node type " << node_type2 << " is not supported\n";
     }
     else
     {
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 425724e..5a0734e 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -50,6 +50,9 @@ endif()
 # Be sure to pass to the consumer the set of SIMD used in the compilation
 target_compile_options(${PROJECT_NAME} PUBLIC ${SSE_FLAGS})
 
+# At least C++11 is required
+target_compile_features(${PROJECT_NAME} PUBLIC cxx_std_11)
+
 set_target_properties(${PROJECT_NAME} PROPERTIES
   VERSION ${FCL_VERSION}
   SOVERSION ${FCL_ABI_VERSION})
diff --git a/src/common/detail/profiler.cpp b/src/common/detail/profiler.cpp
index 6d78ee0..cb1a682 100644
--- a/src/common/detail/profiler.cpp
+++ b/src/common/detail/profiler.cpp
@@ -37,6 +37,12 @@
 
 #include "fcl/common/detail/profiler.h"
 
+#if FCL_ENABLE_PROFILING
+
+#if FCL_ENABLE_STD_LOGGING
+#include <iostream>
+#endif
+
 namespace fcl {
 namespace detail {
 
@@ -58,8 +64,12 @@ Profiler::Profiler(bool printOnDestroy, bool autoStart)
 //==============================================================================
 Profiler::~Profiler()
 {
+#if FCL_ENABLE_STD_LOGGING
   if (printOnDestroy_ && !data_.empty())
-    status();
+    status(std::cerr);
+#else
+  printOnDestroy_ = false;
+#endif
 }
 
 //==============================================================================
@@ -397,3 +407,74 @@ Profiler::ScopedBlock::~ScopedBlock()
 
 } // namespace detail
 } // namespace fcl
+
+#else  // !FCL_ENABLE_PROFILING
+
+namespace fcl {
+namespace detail {
+
+Profiler& Profiler::Instance(void)
+{
+  static Profiler instance(false, false);
+  return instance;
+}
+
+Profiler::Profiler(bool printOnDestroy, bool autoStart)
+  : running_(false), printOnDestroy_(printOnDestroy)
+{
+  (void)autoStart;
+}
+
+Profiler::~Profiler() = default;
+
+void Profiler::Start() {}
+void Profiler::Stop() {}
+void Profiler::Clear() {}
+
+void Profiler::start(void) {}
+void Profiler::stop(void) {}
+void Profiler::clear(void) {}
+
+void Profiler::Event(const std::string&, const unsigned int) {}
+void Profiler::event(const std::string&, const unsigned int) {}
+
+void Profiler::Average(const std::string&, const double) {}
+void Profiler::average(const std::string&, const double) {}
+
+void Profiler::Begin(const std::string&) {}
+void Profiler::End(const std::string&) {}
+void Profiler::begin(const std::string&) {}
+void Profiler::end(const std::string&) {}
+
+void Profiler::Status(std::ostream&, bool) {}
+void Profiler::status(std::ostream&, bool) {}
+
+bool Profiler::running(void) const { return false; }
+bool Profiler::Running(void) { return false; }
+
+Profiler::TimeInfo::TimeInfo()
+  : total(), shortest(), longest(), parts(0)
+{
+}
+
+void Profiler::TimeInfo::set() {}
+void Profiler::TimeInfo::update() {}
+
+Profiler::ScopedBlock::ScopedBlock(const std::string& name, Profiler& prof)
+  : name_(name), prof_(prof)
+{
+}
+
+Profiler::ScopedBlock::~ScopedBlock() = default;
+
+Profiler::ScopedStart::ScopedStart(Profiler& prof)
+  : prof_(prof), wasRunning_(false)
+{
+}
+
+Profiler::ScopedStart::~ScopedStart() = default;
+
+} // namespace detail
+} // namespace fcl
+
+#endif  // FCL_ENABLE_PROFILING
diff --git a/src/geometry/shape/representation.cpp b/src/geometry/shape/representation.cpp
new file mode 100644
index 0000000..97def8b
--- /dev/null
+++ b/src/geometry/shape/representation.cpp
@@ -0,0 +1,44 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2023, Toyota Research Institute
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Sean Curtis */
+
+#include "fcl/geometry/shape/representation.h"
+
+namespace fcl {
+namespace detail {
+
+
+}  // namespace detail
+}  // namespace fcl
diff --git a/src/math/detail/polysolver.cpp b/src/math/detail/polysolver.cpp
index 3aedfa0..975d157 100644
--- a/src/math/detail/polysolver.cpp
+++ b/src/math/detail/polysolver.cpp
@@ -1,49 +1,49 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#include "fcl/math/detail/polysolver-inl.h"
-
-namespace fcl
-{
-
-namespace detail {
-
-template
-class PolySolver<double>;
-
-} // namespace detail
-} // namespace fcl
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#include "fcl/math/detail/polysolver-inl.h"
+
+namespace fcl
+{
+
+namespace detail {
+
+template
+class PolySolver<double>;
+
+} // namespace detail
+} // namespace fcl
diff --git a/src/math/detail/project.cpp b/src/math/detail/project.cpp
index e5bbe94..5b949f9 100644
--- a/src/math/detail/project.cpp
+++ b/src/math/detail/project.cpp
@@ -1,50 +1,50 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#include "fcl/math/detail/project-inl.h"
-
-namespace fcl
-{
-
-namespace detail
-{
-
-template
-class Project<double>;
-
-} // namespace detail
-} // namespace fcl
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#include "fcl/math/detail/project-inl.h"
+
+namespace fcl
+{
+
+namespace detail
+{
+
+template
+class Project<double>;
+
+} // namespace detail
+} // namespace fcl
diff --git a/src/narrowphase/detail/failed_at_this_configuration.cpp b/src/narrowphase/detail/failed_at_this_configuration.cpp
index ba7875d..34815a9 100644
--- a/src/narrowphase/detail/failed_at_this_configuration.cpp
+++ b/src/narrowphase/detail/failed_at_this_configuration.cpp
@@ -1,6 +1,8 @@
 #include "fcl/narrowphase/detail/failed_at_this_configuration.h"
 
+#if FCL_ENABLE_STD_LOGGING
 #include <sstream>
+#endif
 
 namespace fcl {
 namespace detail {
@@ -8,9 +10,16 @@ namespace detail {
 void ThrowFailedAtThisConfiguration(const std::string& message,
                                     const char* func,
                                     const char* file, int line) {
+#if FCL_ENABLE_STD_LOGGING
   std::stringstream ss;
   ss << file << ":(" << line << "): " << func << "(): " << message;
   throw FailedAtThisConfiguration(ss.str());
+#else
+  (void)func;
+  (void)file;
+  (void)line;
+  throw FailedAtThisConfiguration(message);
+#endif
 }
 
 }  // namespace detail
diff --git a/src/narrowphase/detail/primitive_shape_algorithm/intersect.cpp b/src/narrowphase/detail/primitive_shape_algorithm/intersect.cpp
index b4d8a22..3763850 100644
--- a/src/narrowphase/detail/primitive_shape_algorithm/intersect.cpp
+++ b/src/narrowphase/detail/primitive_shape_algorithm/intersect.cpp
@@ -1,50 +1,50 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#include "fcl/narrowphase/detail/traversal/collision/intersect-inl.h"
-
-namespace fcl
-{
-
-namespace detail
-{
-
-template
-class Intersect<double>;
-
-} // namespace detail
-} // namespace fcl
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#include "fcl/narrowphase/detail/traversal/collision/intersect-inl.h"
+
+namespace fcl
+{
+
+namespace detail
+{
+
+template
+class Intersect<double>;
+
+} // namespace detail
+} // namespace fcl
diff --git a/src/narrowphase/detail/primitive_shape_algorithm/triangle_distance.cpp b/src/narrowphase/detail/primitive_shape_algorithm/triangle_distance.cpp
index 2bb3a20..637e42d 100644
--- a/src/narrowphase/detail/primitive_shape_algorithm/triangle_distance.cpp
+++ b/src/narrowphase/detail/primitive_shape_algorithm/triangle_distance.cpp
@@ -1,51 +1,51 @@
-/*
- * Software License Agreement (BSD License)
- *
- *  Copyright (c) 2011-2014, Willow Garage, Inc.
- *  Copyright (c) 2014-2016, Open Source Robotics Foundation
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions
- *  are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above
- *     copyright notice, this list of conditions and the following
- *     disclaimer in the documentation and/or other materials provided
- *     with the distribution.
- *   * Neither the name of Open Source Robotics Foundation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- *  POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** @author Jia Pan */
-
-#include "fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance-inl.h"
-
-namespace fcl
-{
-
-namespace detail
-{
-
-//==============================================================================
-template
-class TriangleDistance<double>;
-
-} // namespace detail
-} // namespace fcl
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011-2014, Willow Garage, Inc.
+ *  Copyright (c) 2014-2016, Open Source Robotics Foundation
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Open Source Robotics Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** @author Jia Pan */
+
+#include "fcl/narrowphase/detail/primitive_shape_algorithm/triangle_distance-inl.h"
+
+namespace fcl
+{
+
+namespace detail
+{
+
+//==============================================================================
+template
+class TriangleDistance<double>;
+
+} // namespace detail
+} // namespace fcl
