# FCL 完整内核移植提案

## 📦 提案文档总览

本目录包含 FCL (Flexible Collision Library) 完整移植到 Windows 内核驱动的详细提案和实施计划。

---

## 📄 文档清单

### 核心提案文档

1. **`proposal.md`** ⭐
   - 提案概要和目标
   - 为什么需要这个移植
   - 影响分析和风险评估
   - 修订后的时间线（36-49 周）

2. **`design.md`**
   - 技术架构设计
   - 关键技术决策（7 个）
   - API 设计
   - 性能和安全考虑

3. **`tasks.md`**
   - 10 个阶段的实施任务清单
   - 70+ 个具体任务
   - 每个任务的验收标准

4. **`specs/collision-detection/spec.md`**
   - 功能规范（15 个需求）
   - 60+ 个测试场景
   - 性能要求和约束

---

### 深度分析报告

5. **`TECHNICAL_ANALYSIS.md`** 🔍 **必读**
   - FCL 源码深度分析（34,155 行）
   - STL 依赖分析（20+ 组件）
   - Eigen 集成挑战
   - 修订后的时间评估（vs 原始）
   - 4 个备选方案对比

6. **`CCD_ANALYSIS.md`** 🔍 **必读**
   - 连续碰撞检测（CCD）专项分析
   - 泰勒模型（3,714 行数学代码）
   - 区间算术和舍入控制
   - 保守推进算法
   - CCD 带来的额外复杂度（+177%）

---

### 实施指南

7. **`IMPLEMENTATION_ROADMAP.md`** 🚀 **最重要**
   - 分阶段详细实施计划（81 周）
   - 关键决策点和验收标准
   - 概念验证（PoC）设计
   - 风险缓解策略
   - 代码示例和测试用例
   - 周报模板和进度跟踪

---

## 🎯 项目概览

### 规模和复杂度

| 指标 | 数值 |
|------|------|
| 总代码量 | 27,714 行（静态 10,000 + CCD 17,714） |
| 文件数 | 150+ 个 |
| 模板使用 | 2,883 处 |
| 需修改文件 | 80+ 个（移除 I/O） |
| 预计工作量 | **36-49 周（9-12 个月）** |
| 成功率估计 | **< 30%** |
| 风险等级 | 🔴 **极高** |

### 关键技术挑战

1. **数学函数库**（阻断性）
   - 需要实现 sin, cos, exp, log, sqrt
   - 内核没有 `<cmath>` 库
   - 工作量：4-6 周

2. **泰勒模型**（极复杂）
   - 3,714 行纯数学代码
   - 区间算术 + 舍入控制
   - 工作量：10-14 周

3. **Eigen 适配**（深度集成）
   - FCL 核心完全依赖 Eigen
   - 必须禁用 SIMD（性能下降 30-50%）
   - 工作量：8-12 周

4. **I/O 操作移除**（繁琐）
   - 80+ 文件使用 cout/cerr
   - 必须全部移除或替换
   - 工作量：4-6 周

---

## 📅 时间线概览

### 阶段 0：风险验证（第 1-4 周）⭐ 最关键
- Musa.Runtime 验证
- 数学函数库可行性验证
- **决策点 1**：Go / No-Go

### 阶段 1：基础设施（第 5-12 周）
- 环境搭建
- 数学函数库实现（fdlibm）
- 内存管理系统

### 阶段 2：Eigen 和 libccd（第 13-24 周）
- Eigen 核心适配
- Eigen 高级功能测试
- libccd 移植

### 阶段 3：静态碰撞检测（第 25-34 周）
- 几何对象
- 碰撞检测核心
- API 和测试
- **里程碑**：静态碰撞可用

### 阶段 4：区间算术和泰勒模型（第 35-48 周）🔴 最难
- 区间算术核心
- 区间数学函数
- 泰勒模型实现
- **决策点 4**：精度验证

### 阶段 5：运动模型（第 49-56 周）
- Translation, Interp, Screw, Spline

### 阶段 6：连续碰撞检测（第 57-64 周）
- 保守推进算法
- CCD 遍历节点

### 阶段 7：I/O 操作移除（第 65-70 周）
- 移除 cout/cerr
- 实现内核日志

### 阶段 8：集成测试和优化（第 71-78 周）
- 功能测试
- 性能优化
- Driver Verifier

### 阶段 9：文档和交付（第 79-81 周）
- 文档和代码审查

---

## ⚠️ 风险评估

### 阻断性风险

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| 数学库无法实现 | 20% | 致命 | 阶段 0 验证 |
| 泰勒模型精度不足 | 30% | 严重 | 降级方案 |
| Eigen 性能过差 | 40% | 严重 | 性能优化 |
| 内存泄漏频繁 | 50% | 中等 | Driver Verifier |

### 项目失败场景

**失败定义**：项目无法达到可用状态

**估计概率**：**70%**（成功率 < 30%）

**失败原因可能包括**：
- 数学库性能不可接受
- 泰勒模型无法正确实现
- CCD 性能远低于预期
- 稳定性问题无法解决
- 时间/资源耗尽

---

## 💡 替代方案

### 如果项目遇到困难，考虑：

**方案 B：简化内核 CCD**
- 放弃泰勒模型
- 仅支持简单运动
- 时间：20-28 周

**方案 C：用户态 CCD + 内核静态碰撞**（推荐降级）
- CCD 在用户态（完整功能）
- 内核仅做静态碰撞
- 时间：12-16 周
- 成功率：80%

**方案 D：从头实现简化版**
- 自己实现基本 CCD
- 时间：8-12 周

---

## 🚀 开始实施

### 前置条件检查清单

在开始前，确认：

- [ ] ✅ 有 9-12 个月的项目时间预算
- [ ] ✅ 团队至少 3 人（内核专家 + 数值算法专家 + C++ 专家）
- [ ] ✅ 有充足的测试环境（虚拟机、调试工具）
- [ ] ✅ 管理层理解并接受 < 30% 的成功率
- [ ] ✅ 有降级方案的预算和计划

### 第一步：阅读文档

**必读文档（按顺序）**：
1. `TECHNICAL_ANALYSIS.md` - 了解技术复杂度
2. `CCD_ANALYSIS.md` - 了解 CCD 挑战
3. `IMPLEMENTATION_ROADMAP.md` - 实施计划
4. `proposal.md` - 提案概要
5. `design.md` - 技术设计

### 第二步：启动阶段 0

**时间**：第 1-4 周

**目标**：验证关键技术可行性

**任务**：
1. 创建 PoC-01-MusaRuntime（验证 Musa.Runtime）
2. 创建 PoC-02-MathLib（验证数学函数库）
3. 决策：Go / No-Go

**详细步骤见**：`IMPLEMENTATION_ROADMAP.md` 阶段 0

---

## 📞 支持和问题

### 如果遇到以下情况，立即寻求帮助：

- ❌ 阶段 0 验证失败（数学库或 Musa.Runtime）
- ❌ 进度严重滞后（> 2 周）
- ❌ 发现新的阻断性技术问题
- ❌ 性能指标无法满足
- ❌ 稳定性问题频繁（频繁 BSOD）

### 建议的决策点

每个阶段都有验收标准和决策点：

- **第 4 周**：决策点 1（数学库可行性）
- **第 12 周**：决策点 2（基础设施稳定性）
- **第 24 周**：决策点 3（Eigen 性能）
- **第 48 周**：决策点 4（泰勒模型精度）

在每个决策点，评估：
1. 是否达到验收标准？
2. 是否继续还是降级？
3. 资源和时间是否充足？

---

## 📊 进度跟踪

### 建议的周报格式

```markdown
# 第 X 周进度报告

## 完成的任务
- [x] 任务 A
- [x] 任务 B

## 遇到的问题
- 问题 1：描述
  - 影响：高/中/低
  - 解决方案：...

## 下周计划
- [ ] 任务 C
- [ ] 任务 D

## 风险和警示
- 风险 1：...

## 关键指标
- 代码完成率：X%
- 测试覆盖率：X%
- 性能达标率：X/Y 模块
```

---

## 🎓 学习资源

### Windows 内核驱动开发
- [Windows Driver Development 文档](https://learn.microsoft.com/en-us/windows-hardware/drivers/)
- [WDK 下载](https://learn.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk)

### 数值计算和几何算法
- FCL 论文：[FCL: A General Purpose Library for Collision and Proximity Queries](https://gamma.cs.unc.edu/FCL/fcl_docs/webpage/pdfs/fcl_icra2012.pdf)
- GJK 算法：Gilbert-Johnson-Keerthi 算法文档
- 泰勒模型：区间算术和泰勒模型理论

### C++ 模板和 Eigen
- [Eigen 官方文档](https://eigen.tuxfamily.org/)
- C++ Templates: The Complete Guide (书籍)

---

## 🏁 总结

这是一个**极具挑战性的项目**，需要：

✅ 深厚的技术功底
✅ 充足的时间和资源
✅ 强大的团队支持
✅ 对风险的清晰认识

**但如果成功，你将拥有：**

🏆 世界上罕见的内核态碰撞检测库
🏆 完整的 CCD 功能
🏆 宝贵的技术经验

**准备好开始这个史诗般的旅程了吗？**

---

**下一步**：阅读 `IMPLEMENTATION_ROADMAP.md` 并启动阶段 0。

## ✅ 阶段进展速记（2025-11-11）
- **P4.1**：新增 `IOCTL_FCL_SELF_TEST`，串联初始化→几何→碰撞→销毁，始终在 PASSIVE_LEVEL 执行。
- **P4.2**：`FCL_SELF_TEST_RESULT` 汇报阶段 NTSTATUS、接触信息与池差值，便于 CI / WinDbg 比对。
- **P4.3**：提供 `tools/fcl-self-test.ps1`（PowerShell），一键运行 Ping + SelfTest，可输出 JSON 并以退出码反映通过/失败。
- **P5.1**：自检流程新增无效参数/句柄路径，确保 `STATUS_INVALID_PARAMETER`/`STATUS_INVALID_HANDLE` 触发且池差值为零。
- **P5.2**：所有阶段性/边界状态在 `FCL_SELF_TEST_RESULT` 中统一曝光，脚本解析后可直接核对 NTSTATUS。
- **P6.2**：碰撞内核支持 Sphere-OBB 与 OBB-OBB 判定（SAT + 最近点），并输出法线、穿透与接触点，满足 FCL 洛谷级几何的最小落地。
- **P6.3**：距离 API 覆盖 Sphere-Sphere、Sphere-OBB、OBB-OBB，返回最近点及距离值，并纳入自检脚本输出。
- **P6.5**：接入 GJK 窄相（libccd 样式），为 Sphere/OBB/Mesh 等凸体提供支持函数，未知组合自动回退到 GJK，并由自检 Mesh 场景验证。
- **P6.3**：距离 API 覆盖 Sphere-Sphere、Sphere-OBB、OBB-OBB，返回最近点及距离值，并纳入自检脚本输出.
- **P2.1**：完成 Sphere/OBB/Mesh 几何描述以及内核句柄定义，全部驻留 NonPagedPool 并通过 RAII 管理。
- **P2.2**：新增 `FclCreateGeometry`/`FclDestroyGeometry` API，覆盖参数校验、内存不足兜底与异常回滚路径。
- **P2.3**：实现几何句柄表、PushLock 并发保护和 DriverState 集成，`FclQueryHealth` 维持与池统计一致的生命周期。
- **P3.1**：完成 Sphere-Sphere 判定（FclCollisionDetect），输出布尔状态 + 接触信息，约束 PASSIVE_LEVEL 并返回未实现错误给其余类型。
- **P3.2**：新增碰撞烟雾测试，覆盖穿透/分离/边界三类场景，启动阶段即在 PASSIVE_LEVEL 自检。
- **P3.3**：统一错误码与参数校验，涵盖 IRQL、句柄、Transform 合法性以及未实现组合的 `STATUS_NOT_IMPLEMENTED`。

祝你好运！🚀






