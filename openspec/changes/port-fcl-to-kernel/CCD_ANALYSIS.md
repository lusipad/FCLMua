# 连续碰撞检测（CCD）专项分析

## 执行摘要

**连续碰撞检测是 FCL 中最复杂的模块之一**。加入 CCD 需求后，项目复杂度**显著增加 40-60%**，需要移植额外的高级数学库和算法。

---

## 一、CCD 模块规模分析

### 1.1 代码规模统计

| 模块 | 文件数 | 代码行数 | 复杂度 |
|------|--------|----------|--------|
| **CCD 核心** | 10 个 | 约 2,500 行 | 🔴 高 |
| **运动学模型** | 29 个 | 约 5,000 行 | 🔴 极高 |
| **泰勒模型** | 13 个 | **3,714 行** | 🔴 **极高** |
| **保守推进算法** | 12 个 | 约 4,000 行 | 🔴 高 |
| **遍历节点（Traversal）** | 6 个 | 约 2,500 行 | 🟡 中 |
| **总计** | **70+ 个** | **约 17,714 行** | 🔴 **极高** |

### 1.2 与静态碰撞检测对比

```
静态碰撞检测核心：    ~10,000 行
CCD 额外增加：        ~17,714 行
总计（含 CCD）：      ~27,714 行

增加比例：+177%
```

**结论**：加入 CCD 后，需要移植的核心代码量增加了 **1.77 倍**！

---

## 二、CCD 核心组件分析

### 2.1 运动模型（Motion Models）

FCL 支持 **4 种运动模型**，用于描述物体在时间区间内的运动轨迹：

#### 1) **TranslationMotion**（平移运动）
```cpp
// 最简单：纯平移
// 公式：p(t) = p0 + v * t
```
- **复杂度**：🟢 低
- **用途**：直线运动物体

#### 2) **InterpMotion**（插值运动）
```cpp
// 在起始和结束姿态之间进行插值
// 旋转：四元数球面线性插值（SLERP）
// 平移：线性插值（LERP）
```
- **复杂度**：🟡 中
- **用途**：两个关键帧之间的运动
- **依赖**：Eigen 的四元数运算

#### 3) **ScrewMotion**（螺旋运动）
```cpp
// 沿螺旋轴的旋转+平移
// 公式：基于 Rodrigues 旋转公式
```
- **复杂度**：🔴 高
- **用途**：机器人关节、螺丝运动
- **依赖**：复杂的 Eigen 矩阵运算

#### 4) **SplineMotion**（样条运动）
```cpp
// 使用样条曲线描述运动轨迹
// 支持 3 次 B-spline
```
- **复杂度**：🔴 极高
- **用途**：复杂轨迹规划
- **依赖**：大量 Eigen 运算

**问题**：
- 每种运动模型都需要独立实现和测试
- 需要大量浮点运算（内核态性能问题）
- 依赖 Eigen 的高级功能（四元数、旋转矩阵）

---

### 2.2 泰勒模型（Taylor Model）

#### 什么是泰勒模型？

泰勒模型是一种**高阶数值方法**，用于：
- 对函数在时间区间内进行**三次多项式逼近**
- 提供**严格的误差边界**（区间余项）
- 用于运动轨迹的**保守估计**

#### 数学原理

```
对于函数 f(t) 在时间区间 [t0, t1]：

f(t) ≈ c0 + c1*(t-t0) + c2*(t-t0)^2 + c3*(t-t0)^3 + [r_min, r_max]

其中：
- c0, c1, c2, c3 是泰勒系数
- [r_min, r_max] 是区间余项（误差边界）
```

#### 泰勒模型的组件

```cpp
// 1. Interval（区间算术）
class Interval {
    double lower_bound;  // 下界
    double upper_bound;  // 上界
    // 支持区间加减乘除、三角函数等
};

// 2. TaylorModel（泰勒模型）
class TaylorModel {
    double coeffs[4];        // 4 个系数（3 次多项式）
    Interval remainder;      // 区间余项
    TimeInterval time;       // 时间区间
    // 支持复杂运算
};

// 3. TaylorVector（泰勒向量）
class TaylorVector {
    TaylorModel x, y, z;  // 3D 向量的每个分量
};

// 4. TaylorMatrix（泰勒矩阵）
class TaylorMatrix {
    TaylorModel data[3][3];  // 3x3 矩阵
};
```

#### 复杂度分析

**泰勒模型子模块（3,714 行代码）包含：**

| 文件 | 行数 | 功能 | 复杂度 |
|------|------|------|--------|
| `interval.h/.inl` | ~1,000 行 | 区间算术（+, -, *, /, sqrt, sin, cos, exp, log） | 🔴 高 |
| `interval_vector.h/.inl` | ~800 行 | 区间向量运算 | 🔴 高 |
| `interval_matrix.h/.inl` | ~1,000 行 | 区间矩阵运算 | 🔴 高 |
| `taylor_model.h/.inl` | ~900 行 | 泰勒模型核心 | 🔴 极高 |
| `taylor_vector.h/.inl` | ~700 行 | 泰勒向量 | 🔴 高 |
| `taylor_matrix.h/.inl` | ~1,000 行 | 泰勒矩阵 | 🔴 极高 |
| `time_interval.h/.inl` | ~200 行 | 时间区间 | 🟢 低 |

**关键挑战**：

1. **精度问题**：泰勒模型需要高精度浮点运算
   - 内核态浮点运算可能有精度损失
   - 区间算术对舍入误差敏感

2. **性能问题**：区间运算比标量运算慢 **5-10 倍**
   - 每次运算都要计算上下界
   - 大量分支判断

3. **数学函数**：需要实现区间版本的 sin, cos, exp, log, sqrt
   - 内核没有标准数学库
   - 需要自己实现或适配

---

### 2.3 保守推进算法（Conservative Advancement）

#### 算法原理

保守推进是 CCD 的核心算法：

```
输入：两个运动物体 O1(t), O2(t)，时间区间 [0, T]
输出：碰撞时间 t_collision（如果存在）

算法流程：
1. t = 0
2. while t < T:
   a) 计算当前时刻 t 的距离 d(t)
   b) 计算距离变化率的上界 d_dot_max
   c) 计算安全步长 Δt = d(t) / d_dot_max  （保守估计）
   d) 检查 t + Δt 时刻是否碰撞
   e) 如果碰撞，返回 t_collision
   f) t = t + Δt
3. 返回无碰撞
```

**关键点**：
- 需要计算距离函数的**上界估计**
- 使用泰勒模型估计运动轨迹
- 需要迭代多次（通常 10-100 次）

#### 代码结构

```
Conservative Advancement 模块（~4,000 行）：

1. conservative_advancement_func_matrix.h/.inl
   - 函数矩阵，定义不同形状对之间的 CA 算法
   - 类似静态碰撞检测的分发表

2. mesh_conservative_advancement_traversal_node.h/.inl
   - 网格对象的 CA 遍历
   - 使用 BVH 加速

3. shape_conservative_advancement_traversal_node.h/.inl
   - 基本形状的 CA 算法

4. mesh_shape_conservative_advancement_traversal_node.h/.inl
   - 网格-形状混合的 CA 算法

5. conservative_advancement_stack_data.h/.inl
   - CA 算法的栈数据结构
```

**复杂度**：
- 249 处调用保守推进相关函数
- 需要与泰勒模型紧密集成
- 需要 BVH 遍历支持

---

## 三、CCD 的技术挑战

### 3.1 浮点运算密集

CCD 涉及**极其密集的浮点运算**：

| 操作 | 每次 CCD 查询的运算次数 |
|------|------------------------|
| 向量加减乘 | 500-1000 次 |
| 矩阵乘法 | 100-500 次 |
| 三角函数（sin/cos） | 50-200 次 |
| 平方根 | 50-100 次 |
| 指数/对数 | 10-50 次 |

**内核问题**：
1. 必须在 DISPATCH_LEVEL 或 PASSIVE_LEVEL 保存浮点状态
2. 浮点运算在内核态有额外开销（20-50%）
3. 缺少优化的数学库（libm）

---

### 3.2 区间算术的特殊挑战

区间算术需要正确的**舍入模式控制**：

```cpp
// 区间加法需要：
// [a, b] + [c, d] = [a+c (向下舍入), b+d (向上舍入)]

// 在 x86 上需要设置 FPU 控制字
_controlfp(_RC_DOWN, _MCW_RC);  // 向下舍入
lower = a + c;

_controlfp(_RC_UP, _MCW_RC);    // 向上舍入
upper = b + d;

_controlfp(_RC_NEAR, _MCW_RC);  // 恢复默认
```

**内核问题**：
- 修改 FPU 状态需要保存/恢复
- 多线程环境下可能有竞争
- 增加 **50-100%** 的计算开销

---

### 3.3 数学函数库依赖

泰勒模型需要以下数学函数的**区间版本**：

```cpp
// 需要实现的区间函数：
Interval sin(const Interval& x);
Interval cos(const Interval& x);
Interval exp(const Interval& x);
Interval log(const Interval& x);
Interval sqrt(const Interval& x);
Interval pow(const Interval& x, int n);
Interval atan2(const Interval& y, const Interval& x);
```

**问题**：
- Windows 内核没有 `<cmath>` 库
- 需要自己实现或移植 libm
- 区间版本比标量版本复杂 **3-5 倍**

**工作量**：**4-6 周**

---

### 3.4 迭代算法的收敛性

保守推进算法是**迭代算法**，可能的问题：

1. **不收敛**：某些病态情况下步长越来越小
2. **迭代次数过多**：性能问题
3. **数值误差累积**：精度损失

**内核限制**：
- 不能无限迭代（可能导致死循环）
- 需要设置最大迭代次数和超时
- 错误处理更严格

---

## 四、CCD 移植工作量评估

### 4.1 分阶段评估

| 阶段 | 任务 | 工作量 | 风险 |
|------|------|--------|------|
| **阶段 1** | 运动模型基础 | 2-3 周 | 🟡 中 |
| | - TranslationMotion | 3 天 | 🟢 低 |
| | - InterpMotion | 1 周 | 🟡 中 |
| | - ScrewMotion | 1 周 | 🔴 高 |
| | - SplineMotion（可选） | 2 周 | 🔴 极高 |
| **阶段 2** | 区间算术 | 4-6 周 | 🔴 极高 |
| | - Interval 核心 | 2 周 | 🔴 高 |
| | - 数学函数（sin/cos/exp/log） | 2-3 周 | 🔴 极高 |
| | - IntervalVector/Matrix | 1-2 周 | 🟡 中 |
| **阶段 3** | 泰勒模型 | 6-8 周 | 🔴 极高 |
| | - TaylorModel 核心 | 2-3 周 | 🔴 高 |
| | - TaylorVector | 1-2 周 | 🟡 中 |
| | - TaylorMatrix | 2-3 周 | 🔴 高 |
| | - 运动边界计算 | 1-2 周 | 🔴 高 |
| **阶段 4** | 保守推进算法 | 5-7 周 | 🔴 高 |
| | - CA 核心算法 | 2-3 周 | 🔴 高 |
| | - 形状-形状 CA | 1-2 周 | 🟡 中 |
| | - 网格-网格 CA | 2-3 周 | 🔴 高 |
| **阶段 5** | CCD 集成和测试 | 4-5 周 | 🔴 高 |
| | - API 封装 | 1 周 | 🟢 低 |
| | - 单元测试 | 2-3 周 | 🟡 中 |
| | - 性能优化 | 2 周 | 🔴 高 |
| **总计** | | **21-29 周** | 🔴 **极高** |

### 4.2 对比：静态 vs CCD

| 项目 | 仅静态碰撞 | 静态 + CCD | 增加 |
|------|-----------|-----------|------|
| 代码量 | ~10,000 行 | ~27,714 行 | +177% |
| 文件数 | 50 个 | 120+ 个 | +140% |
| 工作量 | 15-20 周 | **36-49 周** | +140% |
| 复杂度 | 高 | **极高** | +100% |

---

## 五、性能影响分析

### 5.1 理论性能对比

| 操作 | 静态碰撞检测 | CCD | 性能比 |
|------|-------------|-----|--------|
| 简单形状（球-球） | < 1 ms | 5-20 ms | 5-20x |
| 复杂形状（盒-盒） | 1-2 ms | 10-50 ms | 10-25x |
| 网格（1000 三角形） | 5-10 ms | 50-200 ms | 10-20x |

**结论**：CCD 比静态碰撞检测慢 **10-25 倍**

### 5.2 内核态额外开销

| 因素 | 开销 |
|------|------|
| 浮点状态保存/恢复 | +20-30% |
| 区间算术舍入控制 | +50-100% |
| 缺少 SIMD 优化 | +30-50% |
| 数学函数（无 libm） | +20-40% |
| **总开销** | **+120-220%** |

**结论**：内核态 CCD 可能比用户态慢 **2.2-3.2 倍**

---

## 六、关键风险和阻断问题

### 🔴 阻断性问题

| # | 问题 | 影响 | 解决方案 |
|---|------|------|----------|
| 1 | **数学函数库缺失** | 无法编译区间算术 | 移植 libm 或自己实现 |
| 2 | **区间舍入控制** | 精度无法保证 | 实现 FPU 控制封装 |
| 3 | **迭代算法稳定性** | 可能死循环或崩溃 | 严格的超时和边界检查 |
| 4 | **浮点运算性能** | CCD 可能太慢（> 200ms） | 需要大量优化 |

### 🟡 严重问题

| # | 问题 | 影响 | 缓解措施 |
|---|------|------|----------|
| 5 | **泰勒模型的精度** | 保守估计可能过于保守 | 调参和测试 |
| 6 | **SplineMotion 复杂度** | 实现极其困难 | 暂不支持 |
| 7 | **内存分配频繁** | 迭代过程大量分配 | 内存池优化 |

---

## 七、修订后的方案建议

### 方案 A：完整 CCD（不推荐）❌

**包含**：
- 所有 4 种运动模型
- 完整泰勒模型
- 所有形状对的 CA 算法

**时间**：36-49 周（**9-12 个月**）
**风险**：🔴 极高
**成功率**：< 20%

**结论**：**不现实**

---

### 方案 B：简化 CCD（勉强可行）⚠️

**包含**：
- ✅ TranslationMotion（纯平移）
- ✅ InterpMotion（插值运动）
- ✅ 简化的区间算术（无复杂数学函数）
- ✅ 基本形状的 CA 算法
- ❌ SplineMotion、ScrewMotion
- ❌ 泰勒模型的高级功能
- ❌ 网格的 CCD

**时间**：20-28 周（**5-7 个月**）
**风险**：🔴 高
**成功率**：40-50%

**限制**：
- 只支持简单运动
- 精度较低
- 性能一般

---

### 方案 C：用户态 CCD + 内核静态碰撞（推荐）⭐

**架构**：
```
┌──────────────────────────────────┐
│   用户态服务                      │
│   - 完整 FCL（含 CCD）            │
│   - 性能好、稳定                  │
└────────────┬─────────────────────┘
             │ 共享内存 / IOCTL
┌────────────┴─────────────────────┐
│   内核驱动                        │
│   - 仅静态碰撞检测                │
│   - 轻量、可靠                    │
└──────────────────────────────────┘
```

**优点**：
- CCD 在用户态，性能好
- 内核驱动简单，稳定性高
- 开发时间短：**12-16 周**（3-4 个月）

**缺点**：
- 上下文切换开销
- 不适合极高频 CCD（> 1000次/秒）

**适用场景**：
- CCD 调用频率 < 1000次/秒
- 可以容忍 0.1-0.5ms 的上下文切换开销

---

### 方案 D：从头实现简化 CCD（可考虑）🤔

**自己实现**：
- 仅支持 TranslationMotion
- 使用保守包围盒方法（Swept AABB）
- 不使用泰勒模型

**优点**：
- 代码量小（1000-2000 行）
- 完全控制
- 时间：**8-12 周**（2-3 个月）

**缺点**：
- 功能有限
- 精度较低
- 需要算法专业知识

---

## 八、性能要求澄清

在选择方案前，请明确你的性能需求：

### 问题 1：CCD 调用频率

- **低频**（< 100次/秒）→ 方案 C（用户态）最佳
- **中频**（100-1000次/秒）→ 方案 C 可行
- **高频**（> 1000次/秒）→ 方案 B 或 D

### 问题 2：延迟要求

- **可接受 10-50ms** → 方案 C 完全可行
- **需要 1-10ms** → 方案 B 勉强可行
- **需要 < 1ms** → **不可能**（CCD 本身就需要 5-20ms）

### 问题 3：运动类型

- **仅直线运动** → 方案 D（自己实现）
- **直线 + 旋转** → 方案 B 或 C
- **复杂轨迹** → 方案 C（用户态完整 FCL）

---

## 九、最终建议

基于以上分析，我的建议是：

### 🥇 首选：方案 C（用户态 CCD + 内核静态碰撞）

**理由**：
1. **性价比最高**：3-4 个月完成
2. **风险最低**：分离关注点
3. **性能足够**：适合大多数场景
4. **可维护**：用户态 FCL 易于调试

**实施路线**：
1. **第 1-2 周**：架构设计 + PoC
2. **第 3-8 周**：内核静态碰撞检测
3. **第 9-12 周**：用户态服务 + 共享内存通信
4. **第 13-16 周**：集成测试 + 优化

---

### 🥈 备选：方案 B（简化 CCD）

**仅当以下条件满足时考虑**：
- ✅ 调用频率 > 1000次/秒
- ✅ 延迟要求 < 10ms
- ✅ 可接受功能受限
- ✅ 有 6-7 个月时间
- ✅ 团队有数值算法专家

**警告**：成功率仅 40-50%

---

## 十、决策矩阵

| 标准 | 方案 A | 方案 B | 方案 C ⭐ | 方案 D |
|------|--------|--------|---------|--------|
| 功能完整性 | ✅✅✅ | ⚠️⚠️ | ✅✅✅ | ⚠️ |
| 开发时间 | 9-12 月 | 5-7 月 | **3-4 月** | 2-3 月 |
| 技术风险 | 🔴 极高 | 🔴 高 | 🟢 **低** | 🟡 中 |
| 成功率 | 20% | 40% | **80%** | 60% |
| 性能（CCD） | 好 | 中 | **好** | 中 |
| 可维护性 | 差 | 差 | **好** | 好 |
| 内存占用 | 大 | 中 | **小** | 小 |

---

## 十一、后续行动

### 立即行动

1. **澄清需求**（1 周）
   - 确认 CCD 调用频率
   - 确认延迟要求
   - 确认运动类型

2. **选择方案**（决策会议）
   - 根据需求选择方案
   - 评估资源和时间
   - 获得团队共识

3. **创建 PoC**（2-3 周）
   - 如果选方案 C：验证共享内存通信性能
   - 如果选方案 B：验证简化区间算术 + Musa.Runtime

### 如果选择方案 C（推荐）

进入快速原型开发：
- 周 1-2：用户态 FCL 集成 + 内核驱动框架
- 周 3-4：共享内存通信机制
- 周 5-8：内核静态碰撞检测
- 周 9-12：用户态 CCD 服务
- 周 13-16：测试和优化

---

**报告完成日期**：2025-11-11
**分析人员**：Claude (Sonnet 4.5)
**建议执行方案**：**方案 C（用户态 CCD + 内核静态碰撞）**

